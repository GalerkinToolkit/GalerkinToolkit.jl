<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to the FEM · GalerkinToolkit.jl</title><meta name="title" content="Introduction to the FEM · GalerkinToolkit.jl"/><meta property="og:title" content="Introduction to the FEM · GalerkinToolkit.jl"/><meta property="twitter:title" content="Introduction to the FEM · GalerkinToolkit.jl"/><meta name="description" content="Documentation for GalerkinToolkit.jl."/><meta property="og:description" content="Documentation for GalerkinToolkit.jl."/><meta property="twitter:description" content="Documentation for GalerkinToolkit.jl."/><meta property="og:url" content="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/tutorial_intro_to_fem/"/><meta property="twitter:url" content="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/tutorial_intro_to_fem/"/><link rel="canonical" href="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/tutorial_intro_to_fem/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GalerkinToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GalerkinToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/">Manual</a></li><li><a class="tocitem" href="../../manual/introduction/">Introduction</a></li><li><a class="tocitem" href="../manual_meshes/">Meshes</a></li><li><a class="tocitem" href="../manual_domains/">Domains</a></li><li><a class="tocitem" href="../manual_interpolation/">Interpolation</a></li><li><a class="tocitem" href="../manual_visualization/">Visualization</a></li><li><a class="tocitem" href="../../manual/for_developers/">For developers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../example_hello_world/">Hello, World!</a></li><li><a class="tocitem" href="../example_poisson_equation/">Poisson equation</a></li><li><a class="tocitem" href="../example_p_laplacian/">p-Laplacian</a></li><li><a class="tocitem" href="../example_stokes/">Stokes lid-driven cavity</a></li><li><a class="tocitem" href="../example_transient_heat_eq/">Transient heat equation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/">Tutorials</a></li><li class="is-active"><a class="tocitem" href>Introduction to the FEM</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement"><span>Problem statement</span></a></li><li><a class="tocitem" href="#The-method-of-manufactured-solutions"><span>The method of manufactured solutions</span></a></li><li><a class="tocitem" href="#Numerical-approximation"><span>Numerical approximation</span></a></li><li><a class="tocitem" href="#Workflow"><span>Workflow</span></a></li><li><a class="tocitem" href="#Mesh-generation"><span>Mesh generation</span></a></li><li><a class="tocitem" href="#Computational-domains"><span>Computational domains</span></a></li><li><a class="tocitem" href="#FE-space"><span>FE space</span></a></li><li><a class="tocitem" href="#Dual-operators"><span>Dual operators</span></a></li><li><a class="tocitem" href="#FE-interpolation"><span>FE interpolation</span></a></li><li><a class="tocitem" href="#Free-and-Dirichlet-DOFs"><span>Free and Dirichlet DOFs</span></a></li><li><a class="tocitem" href="#Dirichlet-Field"><span>Dirichlet Field</span></a></li><li><a class="tocitem" href="#The-weighted-residual-method"><span>The weighted residual method</span></a></li><li><a class="tocitem" href="#System-of-linear-algebraic-equations"><span>System of linear algebraic equations</span></a></li><li><a class="tocitem" href="#FE-error"><span>FE error</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../reference/">API</a></li><li><a class="tocitem" href="../../refindex/">Index</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Introduction to the FEM</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction to the FEM</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/main/docs/src/src_jl/tutorial_intro_to_fem.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction-to-the-FEM"><a class="docs-heading-anchor" href="#Introduction-to-the-FEM">Introduction to the FEM</a><a id="Introduction-to-the-FEM-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-the-FEM" title="Permalink"></a></h1><p>by Francesc Verdugo (VU Amsterdam)</p><p>In this lecture, we will learn:</p><ul><li>The gist of the finite element method (FEM).</li><li>How to solve a simple partial differential equation (PDE) with it.</li><li>How to express the key concepts in code using GalerkinToolkit.</li></ul><p>This lecture is useful even if you are a FEM expert if you want to learn GalerkinToolkit. It will walk you through the key parts of the library.</p><p>This lecture is made available under a <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 license</a>. The API documentation and source code of GalerkinToolkit is available under an <a href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/main/LICENSE">MIT license</a>.</p><h2 id="Problem-statement"><a class="docs-heading-anchor" href="#Problem-statement">Problem statement</a><a id="Problem-statement-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-statement" title="Permalink"></a></h2><p>We show how to solve a simple PDE with the FEM. To make this introduction really an introduction we consider the &quot;hello, world&quot; PDE: the Poisson equation.  Our goal is to solve it when adding Dirichlet boundary conditions. These are the inputs of the problem. A domain <span>$\Omega\subset\mathbb{R}^d$</span> with <span>$d$</span> being the number of spatial dimensions (<span>$d=2$</span> in this example), and two functions <span>$f$</span>, <span>$g$</span> such that <span>$f,g:\Omega\rightarrow\mathbb{R}$</span>. The problem is formalized as finding the function <span>$u:\Omega\rightarrow\mathbb{R}$</span> such that</p><p class="math-container">\[\left\lbrace
\begin{aligned}
-\Delta u = f  \ &amp;\text{in} \ \Omega,\\
u = g \ &amp;\text{on}\ \partial\Omega,\\
\end{aligned}
\right.\]</p><p>where <span>$\Delta u = \sum_{i=1}^d \partial^2 u / \partial x_i^2$</span> is the Laplace operator and <span>$\partial\Omega$</span> is the boundary of <span>$\Omega$</span>. We define <span>$\Omega$</span> as a disk of radius one. This is a simple geometry, but yet more complex than a simple two-dimensional box. We this, we illustrate that FEM can be used to solve PDEs on complex geometries beyond simple &quot;boxes&quot;.</p><h2 id="The-method-of-manufactured-solutions"><a class="docs-heading-anchor" href="#The-method-of-manufactured-solutions">The method of manufactured solutions</a><a id="The-method-of-manufactured-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#The-method-of-manufactured-solutions" title="Permalink"></a></h2><p>We are going to select <span>$f$</span> and <span>$g$</span> in such a way <span>$u$</span> is a known function. This will allow us to compare the numerical approximation computed with FEM against the theoretical exact solution <span>$u$</span>. This technique is known as the &quot;method of manufactured solutions&quot;. Note that <span>$u$</span> is not known in practical applications.</p><p>Let us, &quot;manufacture&quot; <span>$f$</span> and <span>$g$</span> such that function <span>$u(x)=(\sum_{i=1}^d x_i)^p$</span> is the solution of the PDE above. The scalar <span>$p$</span> is a given integer <span>$p&gt;0$</span>. It will be useful to see how the numerical solution will behave for different values of <span>$p$</span>.</p><p>To manufacture function <span>$f$</span> and <span>$g$</span>, we applying the PDE operators to the expression for <span>$u$</span>. Function <span>$f$</span> is to be computed as <span>$f= -\Delta ((\sum_{i=1}^d x_i)^p)$</span> and <span>$g$</span> is simply <span>$g(x)=(\sum_{i=1}^d x_i)^p$</span>. Applying the Laplace operator to <span>$(\sum_{i=1}^d x_i)^p$</span>, we get the closed-form expression for <span>$f$</span>, namely <span>$f(x)= -d*p(p-1)(\sum_{i=1}^d x_i)^{(p-2)}$</span>.</p><h2 id="Numerical-approximation"><a class="docs-heading-anchor" href="#Numerical-approximation">Numerical approximation</a><a id="Numerical-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-approximation" title="Permalink"></a></h2><p>The FEM transforms a PDE into a system of linear algebraic equations of the form <span>$Ax=b$</span>, where <span>$A$</span> is a matrix and <span>$b$</span> is a vector. This reduces the problem of finding function <span>$u$</span> to finding vector <span>$x$</span>, which can be done on a computer using arrays and other numeric data structures. The FEM does not look for the exact function <span>$u$</span>, but for approximations of it that can be written as a linear combination of a finite number of basis functions,</p><p class="math-container">\[u^\mathrm{fem}(x)=\sum_{j=1}^N \alpha_j s_j(x),\]</p><p>where <span>$\alpha_i$</span> are the coefficients of the linear combination and <span>$s_i$</span> are functions such that <span>$s_i:\Omega\rightarrow\mathbb{R}$</span>. The integer <span>$N$</span> is the number of terms in the linear combination. The basis functions <span>$s_i$</span> are also called &quot;shape functions&quot; or &quot;hat functions&quot;. The goal of FEM is to find suitable values for <span>$\alpha_i$</span> and <span>$s_i(x)$</span> such that <span>$u^\mathrm{fem}$</span> is a good approximation of the exact solution <span>$u$</span>: <span>$u^\mathrm{fem}(x)\approx u(x)$</span> for points <span>$x\in\Omega$</span>. The more computational effort we put in building function <span>$u^\mathrm{fem}$</span> the better will be the approximation.</p><h2 id="Workflow"><a class="docs-heading-anchor" href="#Workflow">Workflow</a><a id="Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Workflow" title="Permalink"></a></h2><p>Function <span>$u^\mathrm{fem}$</span> is built as follows. First, we define the auxiliary functions <span>$s_i(x)$</span>. This step is referred to as the &quot;numerical discretization&quot; and entails defining a computational mesh and a finite element (FE) function space. The next step is building a system of linear algebraic equations <span>$Ax=b$</span>. This step is called the &quot;FEM assembly&quot; step. Then, one solves for the vector <span>$x$</span> in what is called the &quot;solver&quot; or &quot;solution&quot; step. At this points, the coefficients <span>$\alpha_i$</span> can be computed using both vector <span>$x$</span> and the Dirichlet boundary conditions of the PDE. The final step is typically some post-process of function <span>$u^\mathrm{fem}$</span>. For instance, visualize it, store it in a file, compute some quantity of interest, etc. In summary, these are the key phases in a FEM computation:</p><ul><li>Discretization</li><li>Assembly</li><li>Solution</li><li>Post-process</li></ul><h2 id="Mesh-generation"><a class="docs-heading-anchor" href="#Mesh-generation">Mesh generation</a><a id="Mesh-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-generation" title="Permalink"></a></h2><p>The FEM starts by building a &quot;triangulation&quot; <span>$\mathcal{T}$</span> of the domain <span>$\Omega$</span> in which the PDE is defined. A triangulation <span>$\mathcal{T}$</span> is a set of simpler domains <span>$T_k\subset\mathbb{R}^d$</span>, whose union is an approximation of <span>$\Omega$</span>,  <span>$\cup_{k=1}^M T_k\approx\Omega$</span>. Each domain <span>$T_k$</span> is called an &quot;element&quot;, a &quot;cell&quot; or a &quot;face&quot;, and they are typically simple geometries such as triangles, tetrahedra, hexahedra, etc. The integer <span>$M$</span> denotes the number of elements. The triangulation is also called a computational &quot;mesh&quot; or a computational &quot;grid&quot;.</p><p>Let&#39;s build a mesh for our domain <span>$\Omega$</span> using code. First, let us load all packages that we will use in this lecture:</p><pre><code class="language-julia hljs">using LinearAlgebra
using Random
import GalerkinToolkit as GT
import PartitionedSolvers as PS
import ForwardDiff
import GLMakie as Makie</code></pre><p>A common practice in GalerkinToolkit is to load packages in the Julia standard library with <code>using</code>. Other packages are loaded with <code>import</code>. This makes clear from which package each function comes from, while assuming that developers already know functions in the standard library.</p><p>The following cell builds a triangulation (a mesh object) using the external mesh generation tool GMSH. The variable <code>mesh_size</code> controls how small are the cells in the mesh. We start with a coarse mesh to make visualization easier. We are not going to comment in detail all code lines. We will discuss only the parts relevant in this high-level introduction. You can refer to the API documentation and other tutorials when needed.</p><pre><code class="language-julia hljs">mesh_size = 0.3
R = 1 #Radius
mesh = GT.with_gmsh() do gmsh
    dim = 2
    gmsh.option.set_number(&quot;General.Verbosity&quot;, 2)
    circle_tag = gmsh.model.occ.add_circle(0,0,0,R)
    circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])
    circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])
    gmsh.model.occ.synchronize()
    gmsh.model.model.add_physical_group(dim,[circle_surf_tag],-1,&quot;Omega&quot;)
    gmsh.option.set_number(&quot;Mesh.MeshSizeMax&quot;,mesh_size)
    gmsh.model.mesh.generate(dim)
    GT.mesh_from_gmsh(gmsh)
end</code></pre><p>The mesh we just created can be visualized both with Paraview and Makie. We use Makie in this lecture.</p><pre><code class="language-julia hljs">aspect = Makie.DataAspect()
shading = Makie.NoShading
kwargs = (;axis=(;aspect),shading)
GT.makie_surfaces(mesh;color=:pink,kwargs...)
GT.makie_edges!(mesh;color=:black)</code></pre><p><img src="../fig_tutorial_intro_mesh.png" alt/></p><h2 id="Computational-domains"><a class="docs-heading-anchor" href="#Computational-domains">Computational domains</a><a id="Computational-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-domains" title="Permalink"></a></h2><p>Note that two domains appear in the definition of the PDE above, the domain <span>$\Omega$</span> and its boundary <span>$\partial\Omega$</span>. We need to build data objects representing them to solve the PDE with GalerkinToolkit. They are built from the <code>mesh</code> objects as follows:</p><pre><code class="language-julia hljs">Ω = GT.interior(mesh)</code></pre><p>and</p><pre><code class="language-julia hljs">∂Ω = GT.boundary(mesh)</code></pre><p>We can also visualize them using Makie.</p><pre><code class="language-julia hljs">GT.makie_surfaces(Ω;color=:pink,kwargs...)
GT.makie_edges!(∂Ω;color=:blue,linewidth=3)</code></pre><p><img src="../fig_tutorial_intro_domains.png" alt/></p><p>Note that <code>Ω</code> is indeed an approximation of the unit disk (visualized as a pink surface), and <code>∂Ω</code> is its boundary (visualized with thick blue lines).</p><h2 id="FE-space"><a class="docs-heading-anchor" href="#FE-space">FE space</a><a id="FE-space-1"></a><a class="docs-heading-anchor-permalink" href="#FE-space" title="Permalink"></a></h2><p>Let us now build the data structure representing the finite element function <span>$u^\mathrm{fem}$</span>. We need two ingredients, the functions <span>$s_i$</span> and the coefficients <span>$α_i$</span>. Functions <span>$s_i$</span> are linearly independent and can be understood as the basis of a vector space <span>$V=\mathrm{span}\{s_1,\ldots,s_N\}$</span>. This space is called the FE space. There are many ways of defining FE spaces. Here, we will use the simplest one, which is based on Lagrange polynomials. To build it with GalerkinToolkit, we need the computational domain on which the functions of the space are defined and their polynomial degree, since these function are polynomials inside the cells of the mesh.</p><pre><code class="language-julia hljs">degree = 2
V = GT.lagrange_space(Ω,degree)</code></pre><p>We will discus the mathematical derivation of this FE space in another lecture. For now, it is enough to understand that the object <code>V</code> has information about the basis functions <span>$s_i$</span>. For instance, you can get the number of basis functions with</p><pre><code class="language-julia hljs">N = GT.num_dofs(V)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">258</code></pre><p>The word &quot;dofs&quot; stands for degrees of freedom (DOFs). Each coefficent <span>$\alpha_i$</span> can be understood as a degree of freedom, i.e., a quantity that can be tweaked to modify function <span>$u^\mathrm{fem}$</span>.</p><p>The coefficients <span>$\alpha_i$</span> are unknown at this point. We will compute them later. For the moment, we can build a mock <span>$u^\mathrm{fem}$</span> using some random coefficients <span>$\alpha_i$</span> just to see the connection between the coefficients  <span>$\alpha_i$</span> and the resulting function <span>$u^\mathrm{fem}$</span>. We create them as a random vector of length <span>$N$</span>.</p><pre><code class="language-julia hljs">Random.seed!(1)
α = rand(N)</code></pre><p>We create the function from these coefficients and the FE space as follows:</p><pre><code class="language-julia hljs">u_fem = GT.discrete_field(V,α)</code></pre><p>As suggested by the function name, the numerical approximation is called &quot;discrete field&quot; in GalerkinToolkit. The field is &quot;discrete&quot; since it is expressed in terms of a finite number of degrees of freedom.</p><p>Let&#39;s us visualize it. We do this by plotting domain <span>$\Omega$</span>, using the function value as the color code.</p><pre><code class="language-julia hljs">fig = Makie.Figure()
_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u_fem,refinement=5,kwargs...)
GT.makie_edges!(fig[1,1],Ω,color=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_rand_field.png" alt/></p><p>By looking into the figure it is clear that function <span>$u^\mathrm{fem}(x)$</span> is indeed a function that can be evaluated at any point inside the domain <span>$\Omega$</span>, i.e., a field.</p><h2 id="Dual-operators"><a class="docs-heading-anchor" href="#Dual-operators">Dual operators</a><a id="Dual-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Dual-operators" title="Permalink"></a></h2><p>The FEM also consider a basis for <span>$V^\prime$</span>, the dual space of <span>$V$</span>. Basis functions in the dual space are linear operators <span>$\sigma_i:V\rightarrow\mathbb{R}$</span> that map functions in the original (primal) space <span>$V$</span> into real values. The particular definition of these operators is not important in this lecture. See them as black boxes, that fulfill  these properties: The operators <span>$\sigma_i$</span> are linear, there is one operator <span>$\sigma_i$</span> for each shape function <span>$s_i$</span>, and they  are related with this formula <span>$\sigma(s_j)=\delta_{ij}$</span>, where <span>$\delta_{ij}$</span> is Kroneker&#39;s delta. Operator <span>$\sigma_i$</span> maps the shape function <span>$s_i$</span> to one, <span>$\sigma_i(s_i)=1$</span>, and maps the other shape functions to zero, <span>$\sigma_i(s_j)=0$</span> for <span>$i\neq j$</span>. This property allows us to compute <span>$\alpha_i$</span> as the application of operator <span>$\sigma_i$</span> to the numerical approximation <span>$u^\mathrm{fem}$</span>, namely <span>$\alpha_i=\sigma_i(u^\mathrm{fem})$</span>. You can understand <span>$\sigma_i(u^\mathrm{fem})$</span> as &quot;extract&quot; coefficient <span>$\alpha_i$</span> from <span>$u^\mathrm{fem}$</span>. You can easily prove this by taking <span>$\sigma_i(u^\mathrm{fem}) = \sigma_i(\sum_{j=1}^N \alpha_j s_j)$</span> and considering that <span>$\sigma_i$</span> is linear and <span>$\sigma_i(s_j)=\delta_{ji}$</span>.</p><h2 id="FE-interpolation"><a class="docs-heading-anchor" href="#FE-interpolation">FE interpolation</a><a id="FE-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#FE-interpolation" title="Permalink"></a></h2><p>Using the dual operators, we can define an interpolation operator that builds a function in the FE space <span>$V$</span> from a given function <span>$f:\Omega\rightarrow\mathbb{R}$</span> :</p><p class="math-container">\[(\Pi^\mathrm{fem} f)(x) = \sum_{j=1}^N \sigma_j(f) s_j(x)\]</p><p>Let us do this interpolation using code for a particular function. First, we need to define the function we want to interpolate</p><pre><code class="language-julia hljs">f = GT.analytical_field(Ω) do x
    sin(4*pi*x[1])*cos(4*pi*x[2])
end</code></pre><p>We have build an &quot;analytical field&quot;, which is a field defined by an analytical function. Let us visualize it.</p><pre><code class="language-julia hljs">fig = Makie.Figure()
_,scene = GT.makie_surfaces(fig[1,1],Ω;color=f,refinement=5,kwargs...)
GT.makie_edges!(fig[1,1],Ω,color=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_f.png" alt/></p><p>We interpolate the field using code</p><pre><code class="language-julia hljs">f_fem = GT.interpolate(f,V)</code></pre><p>and we visualize the result</p><pre><code class="language-julia hljs">fig = Makie.Figure()
_,scene = GT.makie_surfaces(fig[1,1],Ω;color=f_fem,refinement=5,kwargs...)
GT.makie_edges!(fig[1,1],Ω,color=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_f_fem.png" alt/></p><p>Note that the interpolated field is an approximation of the original one. The &quot;noisier&quot; the original field, the worse will be the interpolation. Also the larger the number of DOFs in the space <span>$V$</span> the better will be the interpolation.</p><h2 id="Free-and-Dirichlet-DOFs"><a class="docs-heading-anchor" href="#Free-and-Dirichlet-DOFs">Free and Dirichlet DOFs</a><a id="Free-and-Dirichlet-DOFs-1"></a><a class="docs-heading-anchor-permalink" href="#Free-and-Dirichlet-DOFs" title="Permalink"></a></h2><p>Remember that our goal is to find the coefficients <span>$α_i$</span>. Most of them are unknown, but not all. Note that the PDE states that <span>$u=g$</span> on the boundary <span>$\partial\Omega$</span>. With this information we can compute some of the coefficients <span>$\alpha_i$</span> directly, without solving a linear system. To find out which coefficients are really unknown and which can be computed from the boundary condition, we classify the shape functions <span>$s_i$</span> into two groups: the <span>$s_i$</span> that are zero at any point of the boundary, <span>$s_i(x) = 0$</span> for all <span>$x\in\partial\Omega$</span>, in one group, and the rest in the second group. We denote <span>$s^\mathrm{f}_i$</span> the shape function number <span>$i$</span> in the first group, and <span>$s^\mathrm{d}_i$</span> function number <span>$i$</span> in the second group. Letters &quot;f&quot; and &quot;d&quot; stand for &quot;free&quot; and &quot;Dirichlet&quot; as they will be associated with unknown (free) coefficients and coefficients computed from the Dirichlet condition respectively. Using this classification  of the shape functions, we can also classify the coefficients <span>$\alpha_i$</span>, and the dual operators <span>$\sigma_i$</span>. Consider <span>$\star\in(\mathrm{f},\mathrm{d})$</span>. The coefficient <span>$\alpha^\star_i$</span> is the one that multiplies <span>$s^\star_i$</span> and <span>$\sigma^\star_i$</span> is its associated dual operator. We can also define the space <span>$V^\star=\mathrm{span}\{s^\star_1,\ldots,s^\star_{N^\star}\}$</span> as the subspace of <span>$V$</span> generated by the shape functions <span>$s^\star_i$</span>. Finally,  we call <span>$N^\star$</span> the number of shape functions <span>$s^\star_i$</span> for <span>$\star\in(\mathrm{f},\mathrm{d})$</span>,  i.e, the number of free and Dirichlet DOFs.</p><p>The shape functions are classified in the code by creating a FE space that is aware of the Dirichlet boundary:</p><pre><code class="language-julia hljs">V = GT.lagrange_space(Ω,degree;dirichlet_boundary=∂Ω)</code></pre><p>Now the DOFs in this space are split on two groups: free and Dirichlet. We can get the number of free DOFs</p><pre><code class="language-julia hljs">N_f = GT.num_free_dofs(V)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">212</code></pre><p>and the number of Dirichlet DOFs.</p><pre><code class="language-julia hljs">N_d = GT.num_dirichlet_dofs(V)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">46</code></pre><h2 id="Dirichlet-Field"><a class="docs-heading-anchor" href="#Dirichlet-Field">Dirichlet Field</a><a id="Dirichlet-Field-1"></a><a class="docs-heading-anchor-permalink" href="#Dirichlet-Field" title="Permalink"></a></h2><p>Using the classification of nodes, we can decompose function <span>$u^\mathrm{fem}(x)$</span> as the sum of two functions,</p><p class="math-container">\[u^\mathrm{fem}(x)=u^\mathrm{f}(x)+u^\mathrm{d}(x)\]</p><p>with</p><p class="math-container">\[u^\star(x)=\sum_{j=1}^{N^\star} \alpha^\star_j s^\star_j(x) \text{ for } \star\in(\mathrm{f},\mathrm{d})\]</p><p>Note that <span>$u^\mathrm{f}\in V^\mathrm{f}$</span> is a linear combination of the &quot;free&quot; shape functions, and <span>$u^\mathrm{d}\in V^\mathrm{d}$</span> is a linear combination of the &quot;Dirichlet&quot; shape functions.  This decomposition is useful because <span>$u^\mathrm{d}$</span> can be directly computed from the Dirichlet Boundary condition. We refer to <span>$u^\mathrm{d}$</span> as the &quot;Dirichlet field&quot;. It is computed by building the coefficients <span>$\alpha^\mathrm{d}_i=\sigma^\mathrm{d}_i(g)$</span> as the application of the linear operators for the Dirichlet DOFs on function <span>$g$</span>. In other words, <span>$u^\mathrm{d}$</span> is built as the interpolation of the Dirichlet function <span>$g$</span> onto the space <span>$V^\mathrm{d}$</span>, <span>$u^\mathrm{d}=\Pi^\mathrm{d} g$</span>. The interpolation to the spaces <span>$V^\mathrm{f}$</span> and <span>$V^\mathrm{d}$</span> of a given funciton <span>$f$</span> is defined as we did for <span>$V$</span>, but only taking the corresponding shape functions:</p><p class="math-container">\[(\Pi^\star f)(x) = \sum_{j=1}^{N^\star} \sigma^\star_j(f) s^\star_j(x) \text{ for } \star\in(\mathrm{f},\mathrm{d}).\]</p><p>Let us build the Dirichlet field with code. First, we need to build an analytical field representing the Dirichlet function. We take <span>$p=3$</span> for example.</p><pre><code class="language-julia hljs">g = GT.analytical_field(Ω) do x
    sum(x)^3
end</code></pre><p>Then, we interpolate this field, but only on the Dirichlet DOFs, yielding the Dirichlet field</p><pre><code class="language-julia hljs">u_d = GT.interpolate_dirichlet(g,V)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GalerkinToolkit.DiscreteField(…)</code></pre><p>Note that it is a function that (by definition) is possibly non-zero near the Dirichlet boundary.</p><pre><code class="language-julia hljs">fig = Makie.Figure()
_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u_d,refinement=5,kwargs...)
GT.makie_edges!(fig[1,1],Ω,color=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_diri.png" alt/></p><p>Using the Dirichlet field, we can create function <span>$u^\mathrm{fem}$</span> only from coefficients that are associated with free DOFs. These are going to be computed later by solving a system of linear equations, but we can create a mock version of them with randomly generated values. We generate a vector of length <span>$N^\mathrm{f}$</span> because it should contain only &quot;free&quot; coefficients.</p><pre><code class="language-julia hljs">Random.seed!(2)
α_f = rand(N_f)
u_fem = GT.solution_field(u_d,α_f)</code></pre><p>In the following figure, one can see that <span>$u^\mathrm{fem}$</span> generated in this way has random values in the interior of <span>$\Omega$</span>, while matching the Dirichlet boundary condition on <span>$\partial\Omega$</span>.</p><pre><code class="language-julia hljs">fig = Makie.Figure()
_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u_fem,refinement=5,kwargs...)
GT.makie_edges!(fig[1,1],Ω,color=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_fem_2.png" alt/></p><h2 id="The-weighted-residual-method"><a class="docs-heading-anchor" href="#The-weighted-residual-method">The weighted residual method</a><a id="The-weighted-residual-method-1"></a><a class="docs-heading-anchor-permalink" href="#The-weighted-residual-method" title="Permalink"></a></h2><p>To solve the problem now, we need to find the coefficients <span>$\alpha^\mathrm{f}_i$</span> associated with the free DOFs. The number of such coefficients is <span>$N^\mathrm{f}$</span>. Hence, we have <span>$N^\mathrm{f}$</span> unknowns, which suggests that we needs to consider <span>$N^\mathrm{f}$</span> equations. These equations will follow from the PDE above.</p><p>Let us introduce the residual of the PDE, namely <span>$r(v) = \Delta v + f$</span> for a given function <span>$v$</span>. The operator <span>$r$</span> is such that <span>$r(u)=0$</span> for the exact solution of the PDE. The residual provides an estimation of how good a function approximates the solution of the PDE. If <span>$r(v)$</span> is &quot;small&quot;, then <span>$v$</span> is a good approximation of <span>$u$</span> as long as <span>$v$</span> also fulfills the Dirichlet boundary condition <span>$v=g$</span> on <span>$\partial\Omega$</span>. Our goal is to find the coefficients <span>$\alpha^\mathrm{f}_i$</span> for which the resulting function <span>$u^\mathrm{fem}$</span> has a &quot;small&quot; residual <span>$r(u^\mathrm{fem})$</span>. This approach however requires some caution. First, we need to define what &quot;small&quot; is. The second problem is that we cannot evaluate <span>$r(u^\mathrm{fem})$</span> as this value it is not well defined for all points <span>$x\in\Omega$</span>. Function <span>$u^\mathrm{fem}$</span> is continuous, but its gradient is not continuous at the boundaries of the mesh cells. As a consequence the Laplace operator and the residual <span>$r$</span> it is not well defined on the cell boundaries.</p><p>Let us visualize one of the components of the gradient of <span>$u^\mathrm{fem}$</span> to confirm that it is discontinuous. First, let us define the nabla operator.</p><pre><code class="language-julia hljs">∇ = ForwardDiff.gradient</code></pre><p>Then, we visualize the first component of the gradient as follows:</p><pre><code class="language-julia hljs">fig = Makie.Figure()
grad1 = x-&gt;∇(u_fem,x)[1]
_,scene = GT.makie_surfaces(fig[1,1],Ω;color=grad1,refinement=5,kwargs...)
GT.makie_edges!(fig[1,1],Ω,color=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_grad.png" alt/></p><p>It is indeed discontinuous at the mesh cell boundaries.</p><p>The FEM solves this problem by considering to so-called &quot;weighted residual method&quot;. First, the method provides a formal definition for what a &quot;small&quot; residual is. The method looks for a function <span>$u^\mathrm{fem}$</span> such that</p><p class="math-container">\[\int_\Omega r(u^\mathrm{fem}) s^\mathrm{f}_i \ d\Omega = 0 \text{ for } i=1,\ldots,N^\mathrm{f}.\]</p><p>That is, we want the integral of the residual times a free shape function <span>$s^\mathrm{f}_i$</span> to be zero. Each free shape function provides an equation. Thus, the number of total equations that we build with this expression is <span>$N^\mathrm{f}$</span>, which coincides with the number of unknowns. Perfect!</p><p>Now, we need to address the second problem: we need to avoid computing <span>$\Delta u^\mathrm{fem}$</span> as this quantity is not well defined for function <span>$u^\mathrm{fem}$</span> on cell boundaries. Let us expand the integral above, by in-lining the definition of <span>$r$</span>:</p><p class="math-container">\[\int_\Omega ( (\Delta u^\mathrm{fem}) s^\mathrm{f}_i + f s^\mathrm{f}_i )\ d\Omega = 0\]</p><p>We can get rid of the Laplace operator by using this identity</p><p class="math-container">\[\nabla\cdot(\nabla u^\mathrm{fem} s^\mathrm{f}_i) = (\Delta u^\mathrm{fem}) s^\mathrm{f}_i + \nabla u^\mathrm{fem} \cdot \nabla s^\mathrm{f}_i,\]</p><p>or equivalently</p><p class="math-container">\[ (\Delta u^\mathrm{fem}) s^\mathrm{f}_i = \nabla\cdot(\nabla u^\mathrm{fem} s^\mathrm{f}_i) - \nabla u^\mathrm{fem} \cdot \nabla s^\mathrm{f}_i.\]</p><p>This identity is analogous to the well known rule for the derivative of a product, but when the functions are multivariate functions. The quantity <span>$\nabla v$</span> is the gradient of the scalar function <span>$v$</span>, which is a vector defined as <span>$[\nabla v]_k = \partial v/\partial x_k$</span>. The value <span>$\nabla\cdot w$</span> is the divergence of a vector function <span>$w$</span>, which is defined as <span>$\nabla\cdot w = \sum_k^d \partial w_k/\partial x_k$</span>.</p><p>Substituting for <span>$(\Delta u^\mathrm{fem}) s^\mathrm{f}_i$</span> in the integral above, we get:</p><p class="math-container">\[\int_\Omega (\nabla\cdot(\nabla u^\mathrm{fem} s^\mathrm{f}_i) - \nabla u^\mathrm{fem} \cdot \nabla s^\mathrm{f}_i + f s^\mathrm{f}_i)\ d\Omega = 0.\]</p><p>We still have a second order derivative in the first term inside the integral. We can take rid of this one using the Gauss divergence theorem:</p><p class="math-container">\[\int_\Omega \nabla\cdot(\nabla u^\mathrm{fem} s^\mathrm{f}_i) \ d\Omega = \int_{\partial\Omega} n\cdot(\nabla u^\mathrm{fem} s^\mathrm{f}_i)\ d\partial\Omega,\]</p><p>where <span>$n$</span> is the unit normal vector on the boundary <span>$\partial\Omega$</span> pointing outwards to <span>$\Omega$</span>. Note that the right hand side is an integral on the boundary and we classified the shape functions so that all <span>$s^\mathrm{f}_i$</span> are zero at the boundary. Using <span>$s^\mathrm{f}_i(x)=0$</span> for any <span>$x\in\partial\Omega$</span>, we get:</p><p class="math-container">\[\int_{\partial\Omega} n\cdot(\nabla u^\mathrm{fem} s^\mathrm{f}_i)\ d\partial\Omega = 0.\]</p><p>Using this result and rearranging terms, we get this new formulation of our equations:</p><p class="math-container">\[ \int_\Omega \nabla u^\mathrm{fem} \cdot \nabla s^\mathrm{f}_i \ d\Omega = \int_\Omega f s^\mathrm{f}_i \ d\Omega \text{ for } i=1,\ldots,N^\mathrm{f}.\]</p><p>Note that this new formulation does not require computing second order derivatives. Thus, it is well suited for the numerical approximation <span>$u^\mathrm{fem}$</span>. This equation is called the &quot;weak form&quot; of the PDE, since it puts weaker regularity requirements to the numerical approximation <span>$u^\mathrm{fem}$</span>. In contrast, the original PDE formulation is called the &quot;strong form&quot;. There are different types of weak forms. Each one is designed for a type of numerical approximation and PDE. This one is for the Poisson equation and continuous approximations with discontinuous gradients. Other weak forms exist for this PDE. For instance, &quot;discontinuous Galerkin&quot; methods build the numerical approximation such as it is discontinuous across cell boundaries. One needs to to consider other another weak form for this case, since we cannot even compute the gradient on cell boundaries.</p><h2 id="System-of-linear-algebraic-equations"><a class="docs-heading-anchor" href="#System-of-linear-algebraic-equations">System of linear algebraic equations</a><a id="System-of-linear-algebraic-equations-1"></a><a class="docs-heading-anchor-permalink" href="#System-of-linear-algebraic-equations" title="Permalink"></a></h2><p>Let us rewrite the weak equation as <span>$a(u^\mathrm{fem},s^\mathrm{f}_i) = \ell(s^\mathrm{f}_i)$</span> with</p><p class="math-container">\[a(u^\mathrm{fem},s^\mathrm{f}_i) =  \int_\Omega \nabla u^\mathrm{fem} \cdot \nabla s^\mathrm{f}_i \ d\Omega\]</p><p>and</p><p class="math-container">\[\ell(s^\mathrm{f}_i)= \int_\Omega f s^\mathrm{f}_i \ d\Omega.\]</p><p>If we substitute</p><p class="math-container">\[u^\mathrm{fem} = \sum_{j=1}^{N^\mathrm{f}}\alpha^\mathrm{f}_j s^\mathrm{f}_j +\sum_{j=1}^{N^\mathrm{d}}\alpha^\mathrm{d}_j s^\mathrm{d}_j,\]</p><p>we get</p><p class="math-container">\[\sum_{j=1}^{N^\mathrm{f}}a(s^\mathrm{f}_j,s^\mathrm{f}_i)\alpha^\mathrm{f}_j = \ell(s^\mathrm{f}_i) - \sum_{i=1}^{N^\mathrm{d}}a(s^\mathrm{d}_j,s^\mathrm{f}_i)\alpha^\mathrm{d}_j \text{ for } i=1,\ldots,N^\mathrm{f}.\]</p><p>We have used the face that <span>$a$</span> is linear in each one of its arguments to move it inside the sums. If we look closer, this can be written in matrix form as</p><p class="math-container">\[A^\mathrm{f}\alpha^\mathrm{f} = b - A^\mathrm{d}\alpha^\mathrm{d}\]</p><p>where <span>$\alpha^\mathrm{f}$</span> and <span>$\alpha^\mathrm{d}$</span> are two vectors containing the coefficients <span>$\alpha^\mathrm{f}_i$</span> and <span>$\alpha^\mathrm{d}_i$</span> respectively. Values <span>$A^\mathrm{f}$</span> and <span>$A^\mathrm{d}$</span> are matrices, and <span>$b$</span> is a vector. They are defined as</p><p class="math-container">\[[A^\mathrm{f}]_{ij} = a(s^\mathrm{f}_j,s^\mathrm{f}_i),\]</p><p class="math-container">\[[A^\mathrm{d}]_{ij} = a(s^\mathrm{d}_j,s^\mathrm{f}_i),\]</p><p>and</p><p class="math-container">\[[b]_{i} = \ell(s^\mathrm{f}_i).\]</p><p>Solving for <span>$\alpha^\mathrm{f}$</span>, we find the unknown coefficients in <span>$u^\mathrm{fem}$</span>.</p><p>In code, we can build these two matrices and vector using a high-level API. First, we define a measure object that allows us to do the integrals over <span>$\Omega$</span>. This object uses a numerical quadrature internally. So, we need to specify the polynomial degree that we want to integrate exactly. Two times the degree of the interpolation space is a good rule of thumb.</p><pre><code class="language-julia hljs">integration_degree = 2*degree
dΩ = GT.measure(Ω,integration_degree)</code></pre><p>Then, we need to define the field representing function <span>$f$</span></p><pre><code class="language-julia hljs">f = GT.analytical_field(Ω) do x
    p=3
    -2*p*(p-1)*sum(x)^(p-2)
end</code></pre><p>and functions representing <span>$a$</span> and <span>$\ell$</span>.</p><pre><code class="language-julia hljs">a = (u,v) -&gt; GT.∫(x-&gt;∇(u,x)⋅∇(v,x), dΩ)
ℓ = v -&gt; GT.∫(x-&gt;f(x)*v(x), dΩ)</code></pre><p>Now, we can create the matrix and the vector for free DOFs</p><pre><code class="language-julia hljs">K_f = GT.assemble_matrix(a,Float64,V,V)
b = GT.assemble_vector(ℓ,Float64,V)</code></pre><p>We can also assembly the matrix for the Dirichlet DOFs using an optional argument. Here, we are asking for &quot;free&quot; rows and &quot;Dirichlet&quot; columns.</p><pre><code class="language-julia hljs">free_or_dirichlet = (GT.FREE,GT.DIRICHLET)
K_d = GT.assemble_matrix(a,Float64,V,V;free_or_dirichlet)</code></pre><p>Note that to build the final right-hand-side of the system, we compute <span>$b-K^\mathrm{d}\alpha^\mathrm{d}$</span> and we need the Dirichlet coefficients <span>$\alpha^\mathrm{d}$</span>. They can be taken from the Dirichlet field that we created before.</p><pre><code class="language-julia hljs">α_d = GT.dirichlet_values(u_d)</code></pre><p>Now, we have all ingredients to build and solve the algebraic system:</p><pre><code class="language-julia hljs">α_f = K_f\(b-K_d*α_d)</code></pre><p>We can finally create the function <span>$u^\mathrm{fem}$</span> from the computed coefficients.</p><pre><code class="language-julia hljs">u_fem = GT.solution_field(u_d,α_f)</code></pre><p>There is a more compact (and efficient) way of building and solving the system. This one generates matrices <span>$K^\mathrm{f}$</span> and <span>$K^\mathrm{d}$</span> in a single loop internally. We create a linear problem object, we solve it, and we extract the solution field from it. This approach automatically handles the Dirichlet boundary conditions.</p><pre><code class="language-julia hljs">p = GT.PartitionedSolvers_linear_problem(u_d,a,ℓ)
s = PS.solve(p)
u_fem = GT.solution_field(u_d,s)</code></pre><p>Finally, we visualize the computed FEM solution.</p><pre><code class="language-julia hljs">fig = Makie.Figure()
_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u_fem,refinement=5,kwargs...)
GT.makie_edges!(fig[1,1],Ω,color=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_fem_3.png" alt/></p><p>Let us also define the manufactured solution <span>$u$</span></p><pre><code class="language-julia hljs">u = GT.analytical_field(Ω) do x
    sum(x)^3
end</code></pre><p>and visualize it</p><pre><code class="language-julia hljs">fig = Makie.Figure()
_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u,refinement=5,kwargs...)
GT.makie_edges!(fig[1,1],Ω,color=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_sol.png" alt/></p><p>They look very similar. It seems that we solved the PDE correctly (but we still need to conform it mathematically).</p><h2 id="FE-error"><a class="docs-heading-anchor" href="#FE-error">FE error</a><a id="FE-error-1"></a><a class="docs-heading-anchor-permalink" href="#FE-error" title="Permalink"></a></h2><p>Lets us introduce the error field, i.e., the difference between the exact and numerical solution, <span>$e^\mathrm{fem}(x) = u(x)- u^\mathrm{fem}(x)$</span>.</p><pre><code class="language-julia hljs">e_fem = x -&gt; u(x) - u_fem(x)</code></pre><p>Visualize it.</p><pre><code class="language-julia hljs">fig = Makie.Figure()
_,scene = GT.makie_surfaces(fig[1,1],Ω;color=e_fem,refinement=5,kwargs...)
GT.makie_edges!(fig[1,1],Ω,color=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_error.png" alt/></p><p>Note that the error is not zero! Functions <span>$u$</span> and <span>$u^\mathrm{fem}$</span> are not the same, the last one is just an approximation. The result looks promising, but how do we know for sure that this is the expected approximation? This is what we will learn in the next lecture!</p><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>We learned the key ingredients to solve a PDE with the FEM. This requires to define a discrete space, and look for a solution in this space that makes the residual of the PDE &quot;small&quot;. To properly define what a &quot;small&quot; residual is, we used the weighted residual method. This also allowed us to rewrite the PDE into a new form called the weak form. This weak form is needed, because only the residual of the weak form makes sense for functions in the discrete space. We also learned that part of the coefficients of the numerical approximation are unknown. A subset of them can be computed directly by interpolating the Dirichlet boundary condition. We used the method of manufactured solutions to build a PDE with known solution so that we can compare it with the computed approximation.  We also learned how to represent all these concepts using GalerkinToolkit. In the next lecture, we will learn how to confirm that our computed approximation is mathematically correct.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/">« Tutorials</a><a class="docs-footer-nextpage" href="../../reference/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 17 July 2025 14:49">Thursday 17 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
