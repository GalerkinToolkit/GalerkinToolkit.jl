<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to FEM · GalerkinToolkit.jl</title><meta name="title" content="Introduction to FEM · GalerkinToolkit.jl"/><meta property="og:title" content="Introduction to FEM · GalerkinToolkit.jl"/><meta property="twitter:title" content="Introduction to FEM · GalerkinToolkit.jl"/><meta name="description" content="Documentation for GalerkinToolkit.jl."/><meta property="og:description" content="Documentation for GalerkinToolkit.jl."/><meta property="twitter:description" content="Documentation for GalerkinToolkit.jl."/><meta property="og:url" content="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/tutorial_intro_to_fem/"/><meta property="twitter:url" content="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/tutorial_intro_to_fem/"/><link rel="canonical" href="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/tutorial_intro_to_fem/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GalerkinToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GalerkinToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/">Tutorials</a></li><li class="is-active"><a class="tocitem" href>Introduction to FEM</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement"><span>Problem statement</span></a></li><li><a class="tocitem" href="#The-method-of-manufactured-solutions"><span>The method of manufactured solutions</span></a></li><li><a class="tocitem" href="#Numerical-approximation"><span>Numerical approximation</span></a></li><li><a class="tocitem" href="#Workflow"><span>Workflow</span></a></li><li><a class="tocitem" href="#Mesh-generation"><span>Mesh generation</span></a></li><li><a class="tocitem" href="#Computational-domains"><span>Computational domains</span></a></li><li><a class="tocitem" href="#FE-space"><span>FE space</span></a></li><li><a class="tocitem" href="#Free-and-Dirichlet-nodes"><span>Free and Dirichlet nodes</span></a></li><li><a class="tocitem" href="#Dirichlet-Field"><span>Dirichlet Field</span></a></li><li><a class="tocitem" href="#Weak-form"><span>Weak form</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../example_hello_world/">Hello, World!</a></li><li><a class="tocitem" href="../example_hello_world_manual/">Hello, World! (manual assembly)</a></li><li><a class="tocitem" href="../example_poisson_equation/">Poisson equation</a></li><li><a class="tocitem" href="../example_p_laplacian/">p-Laplacian</a></li><li><a class="tocitem" href="../example_p_laplacian_manual/">p-Laplacian (manual assembly)</a></li><li><a class="tocitem" href="../example_stokes/">Stokes lid-driven cavity</a></li><li><a class="tocitem" href="../example_transient_heat_eq_manual/">Transient heat equation (manual assembly)</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/">Manual</a></li><li><a class="tocitem" href="../../manual/getting_started/">Getting started</a></li><li><a class="tocitem" href="../../manual/for_developers/">For developers</a></li></ul></li><li><a class="tocitem" href="../../reference/">API</a></li><li><a class="tocitem" href="../../refindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Introduction to FEM</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction to FEM</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/main/docs/src/src_jl/tutorial_intro_to_fem.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction-to-FEM"><a class="docs-heading-anchor" href="#Introduction-to-FEM">Introduction to FEM</a><a id="Introduction-to-FEM-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-FEM" title="Permalink"></a></h1><p>by Francesc Verdugo (VU Amsterdam)</p><p>In this tutorial, we will learn:</p><ul><li>The gist of the finite element method (FEM).</li><li>How to solve a simple partial differential equation (PDE) with it.</li><li>How to express the key concept in code using GalerkinToolkit.</li><li>How to validate the code using the method manufactured solutions.</li></ul><p>This tutorial is useful even if you are a FEM expert if you want to learn GalerkinToolkit. It will walk you through the key parts of the library.</p><p>This tutorial is made available under a <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 license</a>. The API documentation and source code of GalerkinToolkit is available under an <a href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/main/LICENSE">MIT license</a>.</p><h2 id="Problem-statement"><a class="docs-heading-anchor" href="#Problem-statement">Problem statement</a><a id="Problem-statement-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-statement" title="Permalink"></a></h2><p>In this tutorial, we show how to solve a simple PDE with the FEM. To make this introduction really an introduction we consider what is considered the &quot;hello, world&quot; PDE: the Poisson equation.  Our goal is to solve the Poisson equation with Dirichlet boundary conditions on a given domain <span>$\Omega\subset\mathbb{R}^d$</span> with <span>$d$</span> being the number of spatial dimensions (<span>$d=2$</span> in this example). This problem is formalized as finding the function <span>$u:\Omega\rightarrow\mathbb{R}$</span> such that</p><p class="math-container">\[\left\lbrace
\begin{aligned}
-\Delta u = f  \ &amp;\text{in} \ \Omega,\\
u = g \ &amp;\text{on}\ \partial\Omega,\\
\end{aligned}
\right.\]</p><p>where <span>$\Delta u = \sum_{i=1}^d \partial^2 u / \partial x_i^2$</span> is the Laplace operator and <span>$f$</span>, <span>$g$</span> are two given functions <span>$f,g:\Omega\rightarrow\mathbb{R}$</span>. The boundary condition <span>$g$</span> applies on the boundary of <span>$\Omega$</span>, which is denoted as <span>$\partial\Omega$</span>. For simplicity, we will define <span>$\Omega$</span> as a disk of radius one. This is a simple geometry, but yet more complex than a two-dimensional box. We this, we illustrate that FEM can be used to solve PDEs on complex geometries beyond simple &quot;boxes&quot;.</p><h2 id="The-method-of-manufactured-solutions"><a class="docs-heading-anchor" href="#The-method-of-manufactured-solutions">The method of manufactured solutions</a><a id="The-method-of-manufactured-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#The-method-of-manufactured-solutions" title="Permalink"></a></h2><p>We are going to select <span>$f$</span> and <span>$g$</span> in such a way <span>$u$</span> is a known function. This will allow us to compare the numerical approximation computed with FEM against the theoretical exact solution <span>$u$</span>. This technique is known as the &quot;method of manufactured solutions&quot;. Let us, &quot;manufacture&quot; <span>$f$</span> and <span>$g$</span> such that function <span>$u(x)=(\sum_{i=1}^d x_i)^p$</span> is the solution of the PDE above. The scalar <span>$p$</span> is a given integer <span>$p&gt;0$</span>. It will be useful to see how the numerical solution will behave for different values of <span>$p$</span>.</p><p>To manufacture function <span>$f$</span> and <span>$g$</span> we applying the PDE operators to the given function <span>$u$</span>. That is, <span>$f$</span> needs to be computed as <span>$f= -\Delta ((\sum_{i=1}^d x_i)^p)$</span> and <span>$g$</span> is simply <span>$g(x)=(\sum_{i=1}^d x_i)^p$</span>. Applying the Laplace operator to <span>$(\sum_{i=1}^d x_i)^p$</span>, we get the closed-form expression for <span>$f$</span>, namely <span>$f(x)= -p(p-1)(\sum_{i=1}^d x_i)^{(p-2)}$</span>.</p><h2 id="Numerical-approximation"><a class="docs-heading-anchor" href="#Numerical-approximation">Numerical approximation</a><a id="Numerical-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-approximation" title="Permalink"></a></h2><p>The FEM transforms a PDE into a system of linear algebraic equations of the form <span>$Ax=b$</span>, where <span>$A$</span> is a matrix and <span>$b$</span> is a vector. This reduces the problem of finding function <span>$u$</span> to finding vector <span>$x$</span>, which can be done on a computer using arrays and other numeric data structures. To do this, FEM does not look for the exact function <span>$u$</span>, but for approximations of it that can be written as a linear combination of a finite number of basis functions, namely</p><p class="math-container">\[u^\mathrm{fem}(x)=\sum_{j=1}^N \alpha_j s_j(x),\]</p><p>where <span>$\alpha_i$</span> are the coefficients of the linear combination, <span>$s_i$</span> are functions such that <span>$s_i:\Omega\rightarrow\mathbb{R}$</span> and <span>$N$</span> is an integer. The basis functions <span>$s_i$</span> are also called &quot;shape functions&quot; or &quot;hat functions&quot;. The goal of FEM is to find suitable values for <span>$\alpha_i$</span> and <span>$s_i(x)$</span> such that <span>$u^\mathrm{fem}$</span> is a good approximation of the exact solution <span>$u$</span>, namely <span>$u^\mathrm{fem}(x)\approx u(x)$</span> for points <span>$x\in\Omega$</span>. Spoiler alert: the more computational effort we put in building function <span>$u^\mathrm{fem}$</span> the better will be the approximation.</p><h2 id="Workflow"><a class="docs-heading-anchor" href="#Workflow">Workflow</a><a id="Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Workflow" title="Permalink"></a></h2><p>Function <span>$u^\mathrm{fem}$</span> is built as follows. First, we define the auxiliary functions <span>$s_i(x)$</span>. This step is often referred as the &quot;numerical discretization&quot; and entails defining a computational mesh and a finite element (FE) function space. The next step is building a system of linear algebraic equations <span>$Ax=b$</span>. This step is called the &quot;FEM assembly&quot;. Then, one solves for the vector <span>$x$</span> in what is called the &quot;solver&quot; or &quot;solution&quot; step. At this points, the coefficients <span>$\alpha_i$</span> can be computed using both vector <span>$x$</span> and the Dirichlet boundary conditions of the PDE. The final step is typically some post-process of function <span>$u^\mathrm{fem}$</span>. For instance, visualize it, store it into a file, compute some quantity of interest, etc. In summary, these are the key phases in a FEM computation:</p><ul><li>Discretization</li><li>Assembly</li><li>Solution</li><li>Post-process</li></ul><h2 id="Mesh-generation"><a class="docs-heading-anchor" href="#Mesh-generation">Mesh generation</a><a id="Mesh-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-generation" title="Permalink"></a></h2><p>The FEM starts by building a &quot;triangulation&quot; <span>$\mathcal{T}$</span> of the domain <span>$\Omega$</span> in which the PDE is defined. A triangulation <span>$\mathcal{T}$</span> is a set of simpler domains <span>$T_k\subset\mathbb{R}^d$</span>, whose union is an approximation of <span>$\Omega$</span>, namely <span>$\cup_{k=1}^M T_k\approx\Omega$</span>. Each domain <span>$T_k$</span> is often called an &quot;element&quot;, a &quot;cell&quot; or a &quot;face&quot;, and they are typically simple geometries such as triangles, tetrahedra, hexahedra, etc. The integer <span>$M$</span> denotes the number of elements here. The triangulation is also often called a computational mesh or a computational grid.</p><p>Let&#39;s build a mesh for our domain <span>$\Omega$</span> using code. First, let us load all packages that we will use in this tutorial:</p><pre><code class="language-julia hljs">using LinearAlgebra
using Random
import GalerkinToolkit as GT
import ForwardDiff
import GLMakie as Makie</code></pre><p>A common practice in GalerkinToolkit is to load packages in the Julia standard library with <code>using</code>. Other packages are loaded with <code>import</code>. This makes clear from which package each function comes from, while assuming that developers already know functions in the standard library.</p><p>The following cell builds a triangulation (a mesh object) using the external mesh generation tool GMSH. The variable <code>mesh_size</code> controls how fine are the cells in the mesh (smaller is finer). We start with a coarse mesh to make visualization easier. In this tutorial, we are not going to comment in detail all code lines. We will discuss only the parts relevant in this high-level introduction. You can refer to the API documentation other tutorials when needed.</p><pre><code class="language-julia hljs">mesh_size = 0.3
R = 1 #Radius
mesh = GT.with_gmsh() do gmsh
    dim = 2
    circle_tag = gmsh.model.occ.add_circle(0,0,0,R)
    circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])
    circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])
    gmsh.model.occ.synchronize()
    gmsh.model.model.add_physical_group(dim,[circle_surf_tag],-1,&quot;Omega&quot;)
    gmsh.option.setNumber(&quot;Mesh.MeshSizeMax&quot;,mesh_size)
    gmsh.model.mesh.generate(dim)
    GT.mesh_from_gmsh(gmsh)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Info    : Meshing 1D...
Info    : Meshing curve 1 (Circle)
Info    : Done meshing 1D (Wall 0.000114364s, CPU 0.000116s)
Info    : Meshing 2D...
Info    : Meshing surface 1 (Plane, Frontal-Delaunay)
Info    : Done meshing 2D (Wall 0.00525214s, CPU 0.00525s)
Info    : 71 nodes 141 elements</code></pre><p>There are ways of accessing the low level information in this mesh object, but we are not going to discuss them in this tutorial. Here, we only need to know how to visualize the mesh, and other high-level operations. The mesh can be visualized both using Paraview and Makie. We use Makie in this tutorial.</p><pre><code class="language-julia hljs">axis = (aspect = Makie.DataAspect(),)
Makie.plot(mesh;color=:pink,strokecolor=:blue,axis)</code></pre><p><img src="../fig_tutorial_intro_mesh.png" alt/></p><h2 id="Computational-domains"><a class="docs-heading-anchor" href="#Computational-domains">Computational domains</a><a id="Computational-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-domains" title="Permalink"></a></h2><p>Note that two domains appear in the definition of the PDE above, the domain <span>$\Omega$</span> and its boundary <span>$\partial\Omega$</span>. We need to build data objects representing these domains in order to solve the PDE with GalerkinToolkit. They are built from the <code>mesh</code> objects as follows:</p><pre><code class="language-julia hljs">Ω = GT.interior(mesh)</code></pre><p>and</p><pre><code class="language-julia hljs">∂Ω = GT.boundary(mesh)</code></pre><p>We can also visualize them using Makie.</p><pre><code class="language-julia hljs">Makie.plot(Ω;color=:pink,axis)
Makie.plot!(∂Ω;color=:blue,linewidth=3)</code></pre><p><img src="../fig_tutorial_intro_domains.png" alt/></p><p>Note that <code>Ω</code> is indeed an approximation of the unit disk (visualized as a pink surface), and <code>∂Ω</code> is its boundary (visualized as blue lines).</p><h2 id="FE-space"><a class="docs-heading-anchor" href="#FE-space">FE space</a><a id="FE-space-1"></a><a class="docs-heading-anchor-permalink" href="#FE-space" title="Permalink"></a></h2><p>Let us build the data structure representing the finite element function <span>$u^\mathrm{fem}$</span>. We need two ingredients, the functions <span>$s_i$</span> and the coefficients <span>$α_i$</span>. Functions <span>$s_i$</span> are linearly independent and can be understood as the basis of a vector space <span>$V=\mathrm{span}\{s_1,\ldots,s_N\}$</span>. This space is called the FE space. There are many ways of defining FE spaces. Here, we will use the simplest one, which is based on Lagrange polynomials. To build it with GalerkinToolkit, we need the discretized computational domain on which the functions of the space are defined and their polynomial degree of the Lagrange basis functions.</p><pre><code class="language-julia hljs">degree = 3
V = GT.lagrange_space(Ω,degree)</code></pre><p>We will discus the mathematical derivation of this FE space in another tutorial. For now, it is enough to understand that the object <code>V</code> has information about the basis functions <span>$s_i$</span>. For instance, you can get the number of basis functions with</p><pre><code class="language-julia hljs">N = GT.num_dofs(V)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">562</code></pre><p>The word &quot;dofs&quot; stands for degrees of freedom (DOFs). Each coefficent <span>$\alpha_i$</span> can be understood as a degree of freedom, i.e., a quantity that can be tweaked to modify function <span>$u^\mathrm{fem}$</span>.</p><p>The coefficients <span>$\alpha_i$</span> are unknown at this point. We will compute them later. For the moment, we can build a mock <span>$u^\mathrm{fem}$</span> using some random coefficients <span>$\alpha_i$</span> just to see the connection between the coefficients  <span>$\alpha_i$</span> and the resulting function <span>$u^\mathrm{fem}$</span>. We create them as a random vector of length <span>$N$</span>.</p><pre><code class="language-julia hljs">Random.seed!(1)
α = rand(N)</code></pre><p>Now we can create the function from these coefficients and the FE space as follows:</p><pre><code class="language-julia hljs">u_fem = GT.solution_field(V,α)</code></pre><p>Let&#39;s us visualize it. We do this by plotting domain <span>$\Omega$</span> but not colored using the function value.</p><pre><code class="language-julia hljs">#Create figure
fig = Makie.Figure()
#Plot u_fem on a finer mesh
_,scene = Makie.plot(fig[1,1],Ω;axis,color=u_fem,refinement=5)
#Plot edges of the original mesh
Makie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)
#Plot colorbar
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_rand_field.png" alt/></p><p>By looking into the figure it is clear that function <span>$u^\mathrm{fem}(x)$</span> is ineed a function that can be evaluated at any point inside the domain <span>$\Omega$</span>.</p><p>To have a better intuition of the meaning of the basis functions <span>$s_i$</span>, let us visualize one of them. If we want to visualize <span>$s_{400}$</span>, we just need to create coefficients such that <span>$\alpha_{400}=1$</span> and <span>$\alpha_i=0$</span> for <span>$i\neq 400$</span>.</p><pre><code class="language-julia hljs">α2 = zeros(N)
α2[400] = 1
s_400 = GT.solution_field(V,α2)</code></pre><p>Now, we can visualize this function as we did before for <span>$u^\mathrm{fem}$</span>.</p><pre><code class="language-julia hljs">fig = Makie.Figure()
_,scene = Makie.plot(fig[1,1],Ω;axis,color=s_400,refinement=5)
Makie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_shape.png" alt/></p><p>Note that the function is equal to one at a single point and zero almost everywhere. The point <span>$x_i$</span> in which the function <span>$s_i(x_i)=1$</span> is called the &quot;node&quot; associated with this function. Each function <span>$s_i$</span> has a node associated with it. We can get the coordinates of all this nodes as follows:</p><pre><code class="language-julia hljs">x = GT.node_coordinates(V)</code></pre><p>This is a vector containing the coordinates for all nodes. The coordinates for the node associated with function <span>$s_{400}$</span> can be accessed as</p><pre><code class="language-julia hljs">x_400 = x[400]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):
  0.7508242088504761
 -0.38897683066051164</code></pre><p>We can also visualize all node coordinates.</p><pre><code class="language-julia hljs">Makie.plot(Ω;color=:pink,strokecolor=:black,axis)
Makie.scatter!(x;color=:blue)</code></pre><p><img src="../fig_tutorial_intro_nodes.png" alt/></p><p>We have as many basis functions as nodes in this figure. The shape functions <span>$s_i$</span> have also a very important property. Function <span>$s_i$</span> is equal to one at its node <span>$x_i$</span>, but it is zero at all other nodes, namely <span>$s_i(x_j)=\delta_{ij}$</span>, where <span>$\delta_{ij}$</span> is Kronecker&#39;s delta. This property allows us to interpret the coefficients <span>$\alpha_i$</span> as the &quot;nodal values&quot; of function <span>$u^\mathrm{fem}$</span>. That is, <span>$\alpha_i$</span> is the value of <span>$u^\mathrm{fem}$</span> at node <span>$x_i$</span>, <span>$\alpha_i=u^\mathrm{fem}(x_i)$</span>. You can easily prove this by taking <span>$u^\mathrm{fem}(x_i) = \sum_{j=1}^N \alpha_j s_j(x_i)$</span> and considering that <span>$s_j(x_i)=\delta_{ji}$</span>.</p><p>In summary, the coefficients <span>$α_i$</span> are the values of <span>$u^\mathrm{fem}$</span> at the nodes as show in this figure:</p><pre><code class="language-julia hljs">Makie.plot(Ω;color=:pink,strokecolor=:black,axis)
Makie.scatter!(x;color=α,colormap=:bluesreds)</code></pre><p><img src="../fig_tutorial_intro_nodes_color.png" alt/></p><p>Whereas, function <span>$u^\mathrm{fem}$</span> can be understood as the (Lagrange) interpolation of these nodal values into any other point of the domain <span>$Ω$</span> as shown in this figure:</p><pre><code class="language-julia hljs">_,schene = Makie.plot(Ω;axis,color=u_fem,refinement=5)
Makie.plot!(Ω;color=nothing,strokecolor=:black)
colorrange = scene[:colorrange]
Makie.scatter!(x;color=α,colormap=:bluesreds,colorrange)</code></pre><p><img src="../fig_tutorial_intro_nodes_color2.png" alt/></p><p>NB. In this scalar-valued FE space, there is a one-to-one relation between the coefficients (DOFs) <span>$\alpha_i$</span> and the nodes <span>$x_i$</span>. This is not true for other types of spaces. In vector-valued Lagrange spaces, there are several DOFs in one node.  In other FE spaces the concept of &quot;nodes&quot; does not make sense at all.</p><h2 id="Free-and-Dirichlet-nodes"><a class="docs-heading-anchor" href="#Free-and-Dirichlet-nodes">Free and Dirichlet nodes</a><a id="Free-and-Dirichlet-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Free-and-Dirichlet-nodes" title="Permalink"></a></h2><p>Remember that our goal is to find the coefficients <span>$α_i$</span>. Most of these coefficients are unknown, but not all of them. Note that the PDE states that <span>$u=g$</span> on the boundary <span>$\partial\Omega$</span>. With this information we can easily compute the coefficients <span>$\alpha_i$</span> for nodes <span>$x_i$</span> on the Dirichlet boundary <span>$\partial\Omega$</span> simply as <span>$\alpha_i=g(x_i)$</span>. We need to classify the nodes into two groups: the ones on the Dirichlet boundary <span>$\partial\Omega$</span> in one group and the remaining nodes in another group. Let us call <span>$\mathcal{I}^\mathrm{d}$</span> (&quot;d&quot; for Dirichlet) the set of all integers <span>$i$</span> for which the node <span>$x_i$</span> is on <span>$\partial\Omega$</span>. Let us call <span>$\mathcal{I}^\mathrm{f}$</span> (&quot;f&quot; for free) the other of all integers <span>$i$</span> for which the node <span>$x_i$</span> is not on <span>$\partial\Omega$</span>.  The coefficient <span>$\alpha_i$</span> is computed as <span>$\alpha_i=g(x_i)$</span> for <span>$i\in\mathcal{I}^\mathrm{d}$</span> and the remaining coefficients will be computed solving a system of linear equations. The union of <span>$\mathcal{I}^\mathrm{d}$</span> and <span>$\mathcal{I}^\mathrm{f}$</span> cover all nodes of the FE space. We call <span>$N^\mathrm{f}$</span> and <span>$N^\mathrm{d}$</span> the number of items in <span>$\mathcal{I}^\mathrm{f}$</span> and <span>$\mathcal{I}^\mathrm{d}$</span> respectively, i.e, the number of free and Dirichlet nodes.</p><p>The nodes are classified in the code as follows. We create a FE space that is aware of the Dirichlet boundary:</p><pre><code class="language-julia hljs">V = GT.lagrange_space(Ω,degree;dirichlet_boundary=∂Ω)</code></pre><p>Now the nodes/DOFs in this space are split on two groups: free and Dirichlet. We can get the number of free nodes/DOFs</p><pre><code class="language-julia hljs">N_f = GT.num_free_dofs(V)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">493</code></pre><p>and the number of Dirichlet nodes/DOFs.</p><pre><code class="language-julia hljs">N_d = GT.num_dirichlet_dofs(V)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">69</code></pre><h2 id="Dirichlet-Field"><a class="docs-heading-anchor" href="#Dirichlet-Field">Dirichlet Field</a><a id="Dirichlet-Field-1"></a><a class="docs-heading-anchor-permalink" href="#Dirichlet-Field" title="Permalink"></a></h2><p>Using the classification of nodes, we can decompose function <span>$u^\mathrm{fem}$</span> as the sum of two functions, <span>$u^\mathrm{fem}(x)=u^\mathrm{f}(x)+u^\mathrm{d}(x)$</span></p><p class="math-container">\[u^\mathrm{f}(x)=\sum_{j\in\mathcal{I}^\mathrm{f}} \alpha_j s_j(x)
\text{ and }
u^\mathrm{d}(x)=\sum_{j\in\mathcal{I}^\mathrm{d}} \alpha_j s_j(x).\]</p><p>which corresponds to restrict the linear combination to free or Dirichlet DOFs respectively. This decomposition is useful because <span>$u^\mathrm{d}$</span> can be directly computed from the Dirichlet Boundary condition. We refer to <span>$u^\mathrm{d}$</span> as the &quot;Dirichlet field&quot;. If can be computed in the code as follows. First, we create the Dirichlet field object.</p><pre><code class="language-julia hljs">u_d = GT.dirichlet_field(Float64,V)</code></pre><p>We can get a vector for all DOFs <span>$\alpha_i$</span> on the Dirichlet boundary as follows</p><pre><code class="language-julia hljs">α_d = GT.dirichlet_values(u_d)</code></pre><p>By default, all these values are set to zero. But we can compute their final values by using function <span>$g$</span> and the nodal coordinates of the Dirichlet nodes. These coordinates can be computed by restricting the vector of coordinates of all nodes, to only the Dirichlet nodes:</p><pre><code class="language-julia hljs">node_to_x = GT.node_coordinates(V)
dirichlet_dof_to_node = GT.dirichlet_dof_node(V)
dirichlet_dof_to_x = node_to_x[dirichlet_dof_to_node]</code></pre><p>Now we can fill the values using the definition of function <span>$g$</span>.</p><pre><code class="language-julia hljs">broadcast!(α_d,dirichlet_dof_to_x) do x
    p = 1
    sum(x)^p
end</code></pre><p>Now we can visualize the Dirichlet field and confirm that it is indeed a function that is non-zero at the nodes on the Dirichlet boundary, and zero at the other nodes:</p><pre><code class="language-julia hljs">fig = Makie.Figure()
_,scene = Makie.plot(fig[1,1],Ω;axis,color=u_d,refinement=5)
Makie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_diri.png" alt/></p><p>There is a more compact and more general way of generating the Dirichlet:</p><pre><code class="language-julia hljs">u_d = GT.dirichlet_field(Float64,V)
g = GT.analytical_field(Ω) do x
    p = 1
    sum(x)^p
end
GT.interpolate_dirichlet!(g,u_d)</code></pre><p>This will work also for FE spaces that are not associated with &quot;nodes&quot;. In this case, the Dirichlet values will be filled in using a base of the dual space of <span>$V$</span>.</p><p>Using the Dirichlet field, we can create function <span>$u^\mathrm{fem}$</span> only from coefficients that are associated with free nodes. These are going to be computed later by solving a system of linear equations, but we can create a mock version from randomly generated coefficients. In this case, we generate a vector of length <span>$N^\mathrm{f}$</span> instead of <span>$N$</span> because it should contain only &quot;free&quot; values.</p><pre><code class="language-julia hljs">Random.seed!(2)
α_f = rand(N_f)
u_fem = GT.solution_field(u_d,α_f)</code></pre><p>In the following figure, one can see that <span>$u^\mathrm{fem}$</span> generated in this way has random values in the interior of <span>$\Omega$</span>, while matching the Dirichlet boundary condition on <span>$\partial\Omega$</span>.</p><pre><code class="language-julia hljs">fig = Makie.Figure()
_,scene = Makie.plot(fig[1,1],Ω;axis,color=u_fem,refinement=5)
Makie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_fem_2.png" alt/></p><h2 id="Weak-form"><a class="docs-heading-anchor" href="#Weak-form">Weak form</a><a id="Weak-form-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-form" title="Permalink"></a></h2><p>To solve the problem we need to find as many as <span>$N^\mathrm{f}$</span> coefficients. In other words, we have <span>$N^\mathrm{f}$</span> unknowns, which suggests that we needs to consider <span>$N^\mathrm{f}$</span> equations. These equations will follow from the PDE above. One can try to substitute the expression of <span>$u^\mathrm{fem}$</span> and try to find which coefficients <span>$\alpha_i$</span> that minimize the residual of the equation in some norm. However, we cannot use the PDE directly in this form. The equation is in face not well defined for function <span>$u^\mathrm{fem}$</span>. This function is continuous, but its gradient it is not continuous at the boundaries of the mesh cells. As a consequence the Laplace operator it is not well defined as one cannot compute derivatives of a discontinuous function.</p><p>Let us visualize one of the component of gradient of <span>$u^\mathrm{fem}$</span> to confirm that is discontinuous. First, let us define the nabla operator</p><pre><code class="language-julia hljs">∇ = ForwardDiff.gradient</code></pre><p>Now we can visualize the first component of the gradient as follows:</p><pre><code class="language-julia hljs">fig = Makie.Figure()
_,scene = Makie.plot(fig[1,1],Ω;axis,color=x-&gt;∇(u_fem,x)[1],refinement=5)
Makie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)
Makie.Colorbar(fig[1,2],scene)</code></pre><p><img src="../fig_tutorial_intro_grad.png" alt/></p><p>It is indeed discontinuous at the mesh cell boundaries.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/">« Tutorials</a><a class="docs-footer-nextpage" href="../../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Monday 10 March 2025 16:02">Monday 10 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
