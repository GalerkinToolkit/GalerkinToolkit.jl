<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mesh topology · GalerkinToolkit.jl</title><meta name="title" content="Mesh topology · GalerkinToolkit.jl"/><meta property="og:title" content="Mesh topology · GalerkinToolkit.jl"/><meta property="twitter:title" content="Mesh topology · GalerkinToolkit.jl"/><meta name="description" content="Documentation for GalerkinToolkit.jl."/><meta property="og:description" content="Documentation for GalerkinToolkit.jl."/><meta property="twitter:description" content="Documentation for GalerkinToolkit.jl."/><meta property="og:url" content="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/manual_mesh_topology/"/><meta property="twitter:url" content="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/manual_mesh_topology/"/><link rel="canonical" href="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/manual_mesh_topology/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GalerkinToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GalerkinToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/">Manual</a></li><li><a class="tocitem" href="../../manual/introduction/">Introduction</a></li><li><a class="tocitem" href="../manual_mesh_geometry/">Mesh geometry</a></li><li class="is-active"><a class="tocitem" href>Mesh topology</a><ul class="internal"><li><a class="tocitem" href="#Local-faces"><span>Local faces</span></a></li><li><a class="tocitem" href="#Conforming-meshes"><span>Conforming meshes</span></a></li><li><a class="tocitem" href="#Face-complexes"><span>Face complexes</span></a></li><li><a class="tocitem" href="#Gluing-faces"><span>Gluing faces</span></a></li><li><a class="tocitem" href="#Face-incidence"><span>Face incidence</span></a></li><li><a class="tocitem" href="#Node-permutations"><span>Node permutations</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../manual_mesh_generation/">Mesh generation</a></li><li><a class="tocitem" href="../manual_mesh_partitioning/">Mesh partitioning</a></li><li><a class="tocitem" href="../../manual/for_developers/">For developers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../example_hello_world/">Hello, World!</a></li><li><a class="tocitem" href="../example_hello_world_dg/">Interior penalty</a></li><li><a class="tocitem" href="../example_hello_world_lm/">Lagrange multipliers</a></li><li><a class="tocitem" href="../example_poisson_equation/">Poisson equation</a></li><li><a class="tocitem" href="../example_p_laplacian/">p-Laplacian</a></li><li><a class="tocitem" href="../example_linear_elasticity/">Linear elasticity</a></li><li><a class="tocitem" href="../example_stokes/">Stokes lid-driven cavity</a></li><li><a class="tocitem" href="../example_transient_heat_eq/">Transient heat equation</a></li><li><a class="tocitem" href="../example_laplace_beltrami/">Laplace-Beltrami</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/">Tutorials</a></li><li><a class="tocitem" href="../tutorial_intro_to_fem/">Introduction to the FEM</a></li></ul></li><li><a class="tocitem" href="../../reference/">API</a></li><li><a class="tocitem" href="../../refindex/">Index</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Mesh topology</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mesh topology</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/main/docs/src/src_jl/manual_mesh_topology.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mesh-topology"><a class="docs-heading-anchor" href="#Mesh-topology">Mesh topology</a><a id="Mesh-topology-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-topology" title="Permalink"></a></h1><p>In this page, we discuss how to &quot;glue&quot; faces in a <em>face complex</em>. A face complex is a mesh with some additional properties (see definition below) that allow us to formalize the meaning of &quot;gluing&quot; faces. This information is needed in many finite element (FE) methods, e.g., to build (high-order) conforming FE spaces, or to integrate at face interfaces.</p><h2 id="Local-faces"><a class="docs-heading-anchor" href="#Local-faces">Local faces</a><a id="Local-faces-1"></a><a class="docs-heading-anchor-permalink" href="#Local-faces" title="Permalink"></a></h2><p>In order to define what a face complex is, first, we need to introduce the concept of <em>local faces</em>. To this end, let <span>$F\in M$</span> be a physical face in mesh <span>$M$</span>, where <span>$\hat\Omega:=\hat\Omega(F)$</span> is its reference domain. Let us also consider the chain <span>$\hat C:=C(\hat \Omega)$</span> used to define the geometry of the reference domain <span>$\hat \Omega$</span> and let <span>$d$</span> be the dimension of <span>$\hat \Omega$</span>. See Section <a href="../manual_mesh_geometry/#Mesh-geometry">Mesh geometry</a> for the definition of these concepts. Let us also define the interface <span>$\Gamma(\mathcal{F})$</span> of a set of faces <span>$\mathcal{F}\subset M$</span> as the open set such that its closure is the intersection of the closures of the faces in <span>$\mathcal{F}$</span>, namely <span>$\overline{\Gamma(\mathcal{F})} = \cap_{F\in \mathcal{F}} \bar F$</span>.</p><p>With these notations, we define the set of <em>local faces</em> of the reference domain <span>$\hat \Omega$</span> as the mesh <span>$L(\hat \Omega)$</span> containing:</p><ol><li>the reference domain <span>$\hat \Omega$</span>,</li><li>the faces in the chain <span>$\hat C$</span>,</li><li>and the interfaces <span>$\Gamma(\{F_1,F_2\})$</span> of any pair of faces <span>$F_1,F_2\in\hat C$</span>.</li></ol><p>The set <span>$L(\hat \Omega)$</span> contains all faces in the boundary of the polytope <span>$\hat \Omega$</span>. E.g., for a reference edge, it contains the edge and the two end vertices. For a reference square, it contains the square, four edges, and the four vertices at the intersection of the edges. For a reference cube, it contains the cube, six surfaces, twelve edges, and eight vertices (see the next figure).</p><p>In the code, one can access the mesh of local faces from a reference domain <code>Ωref::AbstractDomain</code> with <code>Mref = mesh(Ωref)</code>. The mesh <code>Mref::AbstractMesh</code> is like any other mesh used in the code and, e.g., it can be visualized as any other mesh shown in next Figure.</p><p><img src="../fig_meshes_defs_5.png" alt/></p><p><strong>Figure</strong>: Visualization of the local faces of a reference cube, square, and segment. Faces are shrunk in the visualization to illustrate that they are open sets.</p><pre><code class="language-julia hljs">#Code used to generate the figure
import GalerkinToolkit as GT
import GLMakie as Makie
domain = (0,2,0,1,0,2)
cells = (4,2,4)
F3 = GT.unit_n_cube(Val(3))
F2 = GT.unit_n_cube(Val(2))
F1 = GT.unit_n_cube(Val(1))
M3 = GT.mesh(F3)
M2 = GT.mesh(F2)
M1 = GT.mesh(F1)
fig = Makie.Figure()
aspect = :data
ax = Makie.Axis3(fig[1,1];aspect)
Makie.hidespines!(ax)
Makie.hidedecorations!(ax)
shrink = 0.8
GT.makie_surfaces!(ax,M3;dim=2,shrink)
GT.makie_surfaces!(ax,M3;dim=3,shrink)
GT.makie_edges!(ax,M3;dim=1,shrink)
GT.makie_vertices!(ax,M3;dim=0,shrink)
aspect = Makie.DataAspect()
axis = (;aspect)
ax, = GT.makie_surfaces(fig[1,2],M2;dim=2,shrink,axis)
Makie.hidespines!(ax)
Makie.hidedecorations!(ax)
GT.makie_edges!(M2;dim=1,shrink)
GT.makie_vertices!(M2;dim=0,shrink)
ax = Makie.Axis(fig[1,3])
Makie.hidespines!(ax)
Makie.hidedecorations!(ax)
GT.makie_edges!(ax,M1;dim=1,shrink)
GT.makie_vertices!(ax,M1;dim=0,shrink)</code></pre><h2 id="Conforming-meshes"><a class="docs-heading-anchor" href="#Conforming-meshes">Conforming meshes</a><a id="Conforming-meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Conforming-meshes" title="Permalink"></a></h2><p>A mesh <span>$M$</span> is <em>conforming</em> if for any pair of faces <span>$F_1,F_2\in M$</span> with non-empty interface <span>$\Gamma_{1,2}:=\Gamma(\{F_1,F_2\})\neq\empty$</span> exists a local face <span>$f_1\in L(\hat\Omega(F_1))$</span> and a local face  <span>$f_2\in L(\hat\Omega(F_2))$</span> such that</p><ul><li>their images via the coordinate map coincide with the interface, <span>$\Gamma_{1,2}=\phi^{F_1}(f_1)=\phi^{F_2}(f_2)$</span>, and</li><li>they share global node ids, <span>$n(F_1,f_1)=Pn(F_2,f_2)$</span>.</li></ul><p>In this definition, <span>$P$</span> is a permutation matrix and <span>$n(F,f)$</span> is a vector containing the node ids of <span>$F$</span> restricted to the local face <span>$f\in L(\hat\Omega(F))$</span>, namely <span>$[n(F,f)]_r:=[n(F)]_l$</span> with <span>$l=[n(f)]_r$</span>. Both local faces have the same global ids but these ids are allowed to be order differently in each local face. This is why we include the permutation matrix <span>$P$</span>. If these local faces exist, we say that face <span>$F_1$</span> is <em>conforming</em> to face <span>$F_2$</span> at the interface <span>$\Gamma_{1,2}$</span>, <em>via</em> the local face <span>$f_1$</span> (idem for <span>$F_2$</span>). We also say that the local faces <span>$f_1$</span> and <span>$f_2$</span>, and the interface <span>$\Gamma_{1,2}$</span> are <em>equivalent</em>.</p><h2 id="Face-complexes"><a class="docs-heading-anchor" href="#Face-complexes">Face complexes</a><a id="Face-complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Face-complexes" title="Permalink"></a></h2><p>With these notations we introduce the concept of face complex as follows. A mesh <span>$M$</span> is a <em>face complex</em> (or a <a href="https://en.wikipedia.org/wiki/Polyhedral_complex">polyhedral complex</a>) if</p><ul><li>it is conforming, and</li><li>it contains the images of all local faces, namely <span>$\phi^F(f)\in M$</span> for all <span>$f\in L(\hat\Omega(F))$</span> and all <span>$F\in M$</span>.</li></ul><p>Given a mesh <span>$M$</span> that is conforming, but not a face complex, it is always possible to add additional faces to make it a face complex (see next figure). In the API, this is done with function <code>M2 = complexify(M)</code> from a mesh object <code>M::AbstractMesh</code>. The result <code>M2::AbstractMesh</code> is a face complex. With function <code>is_face_complex(M)</code> one checks if <code>M</code> is a face complex. It returns true form meshes created with function <code>complexify</code>. Note that the chain <span>$\hat C$</span> used to define the local faces <span>$L(\hat \Omega)$</span> above is conforming, the set of local faces <span>$L(\hat \Omega)$</span> is a face complex. In the code, we create the local faces using function <code>complexify</code> and the chain <span>$\hat C$</span>. Many functions in the  Mesh generation page return face complexes by default.</p><p><img src="../fig_mesh_topo_2.png" alt/></p><p><strong>Figure:</strong> Visualization of two conforming meshes. The mesh on the left, has vertices, edges, and surfaces, but it is not a face complex. The mesh on the right is the face complex obtained by calling <code>complexify</code> on the mesh of the left. I.e., we add the missing faces to make the mesh a face complex.</p><pre><code class="language-julia hljs">#Code used to generate the figure
import GalerkinToolkit as GT
import GLMakie as Makie
domain = (0,1,0,1)
cells = (4,4)
mesh = GT.cartesian_mesh(domain,cells;complexify=false)
fig = Makie.Figure()
axis = (;aspect=Makie.DataAspect())
shading = Makie.NoShading
shrink = 0.8
ax, = GT.makie_surfaces(fig[1,1],mesh;axis,shading,shrink)
GT.makie_edges!(fig[1,1],mesh;shrink,dim=1)
GT.makie_vertices!(fig[1,1],mesh,dim=0)
Makie.hidespines!(ax)
Makie.hidedecorations!(ax)
mesh2 = GT.complexify(mesh)
@assert GT.is_face_complex(mesh2)
ax, = GT.makie_surfaces(fig[1,2],mesh2;axis,shading,shrink)
GT.makie_edges!(fig[1,2],mesh2;shrink,dim=1)
GT.makie_vertices!(fig[1,2],mesh2,dim=0)
Makie.hidespines!(ax)
Makie.hidedecorations!(ax)</code></pre><h2 id="Gluing-faces"><a class="docs-heading-anchor" href="#Gluing-faces">Gluing faces</a><a id="Gluing-faces-1"></a><a class="docs-heading-anchor-permalink" href="#Gluing-faces" title="Permalink"></a></h2><p>Let us consider a face complex <span>$M$</span>, a face <span>$F\in M$</span>, and the set of faces <span>$\mathcal{A}(F)$</span> such that their interface <span>$\Gamma(\mathcal{A}(F))=F$</span>  coincides with face <span>$F$</span>. If these face exist, we call <span>$\mathcal{A}(F)$</span> the <em>faces around</em> <span>$F$</span>. We refer to <em>gluing</em> faces <span>$\mathcal{A}(F)$</span> at the their interface <span>$F$</span> as solving the following two-step problem for each face around <span>$A\in\mathcal{A}(F)$</span>:</p><ol><li>Find the local face <span>$a\in L(\hat\Omega(A))$</span> and the permutation matrix <span>$P$</span> such that <span>$n(F)=P n(A,a)$</span>.</li><li>Build a map <span>$\varphi$</span> such that <span>$\phi^A(\phi^a(\varphi(x)))=\phi^{F}(x)$</span> for all <span>$x\in \hat\Omega(F)$</span>.</li></ol><p>For this problem to have a solution, the mesh <span>$M$</span> needs to be conforming. This is what allows us to find the local face <span>$a$</span>, the permutation matrix <span>$P$</span>, and the map <span>$\varphi$</span>. In addition, mesh <span>$M$</span> needs to be a face complex so that the interface <span>$\Gamma(\mathcal{A}(F))\in M$</span> is also a face in the mesh, i.e., face <span>$F$</span>. In this case, it makes sense to talk about the node ids of the interface <span>$n(F)$</span>, its coordinate map <span>$\phi^{F}$</span>, and its reference domain <span>$\hat\Omega(F)$</span>.</p><div class="admonition is-info" id="Note-7b952f6a2c8f0837"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7b952f6a2c8f0837" title="Permalink"></a></header><div class="admonition-body"><p>TODO: The code is currently working with the inverse of the permutation matrix <span>$P$</span>, namely <span>$P n(F)= n(A,a)$</span>. In the future we will use the definition of <span>$P$</span> as in <span>$n(F)=P n(A,a)$</span>.</p></div></div><p>By solving this problem, we are building a common parametrization of the interface seen from each face around. This is the key ingredient needed to compute integrals at the interface of quantities defined on the faces around. and to build interpolations defined on the faces around that are conforming at the interface.</p><p>Once the step 1. of the problem is solved and we have the local face <span>$a$</span> and the permutation matrix <span>$P$</span>, the map <span>$\varphi$</span> solution of step 2. is readily computed as</p><p class="math-container">\[\varphi(\xi) := \sum_{n=1}^{\hat N} [P\hat x]_n [\hat s]_n(\xi),\]</p><p>where <span>$\hat x:=x(\hat V(a))$</span>, <span>$\hat s:=s(\hat V(a))$</span>, and <span>$\hat N$</span> is the length of <span>$\hat x$</span> and <span>$\hat s$</span>. Thus, the only remaining  part of the face-gluing problem is step 1. In the code, the solution of this step is encoded for all possible interfaces in the object returned by <code>T=topology(M)</code> for a mesh object <code>M::AbstractMesh</code>.  The returned object <code>T</code> is an instance of a type  that implements the <a href="../../reference/#GalerkinToolkit.AbstractTopology"><code>AbstractTopology</code></a> interface.  We detail now the main methods in this interface.</p><h2 id="Face-incidence"><a class="docs-heading-anchor" href="#Face-incidence">Face incidence</a><a id="Face-incidence-1"></a><a class="docs-heading-anchor-permalink" href="#Face-incidence" title="Permalink"></a></h2><p>We define the topology of <span>$M$</span> as the graph <span>$T$</span>, where the vertices of <span>$T$</span> are the faces in <span>$M$</span> and its edges are refined as follows: The edges <span>$(F_1,F_2)$</span> and <span>$(F_2,F_1)$</span> connecting two faces <span>$F_1,F_2\in M$</span> exists in the graph <span>$T$</span> if</p><ul><li>the two faces are the same, <span>$F_1 = F_2$</span>, or</li><li>the two faces are of different dimensions and have a non-empty interface, <span>$d(F_1)\neq d(F_2)$</span> and <span>$\Gamma(\{F_1,F_2\}) \neq \empty$</span>.</li></ul><p>If two faces are connected by an edge in the graph <span>$T$</span>, we say that the faces are <em>incident</em>, or  <em>adjacent</em>. Note that this graph is symmetric.</p><p>In the API,  The graph is encoded using <a href="https://en.wikipedia.org/wiki/Adjacency_list">adjacency lists</a>  organized according to face dimensions.  The adjacency list containing the edges starting at faces of dimension <code>m</code> and ending at a faces of dimension <code>n</code> is returned by function  <code>face_incidence(T,m,n)</code>. One recovers all edges in the graph <code>T</code> by calling this function for all possible pairs <code>(m,n)</code> with <code>m in 0:D</code> and <code>n in 0:D</code>, being <code>D=num_dims(M)</code>.  The result of <code>face_incidence(T,m,n)</code> is a long vector of small vectors of integers encoded via a <code>JaggedArray</code> object, since the inner vectors often have different lengths.</p><p>The vector <code>As=face_incidence(T,m,n)[F]</code> has the following interpretation for a face <span>$F$</span> with face id <code>F::Integer</code>. For <code>m&lt;n</code>, the ids in <code>As</code> are the ids of the faces around <span>$\mathcal{A}(F)$</span>, which are arbitrarily sorted in vector <code>As</code>. For <code>m&gt;n</code>, the vector <code>As</code> contains the ids of the <code>n</code>-faces on the boundary of <span>$F$</span>. In this case, the ids in <code>As</code> are sorted according to the id of the local faces of <span>$F$</span>, namely <code>A=As[f]</code> means that the local <code>n</code>-face  <span>$f$</span> of <span>$F$</span>  with id <code>f::Integer</code> is equivalent to the <code>n</code>-face <span>$A\in M$</span> with id <code>A</code>. For <code>m==n</code>, the vector <code>As</code> is equal to <code>[F]</code> by definition (a vector with a single integer).</p><p>From the mesh topology <span>$T$</span>, we can get, for a given face <span>$F\in M$</span>, the set of faces around <span>$\mathcal{A}(F)\subset M$</span>, and  the local face <span>$a\in L(\hat\Omega(A))$</span> that is equivalent to <span>$F$</span> for each face around <span>$A\in\mathcal{A}(F)$</span>. Consider a topology object <code>T::AbstractTopology</code> and let <span>$F$</span> be the <code>m</code>-face in mesh <span>$M$</span> with id <code>F::Integer</code>. We get the ids of the <code>n</code>-faces around <code>F</code> as <code>As=face_incidence(T,m,n)[F]</code>. For each <code>A in As</code>, we get the id <code>a</code> of the local face  of <code>A</code> equivalent to <code>F</code> as follows. We get all <code>m</code>-faces at the boundary of <code>A</code> with <code>Bs=face_incidence(T,n,m)[A]</code>, and we find in which position in <code>Bs</code> the id <code>F</code> is located, namely <code>a=findfirst(B-&gt;B==F,Bs)</code>.</p><p>It is also possible to access to the same information using face objects rather than face ids. Given a face object <code>F::AbstractMeshFace</code> one iterates over all faces around of dimension <code>m</code>, and gets the local face equivalent to <code>F</code>:</p><pre><code class="language-julia hljs">for A in each_face_around(F,n)
    # A is an AbstractMeshFace
    a = local_face(A,F)
    # a is an AbstractSpace,
    # but in the mesh of local faces of A.
end</code></pre><h2 id="Node-permutations"><a class="docs-heading-anchor" href="#Node-permutations">Node permutations</a><a id="Node-permutations-1"></a><a class="docs-heading-anchor-permalink" href="#Node-permutations" title="Permalink"></a></h2><p>To be able to glue faces <span>$\mathcal{A}(F)\subset M$</span> at the interfce <span>$F$</span>, we still need a way of obtaining the permutation matrix <span>$P$</span> such that <span>$Pn(A,a)=n(F)$</span> for each face around <span>$A\in\mathcal{A}(F)$</span> and its local face <span>$a$</span> equivalent to <span>$F$</span>. This information is encoded in the API as follows. All possible permutations for a local face <span>$a$</span> are contained in the vector <code>k_P = node_permutations(Vref)</code> where <code>Vref::AbstractSpace</code> is the object representing the reference space of <span>$a$</span>. The vector <code>k_P</code> at an index <code>k</code>, is a permutation vector<code>P</code>. The permutation vector is equivalent to a permutation matrix <span>$P$</span>. Applying the permutation matrix <span>$P$</span> to a vector <span>$v$</span>, <span>$Pv$</span> is equivalent to indexing the vector object <code>v</code> with the permutation vector <code>P</code>, namely <code>v[P]</code>.</p><p>From all possible permutations in vector <code>k_P</code>, we obtain the permutation for local face <span>$a$</span> as follows. Let <code>A::Integer</code> and <code>a::Integer</code> be the ids of a <code>n</code>-face around <span>$A\in\mathcal{A}(F)$</span> and of its local <code>m</code>-face <span>$a$</span> equivalent to <span>$F$</span>. Then, we get the permutation <code>P=k_P[k]</code> for this local face by indexing <code>k_P</code> at the index <code>k</code> obtained as follows <code>k=face_permutation_ids(T,n,m)[A][a]</code>. Note that the function <code>face_permutation_ids(T,n,m)</code> has a similar structure than function <code>face_incidence(T,n,m)</code>, both are vectors of vectors of integers, but the former contains the indices used to get the permutation vectors instead of face ids. The permutation vector <code>P</code> is more conveniently accessed given a face object <code>F::AbstractMeshFace</code> as follows:</p><pre><code class="language-julia hljs">for A in each_face_around(F,n)
    a = local_face(A,F)
    P = node_permutation(A,a)
end</code></pre><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>To wrap up, we show how to glue faces using the following example. For each face <span>$F\in M$</span> in a mesh, we show how to  find the local face <span>$a$</span> and permutation <span>$P$</span> for each face around <span>$A\in\mathcal{A}(F)$</span>. In the example, <code>n</code> is the dimension of <span>$F$</span> and <span>$a$</span> and <code>m</code> is the dimension of <span>$A$</span>. We check that <span>$n(F)=P n(A,a)$</span>.</p><p>In this first version of the example, we use face objects. The variables <code>F</code>, <code>A</code>, and <code>a</code> are  <code>AbstractMeshFace</code> objects representing faces  <span>$F$</span>, <span>$A$</span>, and <span>$a$</span> respectively.</p><pre><code class="language-julia hljs">import GalerkinToolkit as GT
domain = (0,1,0,1,0,1)
cells = (5,5,5)
M = GT.cartesian_mesh(domain,cells)
m = 2
n = 3
for F in GT.each_face(M,m)
    for A in GT.each_face_around(F,n)
        a = GT.local_face(A,F)
        P = GT.node_permutation(A,a)
        @assert GT.nodes(F) == GT.nodes(A)[ GT.nodes(a)[P]]
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.MeshTopology3</code></pre><p>This other version uses face ids instead of face objects and explicitly uses the mesh topology. Here, <code>F</code>, <code>A</code>, and <code>a</code> are the <code>Integer</code> ids of faces <span>$F$</span>, <span>$A$</span>, and <span>$a$</span> respectively.</p><pre><code class="language-julia hljs">import GalerkinToolkit as GT
import StaticArrays as SA
domain = (0,1,0,1,0,1)
cells = (5,5,5)
M = GT.cartesian_mesh(domain,cells)
T = GT.topology(M)
m = 2
n = 3
F_As = GT.face_incidence(T,m,n)
A_Bs = GT.face_incidence(T,n,m)
A_a_k = GT.face_permutation_ids(T,n,m)
A_rA = GT.face_reference_id(M,n)
rA_VA = GT.reference_spaces(M,n)
F_nodes = GT.face_nodes(M,m)
A_nodes = GT.face_nodes(M,n)
for F in 1:GT.num_faces(M,m)
    As = F_As[F]
    for A in As
        Bs = A_Bs[A]
        a = findfirst(B-&gt;B==F,Bs)
        k = A_a_k[A][a]
        rA = A_rA[A]
        VA = rA_VA[rA]
        ΩA = GT.domain(VA)
        LA = GT.mesh(ΩA)
        a_nodes = GT.face_nodes(LA,m)
        a_ra = GT.face_reference_id(LA,m)
        ra_Va = GT.reference_spaces(LA,m)
        ra = a_ra[a]
        Va = ra_Va[ra]
        Ps = GT.node_permutations(Va)
        P = Ps[k]
        @assert F_nodes[F] == A_nodes[A][a_nodes[a][P]]
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.MeshTopology4</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>We discussed the strategy to glue faces in GalerkinToolkit. It required to introduce concepts including local faces, the faces a round a face, face complex, and the mesh topology. The following table summarizes the key definitions in this page with its corresponding code API.</p><table><tr><th style="text-align: right">Concept</th><th style="text-align: right">Notation</th><th style="text-align: right">API</th></tr><tr><td style="text-align: right">Interface</td><td style="text-align: right"><span>$\Gamma(\mathcal{F})$</span></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">Mesh topology</td><td style="text-align: right"><span>$T$</span></td><td style="text-align: right"><code>T::AbstractTopology</code></td></tr><tr><td style="text-align: right">Topology from mesh</td><td style="text-align: right"></td><td style="text-align: right"><code>T = topology(M)</code></td></tr><tr><td style="text-align: right">Adjacency list</td><td style="text-align: right"></td><td style="text-align: right"><code>face_incidence(T,m,n)</code></td></tr><tr><td style="text-align: right">Create a face complex</td><td style="text-align: right"></td><td style="text-align: right"><code>complexify(M)</code></td></tr><tr><td style="text-align: right">Check if face complex</td><td style="text-align: right"></td><td style="text-align: right"><code>is_face_complex(M)</code></td></tr><tr><td style="text-align: right">Faces around</td><td style="text-align: right"><span>$A\in\mathcal{A}(F)$</span></td><td style="text-align: right"><code>A in each_face_around(F,n)</code></td></tr><tr><td style="text-align: right">Local faces</td><td style="text-align: right"><span>$L(\hat \Omega(A))$</span></td><td style="text-align: right"><code>L=mesh(Ωref)</code> with <code>Ωref=reference_domain(A)</code></td></tr><tr><td style="text-align: right">Local face of <span>$A$</span> equivalent to <span>$F$</span></td><td style="text-align: right"></td><td style="text-align: right"><code>a=local_face(A,F)</code></td></tr><tr><td style="text-align: right">Permutation matrix/vector</td><td style="text-align: right"><span>$P$</span></td><td style="text-align: right"><code>P=node_permutation(A,a)</code></td></tr></table><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual_mesh_geometry/">« Mesh geometry</a><a class="docs-footer-nextpage" href="../manual_mesh_generation/">Mesh generation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 26 November 2025 12:53">Wednesday 26 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
