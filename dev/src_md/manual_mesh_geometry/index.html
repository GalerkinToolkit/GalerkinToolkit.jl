<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mesh geometry · GalerkinToolkit.jl</title><meta name="title" content="Mesh geometry · GalerkinToolkit.jl"/><meta property="og:title" content="Mesh geometry · GalerkinToolkit.jl"/><meta property="twitter:title" content="Mesh geometry · GalerkinToolkit.jl"/><meta name="description" content="Documentation for GalerkinToolkit.jl."/><meta property="og:description" content="Documentation for GalerkinToolkit.jl."/><meta property="twitter:description" content="Documentation for GalerkinToolkit.jl."/><meta property="og:url" content="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/manual_mesh_geometry/"/><meta property="twitter:url" content="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/manual_mesh_geometry/"/><link rel="canonical" href="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/manual_mesh_geometry/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GalerkinToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GalerkinToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/">Manual</a></li><li><a class="tocitem" href="../../manual/introduction/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Mesh geometry</a><ul class="internal"><li><a class="tocitem" href="#Definition"><span>Definition</span></a></li><li><a class="tocitem" href="#Dimensions"><span>Dimensions</span></a></li><li><a class="tocitem" href="#Face-ids"><span>Face ids</span></a></li><li><a class="tocitem" href="#Node-ids"><span>Node ids</span></a></li><li><a class="tocitem" href="#Reference-ids"><span>Reference ids</span></a></li><li><a class="tocitem" href="#Reference-spaces"><span>Reference spaces</span></a></li><li><a class="tocitem" href="#Reference-domains"><span>Reference domains</span></a></li><li><a class="tocitem" href="#Physical-faces"><span>Physical faces</span></a></li><li><a class="tocitem" href="#Face-groups"><span>Face groups</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../manual_mesh_topology/">Mesh topology</a></li><li><a class="tocitem" href="../manual_mesh_generation/">Mesh generation</a></li><li><a class="tocitem" href="../manual_mesh_partitioning/">Mesh partitioning</a></li><li><a class="tocitem" href="../../manual/for_developers/">For developers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../example_hello_world/">Hello, World!</a></li><li><a class="tocitem" href="../example_hello_world_dg/">Interior penalty</a></li><li><a class="tocitem" href="../example_hello_world_lm/">Lagrange multipliers</a></li><li><a class="tocitem" href="../example_poisson_equation/">Poisson equation</a></li><li><a class="tocitem" href="../example_p_laplacian/">p-Laplacian</a></li><li><a class="tocitem" href="../example_linear_elasticity/">Linear elasticity</a></li><li><a class="tocitem" href="../example_stokes/">Stokes lid-driven cavity</a></li><li><a class="tocitem" href="../example_transient_heat_eq/">Transient heat equation</a></li><li><a class="tocitem" href="../example_laplace_beltrami/">Laplace-Beltrami</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/">Tutorials</a></li><li><a class="tocitem" href="../tutorial_intro_to_fem/">Introduction to the FEM</a></li></ul></li><li><a class="tocitem" href="../../reference/">API</a></li><li><a class="tocitem" href="../../refindex/">Index</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Mesh geometry</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mesh geometry</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/main/docs/src/src_jl/manual_mesh_geometry.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mesh-geometry"><a class="docs-heading-anchor" href="#Mesh-geometry">Mesh geometry</a><a id="Mesh-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-geometry" title="Permalink"></a></h1><p>A mesh object in GalerkinToolkit contains all geometrical information needed in a finite element (FE) computation. This includes the discretization of computational domains as well as data to impose different types of boundary conditions. Meshes are often generated with external tools and then transformed into GalerkinToolkit objects with helper functions such as <a href="../../reference/#GalerkinToolkit.mesh_from_gmsh"><code>mesh_from_gmsh</code></a>, see the Page about Mesh generation for more details. In this page, we assume that we have already created a mesh object and will discuss its geometrical representation and in particular:</p><ul><li>our math definition of a mesh,</li><li>reference domains and spaces,</li><li>physical faces and coordinate maps,</li><li>face, node, and reference ids, and</li><li>face groups.</li></ul><h2 id="Definition"><a class="docs-heading-anchor" href="#Definition">Definition</a><a id="Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Definition" title="Permalink"></a></h2><p>A <em>mesh</em> <span>$M$</span> in GalerkinToolkit is defined as set of <em>physical faces</em> embedded in the Euclidean space <span>$\mathbb{R}^D$</span>, with <span>$D$</span> often being <span>$D=1,2,3$</span>. A physical face is defined in terms of a reference domain and a reference space as detailed later below. In the API, a mesh <span>$M$</span> is represented with a mesh object <code>M</code>, whose type is a subtype of <a href="../../reference/#GalerkinToolkit.AbstractMesh"><code>AbstractMesh</code></a>. Even though our math notation defines a mesh <span>$M$</span> as a set, a mesh object <code>M::AbstractMesh</code> has not the API of a set, but an API providing the information encoding the set of faces <span>$M$</span>. There is a one-to-one relation between the mathematical mesh <span>$M$</span> and the API mesh <code>M</code> and we often refer to them simply as &quot;a mesh&quot;. The same is true for other math definitions and their corresponding API.</p><p>A face <span>$F\in M$</span> in a mesh is represented in the code with an object <code>F::AbstractMeshFace</code>. Given <code>M::AbstractMesh</code>, function <code>GT.each_face(M,d)</code> creates an iterator used to traverse all faces of dimensions <code>d</code> in mesh <code>M</code>. Using this iterator, faces can be accessed with the Julia loop syntax.</p><pre><code class="language-julia hljs">for F in GT.each_face(M,d)
    # F isa AbstractMeshFace
end</code></pre><h2 id="Dimensions"><a class="docs-heading-anchor" href="#Dimensions">Dimensions</a><a id="Dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Dimensions" title="Permalink"></a></h2><p>A face <span>$F\in M$</span> in a mesh is an <em>open</em> <span>$d$</span>-dimensional manifold embedded in the Euclidean space <span>$\mathbb{R}^D$</span>. We call <span>$D$</span> the number of <em>ambient</em> dimensions of the mesh <span>$M$</span>  and of faces <span>$F\in M$</span>, and <span>$d$</span> is the number of dimensions of face <span>$F$</span>, which might be <span>$d=0,\ldots,D$</span>. We use <span>$d(X)$</span> and <span>$D(X)$</span> to denote the number of dimensions and ambient dimensions of an object <span>$X$</span> and define the number of <em>co-dimensions</em> of <span>$X$</span> as <span>$D(X)-d(X)$</span>. Since a mesh might contain faces of different dimensions, we define the number of dimensions of a mesh <span>$M$</span> as the maximum number of dimensions of their faces, <span>$d(M):=\max_{F\in M} d(F)$</span>. In the API, the number of dimensions, ambient dimensions, and co-dimensions are obtained with <code>num_dims(X)</code>, <code>num_ambient_dims(X)</code>, and <code>num_codims(X)</code> respectively for an instance <code>X::AbstractMeshFace</code> or <code>X::AbstractMesh</code>.</p><p>This is some extra notation that we often use in the library. We call a <span>$d$</span>-face to a face of <span>$d$</span> dimensions. We call <em>vertices</em>, <em>edges</em>, <em>surfaces</em>, and <em>volumes</em> to faces of 0, 1, 2, and 3 dimensions respectively. We call <em>chain</em> to a mesh, whose faces are all of the same dimension. The next figure shows a two-dimensional mesh embedded in a three-dimensional space. This mesh contains vertices, edges, and surfaces, but not volumes. This mesh is <em>not</em> a chain, but a <em>face complex</em> (see section <a href="../manual_mesh_topology/#Mesh-topology">Mesh topology</a>).</p><p><img src="../fig_meshes_defs_1.png" alt/></p><p><strong>Figure:</strong> Visualization of the faces in the mesh of a Möbius strip. We shrink the mesh faces to illustrate that faces are open sets. Otherwise faces of hider dimensions would hide faces of lower dimensions in the figure.</p><pre><code class="language-julia hljs">#Code used to generate the figure
import GalerkinToolkit as GT
import GLMakie as Makie
cells = (4,40)
mesh = GT.moebius_strip(cells;width=0.6)
fig = Makie.Figure()
elevation = 0.24π
azimuth = -0.55π
aspect = :data
ax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)
shrink = 0.8
shading = Makie.NoShading
GT.makie_surfaces!(mesh;shrink,shading,dim=2)
GT.makie_edges!(mesh;shrink,dim=1)
GT.makie_vertices!(mesh;shrink,dim=0)</code></pre><h2 id="Face-ids"><a class="docs-heading-anchor" href="#Face-ids">Face ids</a><a id="Face-ids-1"></a><a class="docs-heading-anchor-permalink" href="#Face-ids" title="Permalink"></a></h2><p>We assign a unique integer, called the <em>face id</em> <span>$\text{id}(F)$</span>, to each face <span>$F\in M$</span> of a given dimension <span>$d$</span> . Face ids are assigned per dimension (two faces of different dimension might have the same id). Thus, a face is uniquely identified by its face id <em>and</em> its dimension <span>$d$</span>. The face ids are arbitrary as long as they are consecutive integers starting by one. In the API, <code>num_faces(M,d)</code> returns the number of <code>d</code>-faces and <code>faces(M,d)</code> is the range <code>1:num_faces(M,d)</code> containing all face ids in dimension <code>d</code>. There is a one-to-one relation between face objects and face ids. For a face object <code>F::AbstractMeshFace</code>, <code>F_id=id(F)</code> is the face id of <code>F</code> and <code>F=each_face(M,d)[F_id]</code> is the face <code>F</code> for a face id <code>F_id::Integer</code>. We often refer to face objects <code>F</code> and face ids <code>F_id</code> simply as &quot;a face&quot; since they are equivalent. In the API, the same operation can be done often in two different ways, one using face ids (integers) and another using face objects.</p><h2 id="Node-ids"><a class="docs-heading-anchor" href="#Node-ids">Node ids</a><a id="Node-ids-1"></a><a class="docs-heading-anchor-permalink" href="#Node-ids" title="Permalink"></a></h2><p>Like in many other FE codes, the node coordinates of a face <span>$F\in M$</span> are encoded using a vector of node coordinates <span>$x(M)$</span> for the mesh  <span>$M$</span> and the <em>node ids</em> <span>$n(F)$</span> of the face <span>$F$</span>. In this setup, the node coordinates of a face <span>$x(F)$</span> are computed as <span>$[x(F)]_l := [x(M)]_g\in\mathbb{R}^D$</span> with <span>$g = [n(F)]_l$</span> for <span>$l=1,\ldots,|n(F)|$</span>. The vector <span>$n(F)$</span> is often called  the <em>local-to-global</em> (index) map or the face <em>connectivity</em>. We call them the face node ids.  The value <span>$g$</span> is called the <em>global</em> node id  associated with the <em>face-local</em> (or simply local) node id <span>$l$</span> in face <span>$F$</span>.</p><p>In the API, the vector of node coordinates of a mesh is accessed with <code>node_coordinates(M)</code> for <code>M::AbstractMesh</code>. The length of this vector is <code>num_nodes(M)</code> and <code>nodes(M)</code> is the range <code>1:num_nodes(M)</code> containing all possible node ids. For a given <code>d</code>, we collect the node ids of all <code>d</code>-faces in a mesh <code>M</code> in the vector returned by <code>face_nodes(M,d)</code>. The node ids of a face with id <code>F_id::Integer</code> and dimension <code>d</code> are accessed with <code>face_nodes(M,d)[F_id]</code>.  The coordinates of the local node <code>l</code> in face <code>F_id</code> are then computed by indexing the mesh coordinates  with the global node id <code>g</code>,  <code>node_coordinates(M)[g]</code> with <code>g = face_nodes(M,d)[F_id][l]</code>.  The vector <code>face_nodes(M,d)</code> is a long vector of small vectors of integers with possibly different lengths.  It is often represented using a <code>PartitionedArrays.JaggedArray</code> object that uses continuous linear memory for performance.</p><p>It is also possible to access  node ids and node coordinates from a face object <code>F::AbstractMeshFace</code> as <code>nodes(F)</code>  and <code>node_coordinates(F)</code> respectively. Note that  <code>nodes(F)</code> and <code>face_nodes(M,num_dims(F))[id(F)]</code> are equivalent.</p><h2 id="Reference-ids"><a class="docs-heading-anchor" href="#Reference-ids">Reference ids</a><a id="Reference-ids-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-ids" title="Permalink"></a></h2><p>Each physical face <span>$F\in M$</span> in a mesh is defined by means of a reference FE space <span>$\hat V(F)$</span>. Several faces often share the same reference space and often all faces of the same dimensions share the same reference space. For each dimension <code>d</code>, we collect the unique reference spaces of faces of dimension <code>d</code> in a tuple. This tuple is returned by <code>reference_spaces(M,d)</code> for a mesh object <code>M::AbstractMesh</code>.</p><p>The reference space assigned to a face is then obtained as <code>reference_spaces(M,d)[r]</code>, where <code>r</code> is called the <em>reference</em> id of the face. The reference id is obtained from a face id <code>F_id::Integer</code>, by indexing the vector <code>face_reference_id(M,d)</code>, namely <code>r = face_reference_id(M,d)[F_id]</code>. It can also be obtained from a face object <code>F::AbstractMeshFace</code> with <code>r=reference_id(F)</code>, and the corresponding reference space with <code>reference_space(F)</code>. Note that <code>reference_id(F)</code> and <code>face_reference_id(M,num_dims(F))[id(F)]</code> are equivalent.</p><p>The notion of reference id is introduced since different face  typologies such as simplices and hyper-cubes might be in the same mesh.  If all <span>$d$</span>-faces are topologically equivalent (which is often the case),  there is only one reference  space for all <span>$d$</span>-faces and their reference id is one.</p><h2 id="Reference-spaces"><a class="docs-heading-anchor" href="#Reference-spaces">Reference spaces</a><a id="Reference-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-spaces" title="Permalink"></a></h2><p>The reference space <span>$\hat V(F)$</span> of a face <span>$F\in M$</span> is  is a scalar-valued (possibly high-order) Lagrange FE space  defined on the reference domain <span>$\hat \Omega(F)$</span>. From this space, one can obtain  a vector of (high-order) node coordinates <span>$x(\hat V(F))$</span> and a vector of  shape functions <span>$s(\hat V(F))$</span>.</p><p>In the code, the reference spaces in <code>reference_spaces(M,d)</code> are of a types that specializes the <a href="../../reference/#GalerkinToolkit.AbstractSpace"><code>AbstractSpace</code></a> interface. The <code>AbstractSpace</code> interface is detailed in section <a href="../manual_interpolation/#Interpolation">Interpolation</a>. In this page, we only need to consider the vector of node coordinates <code>node_coordinates(Vref)</code> and the vector of scalar shape functions, <code>shape_functions(Vref)</code> for an object <code>Vref::AbstractSpace</code>. Each function in <code>shape_functions(Vref)</code> is evaluated at a point <code>x::AbstractVector</code> (often <code>x::SVector</code>), and returns a scalar value <code>s::Real</code>.</p><p>One can get a reference spaces from a mesh object as shown above or created from scratch with function <a href="../../reference/#GalerkinToolkit.lagrange_space">lagrange_space</a>. E.g., <code>Vref = lagrange_space(Ωref,order)</code> creates a reference space of order <code>order</code> on the reference domain <code>Ωref</code>.</p><h2 id="Reference-domains"><a class="docs-heading-anchor" href="#Reference-domains">Reference domains</a><a id="Reference-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-domains" title="Permalink"></a></h2><p>A reference domain <span>$\hat \Omega$</span> is a <span>$d$</span>-dimensional <a href="https://en.wikipedia.org/wiki/Polytope">polytope</a> embedded in the Euclidian space <span>$\mathbb{R}^d$</span>. In particular, <span>$\hat \Omega$</span> is a segment, polygon, and a polyhedron for <span>$d=1,2,3$</span> respectively. For <span>$d=0$</span>, we define a reference domain <span>$\hat \Omega:=\{v\}$</span> as a set containing the only point  <span>$v\in\mathbb{R}^0$</span>. For <span>$d&gt;0$</span>. We define the boundary <span>$\partial\hat \Omega$</span> of a reference domain <span>$\hat \Omega$</span> as the union <span>$\partial\hat \Omega := U_{F\in C} \bar F$</span>, where <span>$C$</span> is a chain of faces of dimension <span>$d-1$</span> and <span>$\bar F$</span> is the <a href="https://en.wikipedia.org/wiki/Closure_(topology)">closure</a> of a face <span>$F$</span>. E.g., the boundary of a segment is the union of two vertices. The boundary of a square is the union of four segments, and the boundary of a cube is the union of four squares. Assuming that <span>$\partial\hat \Omega$</span> is closed, we define the reference domain <span>$\hat \Omega$</span> as the open bounded subset of <span>$\mathbb{R}^d$</span> with boundary <span>$\partial\hat \Omega$</span>. i.e., <span>$\hat \Omega$</span> is the space &quot;inside&quot; <span>$\partial\hat \Omega$</span>. In the API, reference domains are often built as <code>Ωref = unit_n_cube(Val(d))</code> or <code>Ωref = unit_simplex(Val(d))</code> that create a unit hypercube or a unit simplex of <code>d</code> dimensions respectively.</p><p>Given a physical face <span>$F\in M$</span>, we call <span>$\hat\Omega(F)$</span> the reference domain associated with it, and <span>$C(\hat \Omega)$</span> the chain used to define <span>$\hat \Omega$</span>. In the API, one can get the reference domain from a face object <code>F::AbstractMeshFace</code> as <code>Ωref=reference_domain(F)</code> or from a reference space <code>Ωref = domain(Vref)</code> with <code>Vref::AbstractSpace</code>. The reference domain is also obtained from a face with id <code>F_id::Integer</code> and dimension <code>d</code>, by getting the reference space <code>Vref=reference_spaces(M,d)[r]</code> with <code>r=face_reference_id(M,d)[F_id]</code> and then calling <code>Ωref = domain(Vref)</code>.</p><h2 id="Physical-faces"><a class="docs-heading-anchor" href="#Physical-faces">Physical faces</a><a id="Physical-faces-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-faces" title="Permalink"></a></h2><p>A physical face <span>$F\in M$</span> is defined as the image <span>$\phi^F(\hat \Omega(F))$</span> of its reference domain <span>$\hat \Omega(F)$</span> via a map <span>$\phi^F: \mathbb{R}^d \rightarrow \mathbb{R}^D$</span>, where <span>$d$</span> is the dimension of <span>$F$</span> and <span>$D$</span> is the ambient dimension of the mesh, see next Figure. This map is called the <em>coordinate map</em> and it is defined using the reference space <span>$\hat V(F)$</span> and the node coordinates <span>$x(F)$</span> of the face <span>$F$</span>.</p><p>The coordinate map for a face <span>$F$</span> is defined as follows:</p><p class="math-container">\[\phi^F(\hat x) := \sum_{n=1}^{N^F} x^F_n s^{\hat V}_n(\hat x),\]</p><p>where <span>$N^F:=|s(\hat V(F))|$</span> is the number of nodes of <span>$F$</span> and <span>$x^F_n:=[x(F)]_n$</span>, and <span>$s^{\hat V }_n:=s(\hat V(F))$</span>. This map transforms the node coordinates in the reference space <span>$x(\hat V(F))$</span> into the physical node coordinates of a face <span>$x(F)$</span> (see the orange dots in next figure). The map also transforms any other point in the reference domain, leading to potentially curved faces in the physical face.</p><p>From a physical face <code>F::AbstractMeshFace</code>, we can obtain its coordinate map and additional geometrical information such as is barycenter and its diameter, namely <code>coordinate_map(F)</code>, <code>barycenter(F)</code> and <code>dimameter(F)</code>.</p><p><img src="../fig_meshes_defs_3.png" alt/></p><p><strong>Figure:</strong> Effect of mapping a reference cube with a third order coordinate map. Orange dots illustrate the nodes before and after the map.</p><pre><code class="language-julia hljs">#Code used to generate the figure
import GalerkinToolkit as GT
import GLMakie as Makie
import StaticArrays
order = 3
Ωref = GT.unit_n_cube(Val(3))
Mref = GT.mesh(Ωref)
Vref = GT.lagrange_space(Ωref,order)
xref = GT.node_coordinates(Vref)
T = StaticArrays.SVector{3,Float64}
x = map(y-&gt;y + 0.1*(rand(T) .- 0.5) ,xref)
node_coordinates = x
N = GT.num_nodes(Vref)
face_nodes = [collect(1:N)]
reference_spaces = (Vref,)
M = GT.create_chain(;
    node_coordinates,
    face_nodes,
    reference_spaces,
   )
F = GT.domain(M,3)
fig = Makie.Figure()
aspect = :data
ax = Makie.Axis3(fig[1,1];aspect)
GT.makie_surfaces!(ax,Mref)
Makie.scatter!(xref;color=Makie.Cycled(2))
ax = Makie.Axis3(fig[1,2];aspect)
refinement = 30
GT.makie_surfaces!(ax,F;refinement)
Makie.scatter!(x;color=Makie.Cycled(2))</code></pre><h2 id="Face-groups"><a class="docs-heading-anchor" href="#Face-groups">Face groups</a><a id="Face-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Face-groups" title="Permalink"></a></h2><p>For a given <span>$d$</span>, we call a <em>face group</em> to a subset <span>$G\subset M$</span> of the <span>$d$</span>-faces in a mesh <span>$M$</span>. A mesh is typically endowed with several of these groups to identify particular faces for modeling purposes, e.g., to impose boundary conditions, or define position-dependent material properties. Each group is given a <em>group name</em>, which identifies the group.</p><p>In the API, <code>group_faces(M,d)</code> provides access to the face groups for faces of dimension <code>d</code>. It is a Julia <code>Dict</code>. The keys are <code>String</code> objects for the group names, and the value <code>group_faces(M,d)[group]</code> is a vector of integers containing the face ids for faces inside the group with name <code>name</code>. The keys of this dictionary can also be accessed as <code>group_names(M,d)</code>. Face groups are defined per dimension and it is accepted to have the same group name in two or more dimensions. It is also possible to add new groups by adding new key-value pairs to this dictionary.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>We illustrate how a new face group is added to an existing mesh. We create a new group with all 2-faces whose center is inside the ball centered at the origin and radius 1. The example uses part of the API described above to find the faces to be added in the group. We color code faces inside the group with value 1, and outside with value 0.</p><pre><code class="language-julia hljs">import GalerkinToolkit as GT
import GLMakie as Makie
using LinearAlgebra

#Create a Cartesian mesh mesh
domain = (0,1,-1,1,0,1)
cells = (10,20,10)
mesh = GT.cartesian_mesh(domain,cells)

#Find faces in new group
d = 3
mesh_faces = GT.each_face(mesh,d)
new_group_faces = findall(mesh_faces) do F
    x = GT.barycenter(F)
    norm(x) &lt; 1
end

#Add new group to mesh
GT.group_faces(mesh,d)[&quot;foo&quot;] = new_group_faces

#Visualize
color = GT.FaceColor(&quot;foo&quot;)
fig = Makie.Figure()
aspect = :data
ax = Makie.Axis3(fig[1,1];aspect)
surfs = GT.makie_surfaces!(ax,mesh;dim=d,color)
GT.makie_edges!(ax,mesh;color=:black)
Makie.Colorbar(fig[1,2],surfs)</code></pre><p><img src="../fig_meshes_defs_4.png" alt/></p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>We discussed how computational meshes are defined in GalerkinToolkit and the core API of the <code>AbstractMesh</code> interface. The following table provides an overview of the math notation and corresponding API introduced in this page.</p><table><tr><th style="text-align: right">Concept</th><th style="text-align: right">Notation</th><th style="text-align: right">API</th></tr><tr><td style="text-align: right">Mesh</td><td style="text-align: right"><span>$M$</span></td><td style="text-align: right"><code>M::AbstractMesh</code></td></tr><tr><td style="text-align: right">Physical face</td><td style="text-align: right"><span>$F$</span></td><td style="text-align: right"><code>F::AbstractMeshFace</code></td></tr><tr><td style="text-align: right">Face iteration</td><td style="text-align: right"><span>$F\in M$</span></td><td style="text-align: right"><code>each_face(M)</code></td></tr><tr><td style="text-align: right">Dimensions</td><td style="text-align: right"><span>$d(x)$</span></td><td style="text-align: right"><code>num_dims(x)</code></td></tr><tr><td style="text-align: right">Ambient dimensions</td><td style="text-align: right"><span>$D(x)$</span></td><td style="text-align: right"><code>num_ambient_dims(x)</code></td></tr><tr><td style="text-align: right">Co-dimensions</td><td style="text-align: right"><span>$D(x)-d(x)$</span></td><td style="text-align: right"><code>num_codims(x)</code></td></tr><tr><td style="text-align: right">Face id</td><td style="text-align: right"><span>$\text{id}(F)$</span></td><td style="text-align: right"><code>id(F)</code></td></tr><tr><td style="text-align: right">Node coordinates</td><td style="text-align: right"><span>$x(A)$</span></td><td style="text-align: right"><code>node_coordinates(A)</code></td></tr><tr><td style="text-align: right">Node ids</td><td style="text-align: right"><span>$n(A)$</span></td><td style="text-align: right"><code>nodes(A)</code></td></tr><tr><td style="text-align: right">Number of nodes</td><td style="text-align: right">$ |n(A)| $</td><td style="text-align: right"><code>num_nodes(A)</code></td></tr><tr><td style="text-align: right">Reference id</td><td style="text-align: right"></td><td style="text-align: right"><code>r=reference_id(F)</code></td></tr><tr><td style="text-align: right">Reference space</td><td style="text-align: right"><span>$\hat V(F)$</span></td><td style="text-align: right"><code>Vref=reference_space(F)</code></td></tr><tr><td style="text-align: right">Shape functions</td><td style="text-align: right"><span>$s(V)$</span></td><td style="text-align: right"><code>shape_functions(Vref)</code></td></tr><tr><td style="text-align: right">Reference domain</td><td style="text-align: right"><span>$\hat \Omega(F)$</span></td><td style="text-align: right"><code>reference_domain(F)</code></td></tr><tr><td style="text-align: right">Chain</td><td style="text-align: right"><span>$C(\hat\Omega)$</span></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">Face groups</td><td style="text-align: right"></td><td style="text-align: right"><code>group_faces(M,d)</code></td></tr><tr><td style="text-align: right">Group names</td><td style="text-align: right"></td><td style="text-align: right"><code>group_names(M,d)</code></td></tr></table><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../manual/introduction/">« Introduction</a><a class="docs-footer-nextpage" href="../manual_mesh_topology/">Mesh topology »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 28 November 2025 08:41">Friday 28 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
