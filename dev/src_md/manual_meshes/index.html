<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Meshes · GalerkinToolkit</title><meta name="title" content="Meshes · GalerkinToolkit"/><meta property="og:title" content="Meshes · GalerkinToolkit"/><meta property="twitter:title" content="Meshes · GalerkinToolkit"/><meta name="description" content="Documentation for GalerkinToolkit."/><meta property="og:description" content="Documentation for GalerkinToolkit."/><meta property="twitter:description" content="Documentation for GalerkinToolkit."/><meta property="og:url" content="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/manual_meshes/"/><meta property="twitter:url" content="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/manual_meshes/"/><link rel="canonical" href="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/manual_meshes/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GalerkinToolkit logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GalerkinToolkit</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/">Manual</a></li><li><a class="tocitem" href="../../manual/introduction/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Meshes</a><ul class="internal"><li><a class="tocitem" href="#Mesh-specification"><span>Mesh specification</span></a></li><li><a class="tocitem" href="#Creating-a-mesh"><span>Creating a mesh</span></a></li><li><a class="tocitem" href="#Cell-complexes"><span>Cell complexes</span></a></li><li><a class="tocitem" href="#Mesh-topology"><span>Mesh topology</span></a></li><li><a class="tocitem" href="#Face-groups"><span>Face groups</span></a></li><li><a class="tocitem" href="#Gmsh-meshes"><span>Gmsh meshes</span></a></li></ul></li><li><a class="tocitem" href="../manual_domains/">Domains</a></li><li><a class="tocitem" href="../manual_interpolation/">Interpolation</a></li><li><a class="tocitem" href="../manual_visualization/">Visualization</a></li><li><a class="tocitem" href="../../manual/for_developers/">For developers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../example_hello_world/">Hello, World!</a></li><li><a class="tocitem" href="../example_poisson_equation/">Poisson equation</a></li><li><a class="tocitem" href="../example_p_laplacian/">p-Laplacian</a></li><li><a class="tocitem" href="../example_stokes/">Stokes lid-driven cavity</a></li><li><a class="tocitem" href="../example_transient_heat_eq/">Transient heat equation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/">Tutorials</a></li><li><a class="tocitem" href="../tutorial_intro_to_fem/">Introduction to the FEM</a></li></ul></li><li><a class="tocitem" href="../../reference/">API</a></li><li><a class="tocitem" href="../../refindex/">Index</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Meshes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Meshes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/main/docs/src/src_jl/manual_meshes.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Meshes"><a class="docs-heading-anchor" href="#Meshes">Meshes</a><a id="Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes" title="Permalink"></a></h1><p>A mesh object in GalerkinToolkit contains all geometrical information needed in a finite element (FE) computation. A mesh is a set of polygons (or polytopes in general) which we refer to as <em>faces</em> or <span>$d$</span><em>-faces</em>, where <span>$d$</span> is the face parametric dimension. We call <em>vertices</em>, <em>edges</em>, <em>surfaces</em>, and <em>volumes</em> to faces of 0, 1, 2, and 3 dimensions respectively. Meshes also include additional metadata, including <em>face groups</em> used to identify particular faces in the mesh, e.g., to impose boundary conditions.</p><p>It is worth noting that GalerkinToolkit is not a mesh generation library. The mesh implementation is designed to provide the rich geometrical information needed in FE methods, rather than mesh generation. Meshes are often generated with external tools and then transformed into GalerkinToolkit objects with helper functions such as <a href="../../reference/#GalerkinToolkit.mesh_from_gmsh-Tuple{Module}"><code>mesh_from_gmsh</code></a>.</p><h3 id="Code-dependencies"><a class="docs-heading-anchor" href="#Code-dependencies">Code dependencies</a><a id="Code-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Code-dependencies" title="Permalink"></a></h3><p>We use the following dependencies in the code snippets in this page.</p><pre><code class="language-julia hljs">import GalerkinToolkit as GT
import GLMakie
import Makie
import StaticArrays</code></pre><p>In GalerkinToolkit we load dependencies from the Julia standard library with <code>using</code> statements, and from other packages with <code>import</code> statements. The latter forces to qualify functions with the package name, which explicitly reveals their origin. We do not qualify functions from the standard library since they are well known by Julia programmers.</p><h2 id="Mesh-specification"><a class="docs-heading-anchor" href="#Mesh-specification">Mesh specification</a><a id="Mesh-specification-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-specification" title="Permalink"></a></h2><p>All types implementing meshes are subtypes of <a href="../../reference/#GalerkinToolkit.AbstractMesh"><code>AbstractMesh</code></a>. Important features of a mesh include:</p><ul><li>A mesh can potentially contain faces with different number of dimensions. I.e., the same mesh object can include vertices, edges, surfaces, and volumes. The number of dimensions of a mesh is the maximum number of dimension of its faces.</li><li>The number of dimensions of a mesh can be smaller or equal to the number of <em>ambient</em> dimension. The latter is the number of components in a node coordinate vector.</li><li>A mesh might or might not represent a cell complex. However, many algorithms require to work with a cell complex.</li><li><em>Physical</em> faces are defined using reference interpolation spaces and node coordinates. A physical face <span>$F=\varphi(\hat F)$</span> is defined by transforming a <em>reference</em> face <span>$\hat F$</span> with a mapping <span>$\varphi: \hat F \rightarrow \mathbb{R}^D$</span>, where D is the number of ambient dimensions.  The mapping is defined as <span>$\varphi(\hat x) = \sum_i \hat s_i(\hat x) x_{(F,i)}$</span>. Function <span>$\hat s_i: \hat F \rightarrow \mathbb{R}$</span> is the scalar basis function number <span>$i$</span> in the reference (interpolation) space of <span>$F$</span>. The vector <span>$x_{(F,i)}$</span> contains the coordinates of the local node <span>$i$</span> in face <span>$F$</span>.</li></ul><p>Functions to create and to work with meshes are listed in docstring of <a href="../../reference/#GalerkinToolkit.AbstractMesh"><code>AbstractMesh</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GalerkinToolkit.AbstractMesh-src_md-manual_meshes" href="#GalerkinToolkit.AbstractMesh-src_md-manual_meshes"><code>GalerkinToolkit.AbstractMesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractMesh &lt;: AbstractType end</code></pre><p>Abstract type representing a computational mesh.</p><p><strong>Level</strong></p><p>Beginner</p><p><strong>Constructors</strong></p><ul><li><a href="../../reference/#GalerkinToolkit.create_mesh"><code>create_mesh</code></a></li><li><a href="../../reference/#GalerkinToolkit.mesh_from_msh-Tuple{Any}"><code>mesh_from_msh</code></a></li><li><a href="../../reference/#GalerkinToolkit.mesh_from_gmsh-Tuple{Module}"><code>mesh_from_gmsh</code></a></li><li><a href="../../reference/#GalerkinToolkit.cartesian_mesh-Tuple{Any, Any}"><code>cartesian_mesh</code></a></li><li><a href="../../reference/#GalerkinToolkit.complexify"><code>complexify</code></a></li><li><a href="../../reference/#GalerkinToolkit.simplexify"><code>simplexify</code></a></li></ul><p><strong>Queries</strong></p><ul><li><a href="../../reference/#GalerkinToolkit.num_dims"><code>num_dims</code></a></li><li><a href="../../reference/#GalerkinToolkit.num_ambient_dims"><code>num_ambient_dims</code></a></li><li><a href="../../reference/#GalerkinToolkit.num_codims"><code>num_codims</code></a></li><li><a href="../../reference/#GalerkinToolkit.num_faces"><code>num_faces</code></a></li><li><a href="../../reference/#GalerkinToolkit.num_nodes"><code>num_nodes</code></a></li><li><a href="../../reference/#GalerkinToolkit.node_coordinates"><code>node_coordinates</code></a></li><li><a href="../../reference/#GalerkinToolkit.face_nodes"><code>face_nodes</code></a></li><li><a href="../../reference/#GalerkinToolkit.face_reference_id"><code>face_reference_id</code></a></li><li><a href="../../reference/#GalerkinToolkit.reference_spaces"><code>reference_spaces</code></a></li><li><a href="../../reference/#GalerkinToolkit.group_faces"><code>group_faces</code></a></li><li><a href="../../reference/#GalerkinToolkit.group_names"><code>group_names</code></a></li><li><a href="../../reference/#GalerkinToolkit.is_cell_complex"><code>is_cell_complex</code></a></li><li><a href="../../reference/#GalerkinToolkit.normals"><code>normals</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/6b0015a1d364e3692ebeb02300814f0cda49623a/src/abstract_types.jl#L7-L41">source</a></section></article><h2 id="Creating-a-mesh"><a class="docs-heading-anchor" href="#Creating-a-mesh">Creating a mesh</a><a id="Creating-a-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-mesh" title="Permalink"></a></h2><p>Arbitrary mesh objects are defined from low-level quantities with function <a href="../../reference/#GalerkinToolkit.create_mesh"><code>create_mesh</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GalerkinToolkit.create_mesh-src_md-manual_meshes" href="#GalerkinToolkit.create_mesh-src_md-manual_meshes"><code>GalerkinToolkit.create_mesh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_mesh(;kwargs...)</code></pre><p>Build an arbitrary mesh object.</p><p>See also <a href="../../reference/#GalerkinToolkit.cartesian_mesh-Tuple{Any, Any}"><code>cartesian_mesh</code></a>, <a href="../../reference/#GalerkinToolkit.mesh_from_msh-Tuple{Any}"><code>mesh_from_msh</code></a>, and <a href="../../reference/#GalerkinToolkit.mesh_from_gmsh-Tuple{Module}"><code>mesh_from_gmsh</code></a>.</p><p><strong>Level</strong></p><p>Intermediate</p><p><strong>Keyword arguments</strong></p><ul><li><code>node_coordinates</code>: The vector containing the coordinates of all mesh nodes. <code>node_coordinates[i]</code> is the coordinate vector for <em>global</em> node number <code>i</code>.</li><li><code>face_nodes</code>: A highly-nested vector containing the node ids for each face in the mesh. <code>node_coordinates[n]</code> with <code>n=face_nodes[d+1][i][k]</code> is the global node coordinate vector for <em>local</em> node number <code>k</code> in face <code>i</code> of dimension <code>d</code>. The object <code>face_nodes[d+1]</code> is a long vector of small vectors of integers. It is often represented using a <code>JaggedArray</code> object that uses continuous linear memory for performance.</li><li><code>reference_spaces</code>: A nested tuple containing the reference spaces for faces. <code>reference_spaces[d+1][i]</code> is the reference space number <code>i</code> in dimension <code>d</code>. Reference interpolation spaces are defined with functions like <a href="../../reference/#GalerkinToolkit.lagrange_space"><code>lagrange_space</code></a>.</li><li><code>face_reference_id</code> [optional]: A nested vector containing which reference space is assigned to each face. <code>reference_sapces[d+1][r]</code> with <code>r=face_reference_id[d+1][i]</code> is the reference space associated with face number <code>i</code> of dimension <code>d</code>. By default, all faces are assigned to the first reference space in its dimension.</li><li><code>group_faces</code> [optional]: A vector of dictionaries containing labeled groups of faces. <code>group_faces[d+1][group_name]</code> is a vector of integers containing the ids  of the faces of dimension <code>d</code> in the group named <code>group_name</code>. These groups might overlap. By default, no faces groups are created.</li><li><code>is_cell_complex=Val(false)</code> [optional]: <code>Val(true)</code> if the input data represents a cell complex, <code>Val(false)</code> otherwise.</li><li><code>normals=nothing</code> [optinal]: Vector containing the normal vectors for the faces of maximum dimension of the mesh. This is relevant for meshes of dimension <code>d</code> embedded in <code>d+1</code> dimensions as there is no way to tell which should be the orientation of the normals from the other quantities in the mesh.  <code>normals[f]</code> gives the normal vector of face number <code>f</code> of dimension <code>d=length(face_nodes)-1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/6b0015a1d364e3692ebeb02300814f0cda49623a/src/mesh.jl#L513-L533">source</a></section></article><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>In the following example, we generate and visualize a mesh of three first order triangles. Only faces of dimension 2 are present in this example. The arrays for vertices and edges are empty.</p><pre><code class="language-julia hljs">#Node coordinates
T = StaticArrays.SVector{2,Float64}
node_coordinates = T[(0,0),(1,0),(0,1),(1,1),(2,0)]

#Face nodes
face_nodes_0 = Vector{Int}[]
face_nodes_1 = Vector{Int}[]
face_nodes_2 = [[1,2,3],[2,3,4],[2,4,5]]
face_nodes = [
    face_nodes_0,
    face_nodes_1,
    face_nodes_2]

#Reference spaces
reference_spaces_0 = ()
reference_spaces_1 = ()
order = 1
triangle = GT.unit_simplex(Val(2))
triangle3 = GT.lagrange_space(triangle,order)
reference_spaces_2 = (triangle3,)
reference_spaces = (
    reference_spaces_0,
    reference_spaces_1,
    reference_spaces_2)

#Create mesh
mesh = GT.create_mesh(;
    node_coordinates,
    face_nodes,
    reference_spaces)

#Visualize
axis = (;aspect=Makie.DataAspect())
shading = Makie.NoShading
GT.makie_surfaces(mesh;axis,shading)
GT.makie_edges!(mesh;color=:black)</code></pre><p><img src="../fig_meshes_1.png" alt/></p><h3 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h3><p>In this other slightly more complex example, we define a mesh including faces of different dimensions: surfaces, edges and vertices. To be able to see all faces in the visualization, we need to &quot;shrink&quot; them. Otherwise, the surfaces would hide the edges and vertices.</p><pre><code class="language-julia hljs">#Face nodes
face_nodes_0 = [[1],[3]]
face_nodes_1 = [[1,2],[2,5],[5,4]]
face_nodes_2 = [[1,2,3],[2,3,4],[2,4,5]]
face_nodes = [
    face_nodes_0,
    face_nodes_1,
    face_nodes_2]

#Reference spaces
vertex = GT.unit_simplex(Val(0))
vertex1 = GT.lagrange_space(vertex,order)
segment = GT.unit_simplex(Val(1))
segment2 = GT.lagrange_space(segment,order)
reference_spaces_0 = (vertex1,)
reference_spaces_1 = (segment2,)
reference_spaces_2 = (triangle3,)
reference_spaces = (
    reference_spaces_0,
    reference_spaces_1,
    reference_spaces_2)

#Create mesh
mesh = GT.create_mesh(;
    node_coordinates,
    face_nodes,
    reference_spaces)

#Visualize
axis = (;aspect=Makie.DataAspect())
shrink = 0.8
GT.makie_surfaces(mesh;axis,shading,shrink)
GT.makie_edges!(mesh;dim=1,shrink)
GT.makie_vertices!(mesh;dim=0)</code></pre><p><img src="../fig_meshes_2.png" alt/></p><h2 id="Cell-complexes"><a class="docs-heading-anchor" href="#Cell-complexes">Cell complexes</a><a id="Cell-complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Cell-complexes" title="Permalink"></a></h2><p>The mesh object described above is general enough to describe cell or <a href="https://en.wikipedia.org/wiki/Polyhedral_complex">polyhedral complexes</a>, but it is not guaranteed that the mesh is indeed a cell complex. For instance, none of the meshes in the two last examples is a cell complex. The first one has no vertices nor edges. The second one has only few vertices and edges, but many are missing. One can complete a given mesh with all low-dimensional faces needed to be a cell complex with function <a href="../../reference/#GalerkinToolkit.complexify"><code>complexify</code></a>. Calling <a href="../../reference/#GalerkinToolkit.is_cell_complex"><code>is_cell_complex</code></a> on the returned mesh, will give <code>true</code>.</p><p>For function <code>complexify</code> to work, neighboring faces should share node ids. I.e., duplicated nodes are not allowed in the input mesh. Otherwise, duplicated faces might be generated, or the functions might not work at all.</p><h3 id="Example-3"><a class="docs-heading-anchor" href="#Example-3">Example</a><a class="docs-heading-anchor-permalink" href="#Example-3" title="Permalink"></a></h3><p>Let us complete the mesh we generated in the last example into a cell complex.</p><pre><code class="language-julia hljs">#Convert
mesh2 = GT.complexify(mesh)
@assert GT.is_cell_complex(mesh2)

#Visualize
GT.makie_surfaces(mesh2;axis,shading,shrink)
GT.makie_edges!(mesh2;dim=1,shrink)
GT.makie_vertices!(mesh2;dim=0)</code></pre><p><img src="../fig_meshes_3.png" alt/></p><p>Note that the mesh contains now all low-dimensional faces.</p><h2 id="Mesh-topology"><a class="docs-heading-anchor" href="#Mesh-topology">Mesh topology</a><a id="Mesh-topology-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-topology" title="Permalink"></a></h2><p>When a mesh is a cell complex, there are well-defined face incidence relationships. All face incidence relations are stored in an object called mesh <em>topology</em>. A mesh topology is represented by the type <a href="../../reference/#GalerkinToolkit.AbstractTopology"><code>AbstractTopology</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GalerkinToolkit.AbstractTopology-src_md-manual_meshes" href="#GalerkinToolkit.AbstractTopology-src_md-manual_meshes"><code>GalerkinToolkit.AbstractTopology</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractTopology</code></pre><p>Abstract type representing the incidence relations in a cell complex.</p><p><strong>Level</strong></p><p>Intermediate</p><p><strong>Constructors</strong></p><ul><li><a href="../../reference/#GalerkinToolkit.topology-Tuple{GalerkinToolkit.AbstractMesh}"><code>topology</code></a></li></ul><p><strong>Queries</strong></p><ul><li><a href="../../reference/#GalerkinToolkit.face_incidence"><code>face_incidence</code></a></li><li><a href="../../reference/#GalerkinToolkit.face_reference_id"><code>face_reference_id</code></a></li><li><a href="../../reference/#GalerkinToolkit.face_permutation_ids"><code>face_permutation_ids</code></a></li><li><a href="../../reference/#GalerkinToolkit.reference_topologies"><code>reference_topologies</code></a></li><li><a href="../../reference/#GalerkinToolkit.vertex_permutations"><code>vertex_permutations</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/6b0015a1d364e3692ebeb02300814f0cda49623a/src/abstract_types.jl#L110-L131">source</a></section></article><h3 id="Incidence-relations"><a class="docs-heading-anchor" href="#Incidence-relations">Incidence relations</a><a id="Incidence-relations-1"></a><a class="docs-heading-anchor-permalink" href="#Incidence-relations" title="Permalink"></a></h3><p>A mesh topology is obtained with function <a href="../../reference/#GalerkinToolkit.topology-Tuple{GalerkinToolkit.AbstractMesh}"><code>topology</code></a> called on a given mesh object: <code>topo = GT.topology(mesh)</code>. The mesh needs to be a cell complex for this to work.  Then, one uses function <a href="../../reference/#GalerkinToolkit.face_incidence"><code>face_incidence</code></a> on the topology object to get the incidence relations. <code>GT.face_incidence(topo,D,d)</code> is a long vector of small vectors of integers, often implemented with a <code>JaggedArray</code>.</p><ul><li>For <code>d&lt;D</code>, <code>GT.face_incidence(topo,D,d)[F]</code> is a vector of integers containing the ids of the faces of dimension <code>d</code> on the boundary of face number <code>F</code> of dimension <code>D</code>.</li><li>For <code>d&lt;D</code>, <code>GT.face_incidence(topo,d,D)[f]</code> is a vector of integers containing the ids of the faces of dimension <code>D</code> around the face number <code>f</code> of dimension <code>d</code>.</li><li>For <code>d==D</code>, <code>GT.face_incidence(topo,D,D)[F] == [F]</code>.</li></ul><h3 id="Example-4"><a class="docs-heading-anchor" href="#Example-4">Example</a><a class="docs-heading-anchor-permalink" href="#Example-4" title="Permalink"></a></h3><p>Let us get some of the incidence relations for the cell complex we generated above.</p><pre><code class="language-julia hljs">topo = GT.topology(mesh2)
surface_to_edges = GT.face_incidence(topo,2,1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element PartitionedArrays.JaggedArray{Int32, Int32}:
 [1, 4, 5]
 [5, 6, 7]
 [6, 2, 3]</code></pre><p>This output is read as follows. Surface 1 has edges 1, 4, and 5 on its boundary; surface 2 has edges 5, 6, 7 on its boundary; etc.</p><pre><code class="language-julia hljs">edge_to_surfaces = GT.face_incidence(topo,1,2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7-element PartitionedArrays.JaggedArray{Int32, Int32}:
 [1]
 [3]
 [3]
 [1]
 [1, 2]
 [2, 3]
 [2]</code></pre><p>According to this output, edge 1 touches surface 1, edge 2 touches surface 3, etc. We can also see that there are two interior edges touching two surfaces. Edge 5 touches surfaces 1 and 2, and edge 6 touches surfaces 2 and 3.</p><h3 id="Reference-topologies"><a class="docs-heading-anchor" href="#Reference-topologies">Reference topologies</a><a id="Reference-topologies-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-topologies" title="Permalink"></a></h3><p>The reference faces in a mesh are also cell complexes. For instance, a reference volume has surfaces, edges, and vertices on its boundary. The incidence relation between the faces in a reference face are obtained using  a <em>reference topology</em>. Reference topologies are accessed with function <a href="../../reference/#GalerkinToolkit.reference_topologies"><code>reference_topologies</code></a> given a topology object.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GalerkinToolkit.reference_topologies-src_md-manual_meshes" href="#GalerkinToolkit.reference_topologies-src_md-manual_meshes"><code>GalerkinToolkit.reference_topologies</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reference_topologies(topo)
reference_topologies(topo,d)
reference_topologies(topo,Val(d))</code></pre><p>Return the list (a vector or a tuple) of reference topologies in <code>topo</code> of dimension <code>d</code>. If the second argument is omitted, then the function returns a collection such that <code>reference_topologies(topo)[d+1]</code> is equivalent to <code>reference_topologies(topo,Val(d))</code>.</p><p>The face reference topology of face <code>f</code> of dimension <code>d</code>, is accessed as <code>reference_topologies(topo,d)[r]</code> with <code>r=face_reference_id(topo,d)[f]</code>.</p><p>See also <a href="../../reference/#GalerkinToolkit.face_reference_id"><code>face_reference_id</code></a>.</p><p><strong>Level</strong></p><p>Intermediate</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/6b0015a1d364e3692ebeb02300814f0cda49623a/src/abstract_types.jl#L680-L695">source</a></section></article><p>The rationale behind accessing reference topologies is analogous to accessing reference spaces in a mesh. Note, however, that the face reference ids in  a mesh <code>mesh</code>, <code>GT.face_reference_id(mesh,d)</code> might be different from the ones in the corresponding mesh topology <code>topo</code>, <code>GT.face_reference_id(topo,d)</code>, since different interpolation spaces can be defined on the same reference face (e.g., in p-adaptive methods).</p><p>A reference topology object behaves like any other topology object and can be queried with the methods from the <a href="../../reference/#GalerkinToolkit.AbstractTopology"><code>AbstractTopology</code></a> interface.</p><h3 id="Example-5"><a class="docs-heading-anchor" href="#Example-5">Example</a><a class="docs-heading-anchor-permalink" href="#Example-5" title="Permalink"></a></h3><p>We get the reference topology of the first 2-face of the previously generated topology, which corresponds to a reference triangle. Then, we show the incidence relation between edges and vertices, i.e., for each edge which are the vertices on its boundary.</p><pre><code class="language-julia hljs">#Get the reference topology
f = 1
r = GT.face_reference_id(topo,2)[f]
ref_topo = GT.reference_topologies(topo,2)[r]

#See the edge to vertex relations
edge_to_vertices = GT.face_incidence(ref_topo,1,0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element PartitionedArrays.JaggedArray{Int32, Int32}:
 [1, 2]
 [1, 3]
 [2, 3]</code></pre><p>The first edge goes from vertex 1 to 2, the second edge from vertex 1 to 3, and the third edge from vertex 2 to 3.</p><h3 id="Permutations"><a class="docs-heading-anchor" href="#Permutations">Permutations</a><a id="Permutations-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations" title="Permalink"></a></h3><p>If a mesh is a cell complex, each face in the boundary of a face is also explicitly contained in the mesh. However, the incidence relations of these two faces are the same but might be stored in different order.</p><p>Let us consider a topology  object <code>topo</code> and two integers <code>d&lt;D</code>. We get the incident relations <code>D_d = GT.face_incidence(topo,D,d)</code>, <code>d_0 = GT.face_incidence(topo,d,0)</code> and <code>D_0 = GT.face_incidence(topo,D,0)</code>. Consider face number <code>v</code> in dimension <code>D</code>. The <code>d</code>-faces on its boundary are given in vector <code>D_d[v]</code>. Consider the integer in <code>l</code> position in this list, namely <code>s=D_d[v][l]</code>. <code>s</code> is the id of a face of dimension <code>d</code>. The 0-faces on the boundary of <code>v</code> are  in <code>D_0[v]</code> and on the boundary of <code>s</code> are in <code>d_0[s]</code>.  Now, consider the reference topology of face <code>v</code>, namely <code>ref_topo_v</code>. We get this incidence relation from the reference topology: <code>ref_d_0 = GT.face_incidence(ref_topo_v,d,0)</code>. This gives us an alternative way of obtaining the 0-faces of <code>s</code>, namely <code>D_0[ref_d_0[l]]</code>. That is, we can take the id <code>s</code> and compute directly <code>d_0[s]</code>, or we can go to the neighbor face <code>v</code> and compute <code>D_0[ref_d_0[l]]</code> using the local id <code>l</code> corresponding to <code>s</code> in <code>v</code>. The vectors <code>d_0[s]</code> and  <code>D_0[ref_d_0[l]]</code> contain the same vertex ids, but not in the same order!</p><p>To fix this issue we provide the permutation <code>P</code> that transforms one vector into the other, namely <code>d_0[s][P] == D_0[ref_d_0[l]]</code>. For <code>d==1</code>, the permutation vector <code>P</code> is either <code>[1,2]</code> or <code>[2,1]</code> since an edge has two vertices. In general, the possible permutations are enumerated and stored in the reference topology associated with face <code>s</code>, namely <code>ref_topo_s</code>. They are accessed with function <a href="../../reference/#GalerkinToolkit.vertex_permutations"><code>vertex_permutations</code></a> in this way: <code>k_P = GT.vertex_permutations(ref_topo_s)</code>. This is a vector of vectors containing all permutations. To get the permutation <code>P</code> from this list, we use function <a href="../../reference/#GalerkinToolkit.face_permutation_ids"><code>face_permutation_ids</code></a>. First we get an index into the list of permutations with <code>k=GT.face_permutation_ids(topo,D,0)[v][l]</code> and using the index <code>k</code>, we get the permutation from the list <code>P = k_P[k]</code>.</p><p>This information is needed in many situations, including the generation of high-order interpolation spaces and integration of jump and average terms on interior faces in discontinuous Galerkin methods.</p><h2 id="Face-groups"><a class="docs-heading-anchor" href="#Face-groups">Face groups</a><a id="Face-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Face-groups" title="Permalink"></a></h2><p>Face groups allow us to select specific faces in a mesh for different modeling purposes: impose boundary conditions, define different equations in different parts of the mesh etc. A face group is a vector of integers containing the ids of the faces in this group plus a string containing a name for this group. This groups are stored using a dictionary that maps strings to vectors (group names to group definitions) in a per dimension basis (one dictionary per dimension). The vector contains faces of the same dimension, but it is possible define groups containing faces of different dimensions by splitting them in a vector per dimension. Face groups can overlap and can be added after the mesh object is created.</p><p>Face groups are accessed and added using function <a href="../../reference/#GalerkinToolkit.group_faces"><code>group_faces</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GalerkinToolkit.group_faces-src_md-manual_meshes" href="#GalerkinToolkit.group_faces-src_md-manual_meshes"><code>GalerkinToolkit.group_faces</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">group_faces(mesh)
group_faces(mesh,d)</code></pre><p>Return the dictionary containing the faces in each group in dimension <code>d</code>. If <code>d</code> is omitted, it returns the dictionaries for all dimensions in a vector. I.e., calling <code>group_faces(mesh,d)</code> is equivalent to <code>group_faces(mesh)[d+1]</code>.</p><p>The faces of dimension <code>d</code> in group <code>group</code> are <code>group_faces(mesh,d)[group_name]</code>, where <code>group_name</code> is a string with the group name. One can create new groups by adding new keys to these dictionaries as long as the key is not already present. Calling <code>group_faces(mesh,d)[new_group_name] = faces_in_newgroup</code> will add a new group to dimension <code>d</code> with name equal to the string <code>new_group_name</code> with faces in vector <code>faces_in_newgroup</code>.</p><p>See also <a href="../../reference/#GalerkinToolkit.group_names"><code>group_names</code></a>.</p><p><strong>Level</strong></p><p>Beginner</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/6b0015a1d364e3692ebeb02300814f0cda49623a/src/abstract_types.jl#L535-L553">source</a></section></article><h3 id="Common-face-groups"><a class="docs-heading-anchor" href="#Common-face-groups">Common face groups</a><a id="Common-face-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Common-face-groups" title="Permalink"></a></h3><p>GalerkinToolkit provides a number of functions that generate commonly used face groups.</p><ul><li><a href="../../reference/#GalerkinToolkit.group_boundary_faces!"><code>group_boundary_faces!</code></a></li><li><a href="../../reference/#GalerkinToolkit.group_interior_faces!"><code>group_interior_faces!</code></a></li><li><a href="../../reference/#GalerkinToolkit.group_faces_in_dim!"><code>group_faces_in_dim!</code></a></li></ul><p>These function do what the name suggests (see the docstrings for further details). The first one is often use to impose boundary conditions and the second one in discontinuous Galerkin methods to define interior penalty terms. They are often called under the hood when calling functions like <a href="../../reference/#GalerkinToolkit.boundary"><code>boundary</code></a> and <a href="../../reference/#GalerkinToolkit.skeleton"><code>skeleton</code></a>.</p><h3 id="Example-6"><a class="docs-heading-anchor" href="#Example-6">Example</a><a class="docs-heading-anchor-permalink" href="#Example-6" title="Permalink"></a></h3><p>Let us add some face groups to the last mesh we created. We add a group for the boundary edges, for the interior edges, and a group for the two first surfaces.</p><pre><code class="language-julia hljs">GT.group_boundary_faces!(mesh2;group_name=&quot;boundary&quot;)
GT.group_interior_faces!(mesh2;group_name=&quot;interior&quot;)
GT.group_faces(mesh2,2)[&quot;foo&quot;] = [1,2]</code></pre><p>We can also visualize the faces with colors telling if a face belongs to a group or not. We can visualize the mesh faces labeled as &quot;boundary&quot; in orange color, and the rest in blue:</p><pre><code class="language-julia hljs">color = GT.FaceColor(&quot;boundary&quot;)
blue = Makie.wong_colors()[1]
orange = Makie.wong_colors()[2]
colormap = [blue,orange]
GT.makie_surfaces(mesh2;axis,shrink,shading,color,colormap)
GT.makie_edges!(mesh2;dim=1,shrink,color,colormap)
GT.makie_vertices!(mesh2;dim=0,color,colormap)</code></pre><p><img src="../fig_meshes_4.png" alt/></p><p>Idem, but now visualizing the group &quot;foo&quot;.</p><pre><code class="language-julia hljs">color = GT.FaceColor(&quot;foo&quot;)
GT.makie_surfaces(mesh2;axis,shrink,shading,color,colormap)
GT.makie_edges!(mesh2;dim=1,shrink,color,colormap)
GT.makie_vertices!(mesh2;dim=0,color,colormap)</code></pre><p><img src="../fig_meshes_5.png" alt/></p><h2 id="Gmsh-meshes"><a class="docs-heading-anchor" href="#Gmsh-meshes">Gmsh meshes</a><a id="Gmsh-meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Gmsh-meshes" title="Permalink"></a></h2><p>Meshes generated with gmsh can be transformed into GalerkinToolkit mesh objects using functions <a href="../../reference/#GalerkinToolkit.mesh_from_gmsh-Tuple{Module}"><code>mesh_from_gmsh</code></a> and <a href="../../reference/#GalerkinToolkit.mesh_from_msh-Tuple{Any}"><code>mesh_from_msh</code></a>. The <em>physical groups</em> defined within gmsh will be transformed into face groups in the GalerkinToolkit mesh, which is useful to impose boundary conditions. We use <a href="https://github.com/JuliaFEM/Gmsh.jl">Gmsh.jl</a> under the hood as the wrapper to the Julia API of gmsh.</p><h3 id="A-mesh-from-a-msh-file"><a class="docs-heading-anchor" href="#A-mesh-from-a-msh-file">A mesh from a msh file</a><a id="A-mesh-from-a-msh-file-1"></a><a class="docs-heading-anchor-permalink" href="#A-mesh-from-a-msh-file" title="Permalink"></a></h3><p>Function <a href="../../reference/#GalerkinToolkit.mesh_from_msh-Tuple{Any}"><code>mesh_from_msh</code></a> reads and crates a mesh object from a <code>.msh</code> file (the default format used by gmsh to export meshes).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GalerkinToolkit.mesh_from_msh-src_md-manual_meshes" href="#GalerkinToolkit.mesh_from_msh-src_md-manual_meshes"><code>GalerkinToolkit.mesh_from_msh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mesh_from_msh(msh_file;kwargs...)</code></pre><p>Create a mesh object from a <code>.msh</code> file found in path <code>msh_file</code>.</p><p>See also <a href="../../reference/#GalerkinToolkit.mesh_from_gmsh-Tuple{Module}"><code>mesh_from_gmsh</code></a> and <a href="../../reference/#GalerkinToolkit.with_gmsh-Tuple{Any}"><code>with_gmsh</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>complexify=true</code> [optional]: If <code>complexify==true</code>, the mesh will be completed with all low dimensional faces into a cell complex.</li><li><code>renumber=true</code> [optional]: If <code>renumber==true</code>, then <code>gmsh.model.mesh.renumberNodes()</code> and <code>gmsh.model.mesh.renumberElements()</code> will be called.</li><li>Any other keyword argument will be passed to function <a href="../../reference/#GalerkinToolkit.with_gmsh-Tuple{Any}"><code>with_gmsh</code></a>.</li></ul><p><strong>Level</strong></p><p>Beginner</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/6b0015a1d364e3692ebeb02300814f0cda49623a/src/gmsh.jl#L37-L53">source</a></section></article><h3 id="Example-7"><a class="docs-heading-anchor" href="#Example-7">Example</a><a class="docs-heading-anchor-permalink" href="#Example-7" title="Permalink"></a></h3><p>We create a mesh from a <code>.msh</code> file and visualize it. In this case, we only visualize the 2-faces in the mesh. We color them according to the face group named <code>&quot;sides&quot;</code>. Faces in the group are visualized in orange and other faces in blue. This face group is only defined for 2-faces. If you visualize the 3-faces (as by default), you would not see this face group.</p><pre><code class="language-julia hljs">#Read the mesh
assets_dir = normpath(joinpath(@__DIR__,&quot;..&quot;,&quot;..&quot;,&quot;..&quot;,&quot;assets&quot;))
msh_file = joinpath(assets_dir,&quot;model.msh&quot;)
mesh = GT.mesh_from_msh(msh_file)

#Visualize it
fig = Makie.Figure()
ax = Makie.Axis3(fig[1,1];aspect=:data)
Makie.hidespines!(ax)
Makie.hidedecorations!(ax)
color = GT.FaceColor(&quot;sides&quot;)
GT.makie_surfaces!(mesh;dim=2,color,colormap)
GT.makie_edges!(mesh;color=:black)</code></pre><p><img src="../fig_meshes_6.png" alt/></p><h3 id="Meshes-from-the-gmsh-API"><a class="docs-heading-anchor" href="#Meshes-from-the-gmsh-API">Meshes from the gmsh API</a><a id="Meshes-from-the-gmsh-API-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes-from-the-gmsh-API" title="Permalink"></a></h3><p>It is also possible to generate meshes in Julia code using the gmsh API and then convert them to GalerkinToolkit objects. This is done with two functions: See also <a href="../../reference/#GalerkinToolkit.with_gmsh-Tuple{Any}"><code>with_gmsh</code></a> and <a href="../../reference/#GalerkinToolkit.mesh_from_gmsh-Tuple{Module}"><code>mesh_from_gmsh</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GalerkinToolkit.with_gmsh-src_md-manual_meshes" href="#GalerkinToolkit.with_gmsh-src_md-manual_meshes"><code>GalerkinToolkit.with_gmsh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">with_gmsh(f[;options])</code></pre><p>A safe way of initialize and finalize the <code>gmsh</code> module. The given function is called <code>f(gmsh)</code> on the <code>gmsh</code> module after is has been initialized. The module is finalized automatically when the function returns.</p><p>The optional keyword argument <code>options</code> is a vector for pairs <code>k=&gt;v</code> containing gmesh options. Each of these options are set with <code>gmsh.option.setNumber(k,v)</code> just after gmsh has been initialized.</p><p><strong>Level</strong></p><p>Beginner</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/6b0015a1d364e3692ebeb02300814f0cda49623a/src/gmsh.jl#L11-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GalerkinToolkit.mesh_from_gmsh-src_md-manual_meshes" href="#GalerkinToolkit.mesh_from_gmsh-src_md-manual_meshes"><code>GalerkinToolkit.mesh_from_gmsh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mesh_from_gmsh(gmsh::Module;complexify=true)</code></pre><p>Create a mesh objects from the current state of the <code>gmsh</code> module. If <code>complexify==true</code>, the mesh will be completed with all low dimensional faces into a cell complex.</p><p>See also <a href="../../reference/#GalerkinToolkit.mesh_from_msh-Tuple{Any}"><code>mesh_from_msh</code></a> and <a href="../../reference/#GalerkinToolkit.with_gmsh-Tuple{Any}"><code>with_gmsh</code></a>.</p><p><strong>Level</strong></p><p>Beginner</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/6b0015a1d364e3692ebeb02300814f0cda49623a/src/gmsh.jl#L64-L75">source</a></section></article><h3 id="Example-8"><a class="docs-heading-anchor" href="#Example-8">Example</a><a class="docs-heading-anchor-permalink" href="#Example-8" title="Permalink"></a></h3><p>We generate a simple 2d mesh with the gmsh Julia API.</p><pre><code class="language-julia hljs">#Generate mesh with GMSH Julia API
mesh = GT.with_gmsh() do gmsh
    mesh_size=0.04
    T=2
    N=100
    R = 0.15
    dim = 2
    gmsh.option.set_number(&quot;General.Verbosity&quot;, 2)
    rect_tag = gmsh.model.occ.add_rectangle(0,0,0,1,1)
    circle_tag = gmsh.model.occ.add_circle(0.5,0.5,0,R)
    circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])
    circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])
    gmsh.model.occ.cut([(dim,rect_tag)],[(dim,circle_surf_tag)]);
    gmsh.model.occ.synchronize()
    domain_tags = [1]
    outer_tags = [6,7,8,9]
    inner_tags = [5]
    gmsh.model.model.add_physical_group(dim,domain_tags,-1,&quot;domain&quot;)
    gmsh.model.model.add_physical_group(dim-1,outer_tags,-1,&quot;outer&quot;)
    gmsh.model.model.add_physical_group(dim-1,inner_tags,-1,&quot;inner&quot;)
    gmsh.option.set_number(&quot;Mesh.MeshSizeMax&quot;,mesh_size)
    gmsh.model.mesh.generate(dim)
    #Transform it to a mesh object
    GT.mesh_from_gmsh(gmsh)
end

#Visualize
fig = Makie.Figure()
ax,sc = GT.makie_surfaces(fig[1,1],mesh;axis,shading)
GT.makie_edges!(mesh;color=:black)
Makie.hidespines!(ax)
Makie.hidedecorations!(ax)</code></pre><p><img src="../fig_meshes_7.png" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../manual/introduction/">« Introduction</a><a class="docs-footer-nextpage" href="../manual_domains/">Domains »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 11 July 2025 15:49">Friday 11 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
