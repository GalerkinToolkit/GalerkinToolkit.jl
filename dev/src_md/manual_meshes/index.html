<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Meshes · GalerkinToolkit.jl</title><meta name="title" content="Meshes · GalerkinToolkit.jl"/><meta property="og:title" content="Meshes · GalerkinToolkit.jl"/><meta property="twitter:title" content="Meshes · GalerkinToolkit.jl"/><meta name="description" content="Documentation for GalerkinToolkit.jl."/><meta property="og:description" content="Documentation for GalerkinToolkit.jl."/><meta property="twitter:description" content="Documentation for GalerkinToolkit.jl."/><meta property="og:url" content="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/manual_meshes/"/><meta property="twitter:url" content="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/manual_meshes/"/><link rel="canonical" href="https://GalerkinToolkit.github.io/GalerkinToolkit.jl/src_md/manual_meshes/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GalerkinToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GalerkinToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/">Manual</a></li><li><a class="tocitem" href="../../manual/introduction/">Introduction</a></li><li><a class="tocitem" href="../manual_mesh_geometry/">Mesh geometry</a></li><li><a class="tocitem" href="../manual_mesh_topology/">Mesh topology</a></li><li><a class="tocitem" href="../manual_mesh_generation/">Mesh generation</a></li><li><a class="tocitem" href="../manual_mesh_partitioning/">Mesh partitioning</a></li><li><a class="tocitem" href="../../manual/for_developers/">For developers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../example_hello_world/">Hello, World!</a></li><li><a class="tocitem" href="../example_hello_world_dg/">Interior penalty</a></li><li><a class="tocitem" href="../example_hello_world_lm/">Lagrange multipliers</a></li><li><a class="tocitem" href="../example_poisson_equation/">Poisson equation</a></li><li><a class="tocitem" href="../example_p_laplacian/">p-Laplacian</a></li><li><a class="tocitem" href="../example_linear_elasticity/">Linear elasticity</a></li><li><a class="tocitem" href="../example_stokes/">Stokes lid-driven cavity</a></li><li><a class="tocitem" href="../example_transient_heat_eq/">Transient heat equation</a></li><li><a class="tocitem" href="../example_laplace_beltrami/">Laplace-Beltrami</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/">Tutorials</a></li><li><a class="tocitem" href="../tutorial_intro_to_fem/">Introduction to the FEM</a></li></ul></li><li><a class="tocitem" href="../../reference/">API</a></li><li><a class="tocitem" href="../../refindex/">Index</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Meshes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Meshes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GalerkinToolkit/GalerkinToolkit.jl/blob/main/docs/src/src_jl/manual_meshes.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Meshes"><a class="docs-heading-anchor" href="#Meshes">Meshes</a><a id="Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes" title="Permalink"></a></h1><p>A mesh object in GalerkinToolkit contains all geometrical information needed in a finite element (FE) computation. This includes the discretization of computational domains as well as data to impose different types of boundary conditions. It is worth noting that GalerkinToolkit is not a mesh generation library. The mesh API is designed to provide the rich geometrical information needed in FE methods, rather than mesh generation. Meshes are often generated with external tools and then transformed into GalerkinToolkit objects with helper functions such as <a href="../../reference/#GalerkinToolkit.mesh_from_gmsh-Tuple{Module}"><code>mesh_from_gmsh</code></a>.</p><h2 id="Definitions"><a class="docs-heading-anchor" href="#Definitions">Definitions</a><a id="Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Definitions" title="Permalink"></a></h2><h3 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h3><p><strong>Mesh and physical faces</strong>: A <em>mesh</em> <span>$M$</span> in GalerkinToolkit is formally defined as set of <em>physical faces</em> embedded in the Euclidean space <span>$\mathbb{R}^D$</span>, with <span>$D$</span> often being <span>$D=1,2,3$</span>.  A physical face <span>$F\in M$</span> is defined as the image <span>$\phi(\hat F)$</span> of a <em>reference face</em> <span>$\hat F$</span> via a map <span>$\phi: \mathbb{R}^d \rightarrow \mathbb{R}^D$</span>. The reference face <span>$\hat F$</span> associated with a physical face <span>$F\in M$</span> is denoted as <span>$\hat F :=\texttt{reference\_face}(F)$</span>.</p><p><strong>Number of dimensions, ambient dimensions and co-dimensions</strong>: The value <span>$D:=\texttt{num\_ambiend\_dims}(M)$</span> in the paragraph above is called the number of <em>ambient</em> dimensions of mesh <span>$M$</span>. We call <span>$d := \texttt{num\_dims}(F)$</span> the number of dimensions  of <span>$F$</span>. Note that the number of dimensions <span>$d$</span> and the number of ambient dimensions <span>$D$</span> might be different, namely <span>$d\leq D$</span>. The number of <em>co-dimensions</em> is the number of ambient dimensions minus the number of dimensions. In GalerkinToolkit, a mesh might contain faces of different number of dimensions. Thus, we define the number of dimensions of a mesh as the maximum number of dimensions of their faces, <span>$\texttt{num\_dims}(M) := \max_{F\in M} \texttt{num\_dims}(F)$</span>. Note however, that the number of ambient dimensions is the same for all physical faces in a mesh.</p><p><strong>Vertices, edges, surfaces, volumes, and <span>$d$</span>-faces</strong>:  We call <span>$d$</span>-face a face of <span>$d$</span> dimensions. We call <em>vertices</em>, <em>edges</em>, <em>surfaces</em>, and <em>volumes</em> to faces of 0, 1, 2, and 3 dimensions respectively.</p><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><p>We show a mesh, where the number of ambient dimensions is 3 and the number of dimensions is 2. This mesh contains vertices, edges, and surfaces. We shrink the mesh faces for visualization purposes. Otherwise faces of hider dimensions would hide faces of lower dimensions.</p><pre><code class="language-julia hljs">import GalerkinToolkit as GT
import GLMakie as Makie

cells = (4,40)
mesh = GT.moebius_strip(cells;width=0.6)
fig = Makie.Figure()
elevation = 0.24π
azimuth = -0.55π
aspect = :data
ax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)
shrink = 0.8
shading = Makie.NoShading
GT.makie_surfaces!(mesh;shrink,shading,dim=2)
GT.makie_edges!(mesh;shrink,dim=1)
GT.makie_vertices!(mesh;shrink,dim=0)</code></pre><p><img src="../fig_meshes_defs_1.png" alt/></p><p><strong>Chain</strong>: We call  <em>chain</em> to a mesh <span>$M$</span> that contains faces all of the same dimension. We denote with <span>$\texttt{chain}(M,d)\subset M$</span> the subset of <span>$M$</span> containing all <span>$d$</span>-faces of <span>$M$</span>.</p><p><strong>Reference face</strong>: A reference <span>$d$</span>-face <span>$\hat F$</span> is a <span>$d$</span>-dimensional <a href="https://en.wikipedia.org/wiki/Polytope">polytope</a> embedded in the Euclidian space <span>$\mathbb{R}^d$</span>. In particular, <span>$\hat F$</span> is a segment, polygon, and a polyhedron for <span>$d=1,2,3$</span> respectively. For <span>$d=0$</span>, we define a reference face <span>$\hat F:=\{v\}$</span> as a set containing the only point  <span>$v\in\mathbb{R}^0$</span>. For <span>$d&gt;0$</span>. We define the boundary <span>$\partial\hat F$</span> of a reference <span>$d$</span>-face <span>$\hat F$</span> as the union <span>$\partial\hat F := U_{f\in \hat M_{d-1}} \bar f$</span>, where <span>$\hat M_{d-1}$</span> is a set of faces of dimension <span>$(d-1)$</span> and <span>$\bar f$</span> is the <a href="https://en.wikipedia.org/wiki/Closure_(topology)">closure</a> of a face <span>$f\in \hat M_{d-1}$</span>. E.g., the boundary of a square is defined as the union of four segments and the boundary of a cube is defined as the union of four squares. Assuming that <span>$\partial\hat F$</span> is closed, we define the reference face <span>$\hat F$</span> as the open bounded subset of <span>$\mathbb{R}^d$</span> with boundary <span>$\partial\hat F$</span>. We denote with <span>$\texttt{chain}(\hat F,d-1)$</span> the set of faces <span>$\hat M_{d-1}$</span> defining the boundary of <span>$\hat F$</span>. Note that our definition of mesh has a recursive structure. A physical <span>$d$</span>-face is defined with a reference <span>$d$</span>-face, whose boundary is defined with a set of physical <span>$(d-1)$</span>-faces in embedded in space <span>$\mathbb{R}^d$</span>. Each <span>$(d-1)$</span>-face is defined with a reference <span>$(d-1)$</span>-face, whose boundary is defined with a set of physical <span>$(d-2)$</span>-faces embedded in <span>$\mathbb{R}^{d-1}$</span>. The recursion continues until one reaches reference <span>$0$</span>-faces, which are not defined by their boundary. For a reference face <span>$\hat F$</span>, the number of dimensions <span>$d$</span> coincides with the number of ambient dimensions, namely <span>$d=\texttt{num\_dims}(\hat F)=\texttt{num\_ambient\_dims}(\hat F)$</span>.</p><h4 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h4><p>We show the 3-faces of a mesh <span>$M$</span> (top, left). We also show the reference 3-face of this mesh and the 2-faces defining its boundary (top,right). Then, we repeat this for the reference 2-face (bottom,left), and for the reference 1-face (bottom,right).</p><pre><code class="language-julia hljs">import GalerkinToolkit as GT
import GLMakie as Makie

domain = (0,2,0,1,0,2)
cells = (4,2,4)
M = GT.cartesian_mesh(domain,cells)
V3ref = first(GT.reference_spaces(M,3))
M3ref = GT.mesh(V3ref)
V2ref = first(GT.reference_spaces(M3ref,2))
M2ref = GT.mesh(V2ref)
V1ref = first(GT.reference_spaces(M2ref,1))
M1ref = GT.mesh(V1ref)
fig = Makie.Figure()
aspect = :data
ax = Makie.Axis3(fig[1,1];aspect)
Makie.hidespines!(ax)
Makie.hidedecorations!(ax)
shrink = 0.8
GT.makie_surfaces!(ax,M;dim=3,shrink)
ax = Makie.Axis3(fig[1,2];aspect)
Makie.hidespines!(ax)
Makie.hidedecorations!(ax)
GT.makie_surfaces!(ax,M3ref;dim=3,shrink)
GT.makie_surfaces!(ax,M3ref;dim=2,shrink)
aspect = Makie.DataAspect()
axis = (;aspect)
ax, = GT.makie_surfaces(fig[1,3],M2ref;dim=2,shrink,axis)
Makie.hidespines!(ax)
Makie.hidedecorations!(ax)
GT.makie_edges!(M2ref;dim=1,shrink)
ax = Makie.Axis(fig[1,4])
Makie.hidespines!(ax)
Makie.hidedecorations!(ax)
GT.makie_edges!(ax,M1ref;dim=1,shrink)
GT.makie_vertices!(ax,M1ref;dim=0,shrink)</code></pre><p><img src="../fig_meshes_defs_2.png" alt/></p><p><strong>Physical map</strong>: The map <span>$\phi$</span> that transforms a reference face <span>$\hat F$</span> into a physical one <span>$F$</span> is called the <em>physical map</em>. It is defined by means of a scalar-valued Lagrangian interpolation space <span>$\hat V$</span> defined on the reference face <span>$\hat F$</span>, which we denote as <span>$\hat V := \texttt{reference\_space}(F)$</span>. The vector of <em>shape functions</em> and <em>node coordinates</em> of space <span>$\hat V$</span> are denoted as <span>$\texttt{shape\_functions}(\hat V)$</span> and <span>$\texttt{node\_coordinates}(\hat V)$</span> respectively. The length of these vectors is <span>$\texttt{num\_nodes}(\hat V)$</span>. See the <a href="../manual_interpolation/#Interpolation">Interpolation</a> section for the formal definition of the Lagrangian spaces, as well for the shape functions and node coordinates. The physical map <span>$\phi$</span> for physical face <span>$F$</span> is then defined using a vector of physical node coordinates, namely <span>$\texttt{node\_coordinates}(F)$</span>. These physical node coordinates are the prescribed images of the reference node coordinates in <span>$\texttt{node\_coordinates}(\hat V)$</span>. The physical map is defined as follows:</p><p class="math-container">\[\phi(\hat x) := \sum_{n=1}^{N} x^F_n s^{\hat V}_n(\hat x),\]</p><p>with <span>$x^F_n := [\texttt{node\_coordinates}(F)]_n$</span> being the coordinate vector of node <span>$n$</span> in face <span>$F$</span>, <span>$s^{\hat V}_n := [\texttt{shape\_functions}(\hat V)]_n$</span> the shape function of node <span>$n$</span> in space <span>$\hat V$</span>, and <span>$N:=\texttt{num\_nodes}(\hat V)$</span>. The notation <span>$[a]_i$</span> denotes the <span>$i$</span>-th element of vector <span>$a$</span>.</p><h3 id="Integer-identifiers-(ids)"><a class="docs-heading-anchor" href="#Integer-identifiers-(ids)">Integer identifiers (ids)</a><a id="Integer-identifiers-(ids)-1"></a><a class="docs-heading-anchor-permalink" href="#Integer-identifiers-(ids)" title="Permalink"></a></h3><p><strong>Face ids</strong>: For a given <span>$d$</span>, let <span>$\texttt{num\_faces}(M,d)$</span> be the number of faces of dimension <span>$d$</span> in a mesh <span>$M$</span>. We assign a unique integer in <span>$\texttt{faces}(M,d):=\{1,\ldots,\texttt{num\_faces}(M,d)\}$</span> to each <span>$d$</span>-face in <span>$M$</span>. The integer <span>$\texttt{id}(F)$</span> assigned to a <span>$d$</span>-face <span>$F\in M$</span> is called the <em>face id</em> of <span>$F$</span>. Note that face ids are assigned per dimension (two faces of different dimension might have the same id). A face is uniquely identified by its face id <span>$\texttt{id}(F)$</span> <em>and</em> its dimension <span>$\texttt{num\_dims}(F)$</span>. The face ids are arbitrary as long as they are consecutive integers starting by one.</p><p><strong>Node ids</strong>: The <em>face-local</em> id of a node in face <span>$F$</span> is defined as the position of the coordinate of this node  in the vector <span>$\texttt{node\_coordinates}(F)$</span>.  That is, the node with face-local id <span>$n$</span> in face <span>$F$</span> has coordinates <span>$[\texttt{node\_coordinates}(F)]_n$</span>.  These coordinates are defined my means of a vector of node coordinates <span>$\texttt{node\_coordinates}(M)$</span> for the entire mesh <span>$M$</span>  and a vector of integers <span>$\texttt{nodes}(F)$</span> for face <span>$F\in M$</span>, namely  <span>$[\texttt{node\_coordinates}(F)]_n := [\texttt{node\_coordinates}(M)]_m$</span> with  <span>$m=[\texttt{nodes}(F)]_n$</span>.  The <em>global</em> id of a node in mesh <span>$M$</span> is the position of the coordinate of this node in vector <span>$\texttt{node\_coordinates}(M)$</span>. The  vector <span>$\texttt{nodes}(F)$</span> contains the global ids for the nodes in this face, and is indexed by face-local node ids. This is often called  the <em>local-to-global</em> (index) map of face <span>$F$</span> or the <em>connectivity</em> of face <span>$F$</span>. We call them the global node ids (or simply the nodes) of face <span>$F$</span>  since there several types of local-to-global integer maps in GalerkinToolkit.  For a given <span>$d$</span>, we collect the node ids of all <span>$d$</span>-faces in a mesh <span>$M$</span> in a vector called <span>$\texttt{face\_nodes}(M,d)$</span> such that  <span>$[\texttt{face\_nodes}(M,d)]_i = \texttt{nodes}(F)$</span> for a <span>$d$</span>-face <span>$F\in M$</span> with <span>$i=\texttt{id}(F)$</span>.  In addition, we define the global node ids of mesh <span>$M$</span> as  <span>$\texttt{nodes}(M):=\{1,\ldots,\texttt{num\_nodes}(M)\}$</span> with <span>$\texttt{num\_nodes}(M)$</span> being the number of nodes in mesh <span>$M$</span>. i.e., the length  of the vector <span>$\texttt{node\_coordinates}(M)$</span>.</p><p><strong>Reference ids</strong>:  For a given <span>$d$</span>, let us consider a vector (or a tuple) <span>$\texttt{reference\_spaces}(M,d)$</span>  containing all the unique reference space for the <span>$d$</span>-faces of a mesh <span>$M$</span>. The <em>reference</em> id   of a <span>$d$</span>-face <span>$F\in M$</span>, namely <span>$\texttt{reference\_id}(F)$</span>, is defined as the integer <span>$r$</span> such that  <span>$\texttt{reference\_space}(F) = [\texttt{reference\_spaces}(M,d)]_r$</span>. That is,  <span>$r$</span> is the position of the reference space of face <span>$F$</span> in <span>$\texttt{reference\_spaces}(M,d)$</span>.  The reference ids of all <span>$d$</span>-faces are collected in vector <span>$\texttt{face\_reference\_id}(M,d)$</span>,  such that <span>$[\texttt{face\_reference\_id}(M,d)]_i := \texttt{reference\_id}(F)$</span> for a <span>$d$</span>-face  <span>$F\in M$</span>  with <span>$i=\texttt{id}(F)$</span>.  The notion of reference id is introduced since different face  typologies such as simplixes and hyper-cubes might be contained in the same mesh object.  Note also that often all <span>$d$</span>-faces are topologically equivalent. In this case, there is only one reference  space for all <span>$d$</span>-faces and their reference id is one.</p><h3 id="Mesh-meta-data"><a class="docs-heading-anchor" href="#Mesh-meta-data">Mesh meta-data</a><a id="Mesh-meta-data-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-meta-data" title="Permalink"></a></h3><p><strong>Face groups</strong>: For a given <span>$d$</span>, we call a <em>face group</em> to a subset <span>$G\subset \texttt{faces}(M,d)$</span> of the face ids of dimension <span>$d$</span>. A mesh is typically endowed with several of these groups to identify particular faces of the mesh for modeling purposes, e.g., to impose boundary conditions, or define position-dependent material properties. Each group is given a <em>group name</em>, which identifies the group. We call <span>$\texttt{group\_names}(M,d)$</span> the set of group names available in mesh <span>$M$</span> for faces of dimension <span>$d$</span>. We call <span>$\texttt{group\_faces}(M,d)$</span> to an associative collection (a Julia <code>Dict</code> in practice), that maps group names to the corresponding subset of face ids <span>$G\subset \texttt{faces}(M,d)$</span>. That is <span>$[\texttt{group\_faces}(M,d)]_n$</span> is the set of face ids in the group with name <span>$n\in\texttt{group\_names}(M,d)$</span>. Here, <span>$[a]_n$</span> denotes the value of the associative collection <span>$a$</span> at key <span>$n$</span>. Face groups are defined per dimension and it is accepted to have the same group name in two or more dimensions. That is, <span>$\texttt{group\_names}(M,d_1)\cap\texttt{group\_names}(M,d_2)$</span> might be non-empty for two dimensions <span>$d_1\neq d_2$</span>. It is also possible to add new groups to the collection, <span>$[\texttt{group\_faces}(M,d)]_n := G$</span>, as long as the group name <span>$n$</span> is not already an existing key.</p><h2 id="The-AbstractMesh-interface"><a class="docs-heading-anchor" href="#The-AbstractMesh-interface">The AbstractMesh interface</a><a id="The-AbstractMesh-interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-AbstractMesh-interface" title="Permalink"></a></h2><p>A mesh <span>$M$</span> as defined above is represented in GalerkinToolkit with a mesh object <code>M</code>, whose type is a subtype of <a href="../../reference/#GalerkinToolkit.AbstractMesh"><code>AbstractMesh</code></a>.</p><h3 id="Core-API"><a class="docs-heading-anchor" href="#Core-API">Core API</a><a id="Core-API-1"></a><a class="docs-heading-anchor-permalink" href="#Core-API" title="Permalink"></a></h3><p>The core API for mesh objects <code>M::AbstractMesh</code> is given below. The definition of these functions is analogous as the definition of the mathematical functions above.</p><ul><li><a href="../../reference/#GalerkinToolkit.num_dims"><code>num_dims(M)</code></a></li><li><a href="../../reference/#GalerkinToolkit.num_ambient_dims"><code>num_ambient_dims(M)</code></a></li><li><a href="../../reference/#GalerkinToolkit.num_codims"><code>num_codims(M)</code></a></li><li><a href="../../reference/#GalerkinToolkit.num_nodes"><code>num_nodes(M)</code></a></li><li><a href="../../reference/#GalerkinToolkit.nodes"><code>nodes(M)</code></a></li><li><a href="../../reference/#GalerkinToolkit.node_coordinates"><code>node_coordinates(M)</code></a></li><li><a href="../../reference/#GalerkinToolkit.faces"><code>faces(M,d)</code></a></li><li><a href="../../reference/#GalerkinToolkit.num_faces"><code>num_faces(M,d)</code></a></li><li><a href="../../reference/#GalerkinToolkit.face_nodes"><code>face_nodes(M,d)</code></a></li><li><a href="../../reference/#GalerkinToolkit.face_reference_id"><code>face_reference_id(M,d)</code></a></li><li><a href="../../reference/#GalerkinToolkit.reference_spaces"><code>reference_spaces(M,d)</code></a></li><li><a href="../../reference/#GalerkinToolkit.group_faces"><code>group_faces(M,d)</code></a></li><li><a href="../../reference/#GalerkinToolkit.group_names"><code>group_names(M,d)</code></a></li><li><a href="../../reference/#GalerkinToolkit.normals"><code>normals(M)</code></a></li></ul><h3 id="Face-iteration"><a class="docs-heading-anchor" href="#Face-iteration">Face iteration</a><a id="Face-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Face-iteration" title="Permalink"></a></h3><p>Given <code>M::AbstractMesh</code>, function <code>GT.each_face(M,d)</code> creates an iterator object used to traverse all <code>d</code>-faces in mesh <code>M</code>. Using this iterator, face objects can be accessed with the Julia loop syntax.</p><pre><code class="language-julia hljs">for F in GT.each_face(M,d)
   # Use F
end</code></pre><p>Variable <code>F</code> represents a <code>d</code>-face in mesh <code>M</code>. One case use the following API on the <code>F</code> object. Most these functions coincide with the mathematical functions presented above. Otherwise, their definition can be found in the corresponding doc-strings.</p><ul><li><a href="../../reference/#GalerkinToolkit.num_dims"><code>num_dims(F)</code></a></li><li><a href="../../reference/#GalerkinToolkit.num_ambient_dims"><code>num_ambient_dims(F)</code></a></li><li><a href="../../reference/#GalerkinToolkit.num_codims"><code>num_codims(F)</code></a></li><li><a href="../../reference/#GalerkinToolkit.nodes"><code>nodes(F)</code></a></li><li><a href="../../reference/#GalerkinToolkit.num_nodes"><code>num_nodes(F)</code></a></li><li><a href="../../reference/#GalerkinToolkit.node_coordinates"><code>node_coordinates(F)</code></a></li><li><a href="../../reference/#GalerkinToolkit.diameter-Tuple{GalerkinToolkit.MeshFace}"><code>diameter(F)</code></a></li><li><code>id(F)</code></li><li><code>reference_id(F)</code></li><li><code>reference_face(F)</code></li><li><code>reference_space(F)</code></li></ul><h3 id="Specializing-AbstractMesh"><a class="docs-heading-anchor" href="#Specializing-AbstractMesh">Specializing AbstractMesh</a><a id="Specializing-AbstractMesh-1"></a><a class="docs-heading-anchor-permalink" href="#Specializing-AbstractMesh" title="Permalink"></a></h3><p>A type that specializes <code>AbstractMesh</code> needs to implement the following methods for an instance <code>M</code> of the new type. The entire <code>AbstractMesh</code> API can be then used in instances of these types.</p><ul><li><a href="../../reference/#GalerkinToolkit.node_coordinates"><code>node_coordinates(M)</code></a></li><li><a href="../../reference/#GalerkinToolkit.face_nodes"><code>face_nodes(M)</code></a></li><li><a href="../../reference/#GalerkinToolkit.face_reference_id"><code>face_reference_id(M)</code></a></li><li><a href="../../reference/#GalerkinToolkit.reference_spaces"><code>reference_spaces(M)</code></a></li><li><a href="../../reference/#GalerkinToolkit.group_faces"><code>group_faces(M)</code></a></li><li><a href="../../reference/#GalerkinToolkit.normals"><code>normals(M)</code></a></li></ul><h2 id="The-Mesh-type"><a class="docs-heading-anchor" href="#The-Mesh-type">The Mesh type</a><a id="The-Mesh-type-1"></a><a class="docs-heading-anchor-permalink" href="#The-Mesh-type" title="Permalink"></a></h2><p>The default specialization of <code>AbstractMesh</code> is the type <a href="../../reference/#GalerkinToolkit.Mesh"><code>Mesh</code></a>. It is a data structure able to hold general unstructured meshes.</p><h3 id="Creating-a-general-mesh"><a class="docs-heading-anchor" href="#Creating-a-general-mesh">Creating a general mesh</a><a id="Creating-a-general-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-general-mesh" title="Permalink"></a></h3><p>The general way of creating an instance of the type <code>Mesh</code> is with function <a href="../../reference/#GalerkinToolkit.create_mesh"><code>create_mesh</code></a>. This is the lowest-level way of creating a mesh. Other more user-friendly ways of building a mesh are discussed in the Mesh generation section.</p><h4 id="Example-3"><a class="docs-heading-anchor" href="#Example-3">Example</a><a class="docs-heading-anchor-permalink" href="#Example-3" title="Permalink"></a></h4><p>In the following example, we generate and visualize a mesh of three first order triangles. Only faces of dimension 2 are present in this example. The arrays for vertices and edges are empty.</p><pre><code class="language-julia hljs">#Import dependencies
import GalerkinToolkit as GT
import GLMakie as Makie
import StaticArrays

#Node coordinates
T = StaticArrays.SVector{2,Float64}
node_coordinates = T[(0,0),(1,0),(0,1),(1,1),(2,0)]

#Face nodes
face_nodes_0 = Vector{Int}[]
face_nodes_1 = Vector{Int}[]
face_nodes_2 = [[1,2,3],[2,3,4],[2,4,5]]
face_nodes = [
    face_nodes_0,
    face_nodes_1,
    face_nodes_2]

#Reference spaces
reference_spaces_0 = ()
reference_spaces_1 = ()
order = 1
triangle = GT.unit_simplex(Val(2))
triangle3 = GT.lagrange_space(triangle,order)
reference_spaces_2 = (triangle3,)
reference_spaces = (
    reference_spaces_0,
    reference_spaces_1,
    reference_spaces_2)

#Create mesh
mesh = GT.create_mesh(;
    node_coordinates,
    face_nodes,
    reference_spaces)

#Visualize
axis = (;aspect=Makie.DataAspect())
shading = Makie.NoShading
GT.makie_surfaces(mesh;axis,shading)
GT.makie_edges!(mesh;color=:black)</code></pre><p><img src="../fig_meshes_1.png" alt/></p><h4 id="Example-4"><a class="docs-heading-anchor" href="#Example-4">Example</a><a class="docs-heading-anchor-permalink" href="#Example-4" title="Permalink"></a></h4><p>In this other slightly more complex example, we define a mesh including faces of different dimensions: surfaces, edges and vertices. To be able to see all faces in the visualization, we need to &quot;shrink&quot; them. Otherwise, the surfaces would hide the edges and vertices.</p><pre><code class="language-julia hljs">#Import dependencies
import GalerkinToolkit as GT
import GLMakie as Makie
import StaticArrays

#Node coordinates
T = StaticArrays.SVector{2,Float64}
node_coordinates = T[(0,0),(1,0),(0,1),(1,1),(2,0)]

#Face nodes
face_nodes_0 = [[1],[3]]
face_nodes_1 = [[1,2],[2,5],[5,4]]
face_nodes_2 = [[1,2,3],[2,3,4],[2,4,5]]
face_nodes = [
    face_nodes_0,
    face_nodes_1,
    face_nodes_2]

#Reference spaces
order = 1
vertex = GT.unit_simplex(Val(0))
vertex1 = GT.lagrange_space(vertex,order)
segment = GT.unit_simplex(Val(1))
segment2 = GT.lagrange_space(segment,order)
triangle = GT.unit_simplex(Val(2))
triangle3 = GT.lagrange_space(triangle,order)
reference_spaces_0 = (vertex1,)
reference_spaces_1 = (segment2,)
reference_spaces_2 = (triangle3,)
reference_spaces = (
    reference_spaces_0,
    reference_spaces_1,
    reference_spaces_2)

#Create mesh
mesh = GT.create_mesh(;
    node_coordinates,
    face_nodes,
    reference_spaces)

#Visualize
axis = (;aspect=Makie.DataAspect())
shrink = 0.8
shading = Makie.NoShading
GT.makie_surfaces(mesh;axis,shading,shrink)
GT.makie_edges!(mesh;dim=1,shrink)
GT.makie_vertices!(mesh;dim=0)</code></pre><p><img src="../fig_meshes_2.png" alt/></p><h3 id="Creating-a-general-chain"><a class="docs-heading-anchor" href="#Creating-a-general-chain">Creating a general chain</a><a id="Creating-a-general-chain-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-general-chain" title="Permalink"></a></h3><p>Using function <a href="../../reference/#GalerkinToolkit.create_mesh"><code>create_mesh</code></a> might be tedious if all faces are of the same dimension. In this case, we can use the slightly simpler constructor <a href="../../reference/#GalerkinToolkit.create_chain-Tuple{}"><code>create_chain</code></a>. It works like <a href="../../reference/#GalerkinToolkit.create_mesh"><code>create_mesh</code></a>, but we pass data only for one face dimension.</p><h4 id="Example-5"><a class="docs-heading-anchor" href="#Example-5">Example</a><a class="docs-heading-anchor-permalink" href="#Example-5" title="Permalink"></a></h4><p>We create the mesh of the first example, but using <a href="../../reference/#GalerkinToolkit.create_chain-Tuple{}"><code>create_chain</code></a>.</p><pre><code class="language-julia hljs">#Import dependencies
import GalerkinToolkit as GT
import GLMakie as Makie
import StaticArrays

#Node coordinates
T = StaticArrays.SVector{2,Float64}
node_coordinates = T[(0,0),(1,0),(0,1),(1,1),(2,0)]

#Face nodes
face_nodes = [[1,2,3],[2,3,4],[2,4,5]]

#Reference spaces
order = 1
triangle = GT.unit_simplex(Val(2))
triangle3 = GT.lagrange_space(triangle,order)
reference_spaces = (triangle3,)

#Create mesh
chain = GT.create_chain(;
    node_coordinates,
    face_nodes,
    reference_spaces)

#Visualize
axis = (;aspect=Makie.DataAspect())
shading = Makie.NoShading
GT.makie_surfaces(chain;axis,shading)
GT.makie_edges!(chain;color=:black)</code></pre><p><img src="../fig_meshes_1a.png" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Wednesday 19 November 2025 21:34">Wednesday 19 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
