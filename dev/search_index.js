var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"C. Johnson. Numerical Solution of Partial Differential Equations by the Finite Element Method (Dover Publications, 2009).\n\n\n\nJ. Whiteley. Finite Element Methods, A Practical Guide (Springer, 2017).\n\n\n\nS. C. Brenner and R. Scott. The mathematical theory of finite element methods. 3 Edition, Texts in applied mathematics (Springer, New York, NY, 2007).\n\n\n\nD. N. Arnold, F. Brezzi, B. Cockburn and L. D. Marini. Unified analysis of discontinuous Galerkin methods for elliptic problems. SIAM J. Numer. Anal. 39, 1749–1779 (2002).\n\n\n\n","category":"page"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Introduction to the FEM","category":"page"},{"location":"src_md/example_p_laplacian/#p-Laplacian","page":"p-Laplacian","title":"p-Laplacian","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/#Problem-statement","page":"p-Laplacian","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Find the scalar-field u such that","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"leftlbrace\nbeginaligned\n-nabla cdot sigma(u) = f textin Omega\nu = -1  texton  Gamma_0\nu = 1  texton  Gamma_1\nsigma(u)cdot n = 0  textelsewhere on  partialOmega\nendaligned\nright","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"with sigma(u) = nabla u^p-2  nabla u and p2. The vector field n is the outwards unit normal vector to partialOmega. The computational domains are defined in the mesh file model.msh. The domain Omega is represented by the 3D faces in this mesh. The domain Gamma_0 is represented by the physical group named \"sides\" and Gamma_1 is the union of the physical groups named \"circle\", \"triangle\", and \"square\".","category":"page"},{"location":"src_md/example_p_laplacian/#Numerical-scheme","page":"p-Laplacian","title":"Numerical scheme","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"We discretize the problem with a space V with piece-wise continuous Lagrangian basis functions. For this formulation, the nonlinear weak form reads: find uin V_g such that r(u)(v) = 0 for all vin V_0. The auxiliary spaces V_g and V_0 are the subsets of V that fulfill the Dirichlet boundary condition g and 0 on partialOmega respectively.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"The weak residual r(u) evaluated at a function  uin V_g is the linear form defined as","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"r(u)(v) doteq int_Omega nabla v cdot left( nabla u^p-2 nabla u right)  rm dOmega - int_Omega v f  rm dOmega","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"In order to solve this nonlinear weak equation, we consider a Newton-Raphson method, which is associated with a linearization of the problem in an arbitrary direction delta uin V_0, namely r(u+delta u)(v)approx r(u)(v) + j(u)(delta uv). In previous formula,  j(u) is the Jacobian evaluated at uin V_g, which is the bilinear form","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"j(u)(delta uv) = int_Omega nabla v cdot left( nabla u^p-2 nabla delta u right)  rm dOmega + (p-2) int_Omega nabla v cdot left(  nabla u^p-4 (nabla u cdot nabla delta u) nabla u  right)  rm dOmega","category":"page"},{"location":"src_md/example_p_laplacian/#Implementation","page":"p-Laplacian","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"import FileIO # hide\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport NonlinearSolve\nimport ForwardDiff\nimport GLMakie as Makie\n\n#Read and visualize the mesh\nassets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"model.msh\")\nmesh = GT.mesh_from_msh(msh_file)\n\n#Define domains\ndirichlet_names = [\"sides\",\"circle\", \"triangle\", \"square\"]\nΩ = GT.interior(mesh)\nΓd = GT.boundary(mesh;group_names=dirichlet_names)\n\n#Define forcing data\ng = GT.analytical_field(Γd;piecewise=true) do x,name\n    if name == \"sides\"\n        -1\n    else\n        1\n    end\nend\n\n#Define the interpolation space\nk = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n\n#Interpolate Dirichlet values\nT = Float64\nuh = GT.rand_field(T,V)\nGT.interpolate_dirichlet!(g,uh)\n\n#Define numerical integration\ndegree = 2*k\ndΩ = GT.measure(Ω,degree)\n\n#Define weak form.\n∇ = ForwardDiff.gradient\nq = 3\nflux(∇u) = norm(∇u)^(q-2) * ∇u\ndflux(∇du,∇u) = (q-2)*norm(∇u)^(q-4)*(∇u⋅∇du)*∇u+norm(∇u)^(q-2)*∇du\nr = u -> v -> GT.∫( x-> ∇(v,x)⋅GT.call(flux,∇(u,x)), dΩ)\nj = u -> (du,v) -> GT.∫( x-> ∇(v,x)⋅GT.call(dflux,∇(du,x),∇(u,x)) , dΩ)\n\n#Define non-linear problem\np = GT.SciMLBase_NonlinearProblem(uh,r,j)\n\n#Solve it\nsol = NonlinearSolve.solve(p;show_trace=Val(true))\n@assert sol.retcode == NonlinearSolve.ReturnCode.Success\n\n#Get the FE solution object\nuh = GT.solution_field(uh,sol)\n\n#Visualize the solution\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Ω;color=uh)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_1.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/#Building-the-algebraic-non-linear-problem-explicitly","page":"p-Laplacian","title":"Building the algebraic non-linear problem explicitly","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"In this other version, we explicitly build the algebraic residual and Jacobian (functions that take plain Julia vectors) and build a algebraic non-linear problem from them.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"import SciMLBase\n\n#Initial guess\nx = rand(T,GT.num_free_dofs(V))\nGT.solution_field!(uh,x)\n\n#Initial residual and Jacobian\nreuse = Val(true)\nparameters = (uh,)\nb,residual_cache = GT.assemble_vector(r(uh),T,V;parameters,reuse)\nA,jacobian_cache = GT.assemble_matrix(j(uh),T,V,V;parameters,reuse)\n\n#Algebraic residual and Jacobian functions\nfunction f(dx,x,p)\n    GT.solution_field!(uh,x)\n    GT.update_vector!(dx,residual_cache;parameters)\n    dx\nend\n\nfunction jac(J,x,p)\n    GT.solution_field!(uh,x)\n    GT.update_matrix!(J,jacobian_cache;parameters)\n    J\nend\n\n#Build the nonlinear problem\njac_prototype = A\nnlfun = SciMLBase.NonlinearFunction(f;jac,jac_prototype)\np = SciMLBase.NonlinearProblem(nlfun,x)\n\n#Solve it\nsol = NonlinearSolve.solve(p;show_trace=Val(true))\n@assert sol.retcode == NonlinearSolve.ReturnCode.Success\n\n#Get the FE solution object\nx = sol.u\nGT.solution_field!(uh,x)\n\n#Visualize the solution\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Ω;color=uh)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_2.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_hello_world/#Hello,-World!","page":"Hello, World!","title":"Hello, World!","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world/#Problem-statement","page":"Hello, World!","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"In this example, we show how to solve the \"Hello, world\" PDE example: the Laplace equation on the unit hyper-cube Omega  =01^d, d=3, with Dirichlet boundary conditions.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"with f=0 and g(x)=textsum(x). In this case, we know that the solution is u=g which allows us to check that we solve the problem correctly, by integration an error norm.","category":"page"},{"location":"src_md/example_hello_world/#Numerical-scheme","page":"Hello, World!","title":"Numerical scheme","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"We use a conventional Galerkin finite element (FE) method with conforming Lagrangian FE spaces (see, e.g., [1]).  The weak form equation we solve consists in finding u_hin V_g such that a(u_hv) = ell(v) for all vin V_0. To this end we build a space V spanned by continuous and piece-wise Lagrangian basis functions. The auxiliary spaces V_g and V_0 are the subsets of V that fulfill the Dirichlet boundary condition g and 0 on partialOmega respectively. The bilinear and linear forms are","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"  a(uv) doteq int_Omega nabla v cdot nabla u  rm dOmega quad b(v) doteq int_Omega v f   rm  dOmega","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"This equation results in a system of linear algebraic equations that is solved using an external linear solver from LinearSolve.jl.","category":"page"},{"location":"src_md/example_hello_world/#Implementation","page":"Hello, World!","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"import FileIO # hide\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport LinearSolve\n\n#Geometry\ndomain = (0,1,0,1,0,1)\ncells = (10,10,10)\nmesh = GT.cartesian_mesh(domain,cells)\nΩ = GT.interior(mesh)\nΓd = GT.boundary(mesh)\n\n#Functions\n∇ = ForwardDiff.gradient\ng = GT.analytical_field(sum,Ω)\nf = GT.analytical_field(x->0,Ω)\n\n#Interpolation\nk = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\nT = Float64\nuhd = GT.zero_dirichlet_field(T,V)\nGT.interpolate_dirichlet!(g,uhd)\n\n#Weak form\ndegree = 2*k\ndΩ = GT.measure(Ω,degree)\na = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\nl = v -> GT.∫( x->v(x)*f(x), dΩ)\n\n#Linear problem\np = GT.SciMLBase_LinearProblem(uhd,a,l)\nsol = LinearSolve.solve(p)\nuh = GT.solution_field(uhd,sol)\n\n#Error check\neh = x -> uh(x) - g(x)\nel2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt\n@assert el2 < 1.0e-9\n\n#Visualization\nfig = Makie.Figure()\nax = Makie.Axis3(fig[1,1],aspect=:data)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Ω;color=uh)\nFileIO.save(joinpath(@__DIR__,\"fig_hello_world_1.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/#Explicit-integration-loops","page":"Hello, World!","title":"Explicit integration loops","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"This other code version implements the integration loops manually instead of relying on the underlying automatic code generation.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"#Manually written matrix assembly function\n#Always use a function, never the global scope\nfunction assemble_matrix!(A_alloc,Ad_alloc,V,dΩ)\n\n    ∇ = ForwardDiff.gradient\n\n    #Iterators to the quantities on the\n    #integration points\n    V_faces = GT.each_face(V,dΩ;tabulate=(∇,))\n\n    #Temporaries\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n\n    #Numerical integration loop\n    for V_face in V_faces\n\n        #Get quantities at current face\n        dofs = GT.dofs(V_face)\n\n        #Reset face matrix\n        fill!(Auu,zero(T))\n\n        #Loop over integration points\n        for V_point in GT.each_point(V_face)\n\n            #Get quantities at current integration point\n            dV = GT.weight(V_point)\n            dof_∇s = GT.shape_functions(∇,V_point)\n\n            #Fill in face matrix\n            for (i,dofi) in enumerate(dofs)\n                ∇v = dof_∇s[i]\n                for (j,dofj) in enumerate(dofs)\n                    ∇u = dof_∇s[j]\n                    Auu[i,j] += ∇v⋅∇u*dV\n                end\n            end\n        end\n\n        #Add face contribution to the\n        #global allocations\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n        GT.contribute!(Ad_alloc,Auu,dofs,dofs)\n    end\nend\n\n#Manually written integration of the error\n#Always use a function, never the global scope\nfunction integrate_l2_error(g,uh,dΩ)\n\n    #Iterators to the quantities on the\n    #integration points\n    tabulate = (GT.value,)\n    compute = (GT.coordinate,)\n    uh_faces = GT.each_face(uh,dΩ;tabulate,compute)\n\n    #Numerical integration loop\n    s = 0.0\n    for uh_face in uh_faces\n        for uh_point in GT.each_point(uh_face)\n\n            #Get quantities at current integration point\n            x = GT.coordinate(uh_point)\n            dV = GT.weight(uh_point)\n            uhx = GT.field(GT.value,uh_point)\n\n            #Add contribution\n            s += abs2(uhx-g.definition(x))*dV\n        end\n    end\n\n    #Compute the l2 norm\n    el2 = sqrt(s)\nend\n\n#Allocate matrix for free columns\nA_alloc = GT.allocate_matrix(T,V,V,Ω)\n\n#Allocate matrix for dirichlet columns\nfree_or_dirichlet=(GT.FREE,GT.DIRICHLET)\nAd_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet)\n\n#Fill allocations with the function we wrote above\nassemble_matrix!(A_alloc,Ad_alloc,V,dΩ)\n\n#Compress matrix into the final format\nA = GT.compress(A_alloc)\nAd = GT.compress(Ad_alloc)\n\n#Build the linear system\nxd = GT.dirichlet_values(uhd)\nb = -Ad*xd\np = LinearSolve.LinearProblem(A,b)\n\n#Solve the problem\nsol = LinearSolve.solve(p)\nuh = GT.solution_field(uhd,sol)\n\n#Integrate the error l2 norm\n#with the function we wrote above\nel2 = integrate_l2_error(g,uh,dΩ)\n@assert el2 < 1.0e-9\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/manual_mesh_partitioning/#Mesh-partitioning","page":"Mesh partitioning","title":"Mesh partitioning","text":"","category":"section"},{"location":"src_md/manual_mesh_partitioning/","page":"Mesh partitioning","title":"Mesh partitioning","text":"One can partition mesh objects and distribute them over different process for computations on large-scale parallel systems. PartitionedArrays.jl is used under-the-hood to distribute the vectors defining the mesh object. This allows one to use several backends including MPI (by default), and the debug-backend of PartitionedArrays for developing and debugging purposes.","category":"page"},{"location":"src_md/manual_mesh_partitioning/#Data-partition-model","page":"Mesh partitioning","title":"Data partition model","text":"","category":"section"},{"location":"src_md/manual_mesh_partitioning/","page":"Mesh partitioning","title":"Mesh partitioning","text":"A partitioned mesh is made of the same vectors as a sequential mesh, except for the fact that these vectors are of type PVector, the type representing a distributed vector in PartitionedArrays. Thus, one can work with a partitioned mesh as with a sequential mesh, as long as you don't index the PVector objects directly (which is intentionally forbidden by PartitionedArrays for performance reasons). The usage of partitioned meshes is transparent to the user in most of the cases, as one rarely works with the underlying data directly. Functions that you call on a partitioned mesh and access the underlying mesh data, are dispatched to parallel implementations that carefully access the partitioned data. In particular, types that build on top of a partitioned mesh also distribute data using PVector objects. The same usage remarks apply to them.","category":"page"},{"location":"src_md/manual_mesh_partitioning/","page":"Mesh partitioning","title":"Mesh partitioning","text":"The mesh data in a mesh object is partitioned as follows:","category":"page"},{"location":"src_md/manual_mesh_partitioning/","page":"Mesh partitioning","title":"Mesh partitioning","text":"GT.node_coordinates(mesh) is a PVector distributed over nodes containing node coordinates.\nGT.face_nodes(mesh,d) is a PVector distributed over d-faces of containing global node ids.\nGT.reference_spaces(mesh,d) is typically a small tuple which is replicated across all processes.\nGT.face_reference_id(mesh,d) is a PVector distributed over d-faces  containing global reference indices.\nGT.group_faces(mesh,d) is a Dict{String,PVector} object whose keys are replicated on all processes. GT.group_faces(mesh,d)[key] is a PVector distributed over the faces in this group containing global face ids.\nOther vectors like normals(mesh) are distributed following the same principle.","category":"page"},{"location":"src_md/manual_mesh_partitioning/","page":"Mesh partitioning","title":"Mesh partitioning","text":"All these PVector objects only include own indices and point to global indices.  This allows us to distribute node and face data in an arbitrary way.","category":"page"},{"location":"src_md/manual_mesh_partitioning/#Creating-partitioned-meshes","page":"Mesh partitioning","title":"Creating partitioned meshes","text":"","category":"section"},{"location":"src_md/manual_mesh_partitioning/","page":"Mesh partitioning","title":"Mesh partitioning","text":"A partitioned mesh can be created with function with_mesh_partitioner.","category":"page"},{"location":"src_md/manual_mesh_partitioning/#GalerkinToolkit.with_mesh_partitioner-src_md-manual_mesh_partitioning","page":"Mesh partitioning","title":"GalerkinToolkit.with_mesh_partitioner","text":"with_mesh_partitioner(mesher[,partitioner];[parts])\n\nGenerate a mesh calling mesher() partition it, and distribute it over the part ids in parts.\n\nArguments\n\nFunction mesher() should have no arguments and returns a sequential mesh object. This function is called only on one process.\npartitioner [optional]: A function that takes a graph encoded as a sparse matrix, and returns a vector containing the part id of each node in the graph. Defaults to Metis.partition.\n\nKeyword arguments\n\nparts [optional]: A vector containing the part indices 1:P where P is the number of parts in the data distribution. By default, P is the number of MPI ranks and 1:P is distributed one item per rank.\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_mesh_partitioning/#Example","page":"Mesh partitioning","title":"Example","text":"","category":"section"},{"location":"src_md/manual_mesh_partitioning/","page":"Mesh partitioning","title":"Mesh partitioning","text":"Create a 3D mesh from a msh file partitioned into 5 parts. Visualize the mesh using colors according to part owner.","category":"page"},{"location":"src_md/manual_mesh_partitioning/","page":"Mesh partitioning","title":"Mesh partitioning","text":"module mesh_partitioning_1 # hide\nimport GalerkinToolkit as GT\nimport GLMakie\nimport Makie\nimport FileIO # hide\n\nparts = 1:5\nmesh = GT.with_mesh_partitioner(;parts) do\n    assets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\n    msh_file = joinpath(assets_dir,\"model.msh\")\n    GT.mesh_from_msh(msh_file)\nend\n\n#Visualize it\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\ncolor = GT.FaceColor(\"__OWNER__\")\nGT.makie_surfaces!(mesh;color)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_12.png\"),Makie.current_figure()) # hide\nend # hide","category":"page"},{"location":"src_md/manual_mesh_partitioning/","page":"Mesh partitioning","title":"Mesh partitioning","text":"(Image: )","category":"page"},{"location":"src_md/manual_mesh_partitioning/","page":"Mesh partitioning","title":"Mesh partitioning","text":"","category":"page"},{"location":"src_md/manual_mesh_partitioning/","page":"Mesh partitioning","title":"Mesh partitioning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_poisson_equation/#Poisson-equation","page":"Poisson equation","title":"Poisson equation","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/#Problem-statement","page":"Poisson equation","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"We want to solve a simple Poisson equation, but this time on a more complex domain and also including Neumann boundary conditions.  Dirichlet boundary conditions are applied on Gamma_rm D, non-homogeneous Neumann conditions are applied on Gamma_rm N,   and homogeneous Neumann boundary conditions are applied on the remaining portion of the boundary. The computational domains are defined in the mesh file model.msh. The domain Omega is represented by the 3D faces in this mesh. The domain Gamma_rm D is represented by the physical group named \"sides\" and Gamma_rm N is the union of the physical groups named \"circle\", \"triangle\", and \"square\".","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Formally, the problem to solve is: find the scalar field u such that","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton Gamma_rm D\nnabla ucdot n = h  texton  Gamma_rm N\nnabla ucdot n = 0  textelsewhere on  partial Omega\nendaligned\nright","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"being n the outwards unit normal vector to partialOmega. In this example, we chose f(x) = 1, g(x) = 2, and h(x)=3. The variable x is the position vector x=(x_1x_2x_3).","category":"page"},{"location":"src_md/example_poisson_equation/#Numerical-scheme","page":"Poisson equation","title":"Numerical scheme","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"We use a conventional Galerkin finite element (FE) method with conforming Lagrangian FE spaces (see, e.g., [1]).  The weak form equation we solve consists in finding u_hin V_g such that a(u_hv) = ell(v) for all vin V_0. To this end we build a space V spanned by continuous and piece-wise Lagrangian basis functions. The auxiliary spaces V_g and V_0 are the subsets of V that fulfill the Dirichlet boundary condition g and 0 on partialOmega respectively. The bilinear and linear forms are","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"  a(uv) doteq int_Omega nabla v cdot nabla u  rm dOmega quad b(v) doteq int_Omega v f   rm  dOmega + int_Gamma_rm N v h  rm dGamma_rm N","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"This equation results in a system of linear algebraic equations that is solved using an external linear solver from LinearSolve.jl.","category":"page"},{"location":"src_md/example_poisson_equation/#Implementation","page":"Poisson equation","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"import FileIO # hide\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport LinearSolve\nimport ForwardDiff\nimport GLMakie as Makie\n\n#Read the mesh file\nassets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"model.msh\")\nmesh = GT.mesh_from_msh(msh_file)\n\n#Geometry\ndirichlet_names = [\"sides\"]\nneumann_names = [\"circle\", \"triangle\", \"square\"]\nΩ = GT.interior(mesh)\nΓd = GT.boundary(mesh;group_names=dirichlet_names)\nΓn = GT.boundary(mesh;group_names=neumann_names)\n\n#Define forcing data\nf = GT.analytical_field(x->1.0,Ω)\ng = GT.analytical_field(x->2.0,Ω)\nh = GT.analytical_field(x->3.0,Ω)\n\n#Define the interpolation space.\nk = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n\n#Interpolate Dirichlet values.\nT = Float64\nuhd = GT.zero_dirichlet_field(T,V)\nGT.interpolate_dirichlet!(g,uhd)\n\n#Define numerical integration.\ndegree = 2*k\ndΩ = GT.measure(Ω,degree)\ndΓn = GT.measure(Γn,degree)\nnothing # hide\n\n#Define weak form.\n∇ = ForwardDiff.gradient\na = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\nl = v -> GT.∫( x->v(x)*f(x), dΩ) + GT.∫( x->v(x)*h(x), dΓn)\n\n#Assemble the problem and solve it\np = GT.SciMLBase_LinearProblem(uhd,a,l)\nsol = LinearSolve.solve(p)\n\n#Build the FE solution.\nuh = GT.solution_field(uhd,sol)\n\n#Visualize the solution.\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Ω;color=uh)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_1.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/#Explicit-integration-loops","page":"Poisson equation","title":"Explicit integration loops","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"This other code version implements the integration loops manually instead of relying on the underlying automatic code generation. It shows how to handle the source term and the Neumann boundary condition.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"#Manually written assembly function\n#Always use a function, never the global scope\nfunction assemble_in_Ω!(A_alloc,Ad_alloc,b_alloc,V,f,dΩ)\n\n    #Iterators to the quantities on the\n    #integration points\n    tabulate = (GT.value,∇)\n    compute = (GT.coordinate,)\n    V_faces = GT.each_face(V,dΩ;tabulate,compute)\n\n    #Temporaries\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Numerical integration loop\n    for V_face in V_faces\n\n        #Get quantities at current face\n        dofs = GT.dofs(V_face)\n\n        #Reset face matrix\n        fill!(Auu,zero(T))\n        fill!(bu,zero(T))\n\n        #Loop over integration points\n        for V_point in GT.each_point(V_face)\n\n            #Get quantities at current integration point\n            x = GT.coordinate(V_point)\n            dV = GT.weight(V_point)\n            dof_s = GT.shape_functions(GT.value,V_point)\n            dof_∇s = GT.shape_functions(∇,V_point)\n\n            #Fill in face matrix and vector\n            for (i,dofi) in enumerate(dofs)\n                v = dof_s[i]\n                ∇v = dof_∇s[i]\n                bu[i] += f.definition(x)*v*dV\n                for (j,dofj) in enumerate(dofs)\n                    ∇u = dof_∇s[j]\n                    Auu[i,j] += ∇v⋅∇u*dV\n                end\n            end\n        end\n\n        #Add face contribution to the\n        #global allocations\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n        GT.contribute!(Ad_alloc,Auu,dofs,dofs)\n        GT.contribute!(b_alloc,bu,dofs)\n    end\nend\n\n#Manually written assembly function\n#Always use a function, never the global scope\nfunction assemble_in_Γn!(b_alloc,V,h,dΓn)\n\n    #Iterators to the quantities on the\n    #integration points\n    tabulate = (GT.value,)\n    compute = (GT.coordinate,)\n    V_faces = GT.each_face(V,dΓn;tabulate,compute)\n\n    #Temporaries\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Numerical integration loop\n    for V_face in V_faces\n\n        #Get quantities at current face\n        dofs = GT.dofs(V_face)\n\n        #Reset face vector\n        fill!(bu,zero(T))\n\n        #Loop over integration points\n        for V_point in GT.each_point(V_face)\n\n            #Get quantities at current integration point\n            x = GT.coordinate(V_point)\n            dV = GT.weight(V_point)\n            dof_s = GT.shape_functions(GT.value,V_point)\n\n            #Fill in face matrix and vector\n            for (i,dofi) in enumerate(dofs)\n                v = dof_s[i]\n                bu[i] += h.definition(x)*v*dV\n            end\n        end\n\n        #Add face contribution to the\n        #global allocations\n        GT.contribute!(b_alloc,bu,dofs)\n    end\nend\n\n#Allocate matrix for free columns\nA_alloc = GT.allocate_matrix(T,V,V,Ω)\n\n#Allocate matrix for dirichlet columns\nfree_or_dirichlet=(GT.FREE,GT.DIRICHLET)\nAd_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet)\n\n#Allocate rhs vector\nb_alloc = GT.allocate_vector(T,V,Ω,Γn)\n\n#Fill allocations with the function we wrote above\nassemble_in_Ω!(A_alloc,Ad_alloc,b_alloc,V,f,dΩ)\nassemble_in_Γn!(b_alloc,V,h,dΓn)\n\n#Compress matrix and vector into the final format\nA = GT.compress(A_alloc)\nAd = GT.compress(Ad_alloc)\nb = GT.compress(b_alloc)\n\n#Build the linear system\nxd = GT.dirichlet_values(uhd)\nb .= b .- Ad*xd\np = LinearSolve.LinearProblem(A,b)\n\n#Solve the problem\nsol = LinearSolve.solve(p)\nuh = GT.solution_field(uhd,sol)\n\n#Visualize the solution.\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Ω;color=uh)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_2.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/for_developers/#For-developers","page":"For developers","title":"For developers","text":"","category":"section"},{"location":"manual/for_developers/#Building-the-documentation-locally","page":"For developers","title":"Building the documentation locally","text":"","category":"section"},{"location":"manual/for_developers/#Setup-the-docs-folder-environment","page":"For developers","title":"Setup the docs folder environment","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"We assume that your terminal is located in the root folder of the GalerkingToolkit.jl repo. Open Julia, pointing to the docs folder.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"$ julia --project=docs/","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"Develop your current copy of GalerkingToolkit.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> ]\n(docs) pkg> dev .","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"You will need to do this each time the dependencies of the documentation or of GalerkinToolkit change.","category":"page"},{"location":"manual/for_developers/#Standard-build","page":"For developers","title":"Standard build","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"After the setup, exit package mode and run","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/make.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"This will take a while. When it is done, you will have the html docs in the folder docs/build.","category":"page"},{"location":"manual/for_developers/#Visualizing-the-documentation","page":"For developers","title":"Visualizing the documentation","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The easiest way to visualize the documentation is using LiveServer as follows.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> using LiveServer\nserve(dir=\"docs/build/\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"After it, your docs will be served at the given url.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"If nor yet done, you can install LiveServer as follows. We recommend to install it in your global environment.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> ]\npkg> activate\npgk> add LiveServer","category":"page"},{"location":"manual/for_developers/#Quick-build","page":"For developers","title":"Quick build","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The standard build takes a long time since it runs several examples. This delay makes this approach impractical to write documentation, since one needs to build the docs often to check the final result.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"To avoid this, one can run all the files in docs/src/src_jl in advance using","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/make_media.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"and then one can quickly build the documentation with","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/make_with_media.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"This will work as long as you are not including new figures or animations that are generated by running the files in the docs/src/src_jl folder. Otherwise you will need to run the particular file with","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/src/src_jl/<file that generates the figure>.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"or running again","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/media.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The output documentation is not exactly the same as the generated with the standard build method, but it is good enough for development.","category":"page"},{"location":"manual/for_developers/#Performance-Benchmarks","page":"For developers","title":"Performance Benchmarks","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"There is a benchmark suite defined in GalerkinToolkitExamples/benchmarks. This uses BenchmarkTools.jl to perform the timings and github-action-benchmark to collect the results and store them in the benchmarks branch. Upon merging of a PR, and after the docs have built, the benchmark results are copied from the benchmarks branch into the gh-pages branch. This is required to prevent overwriting of the previous results by docs deployment etc.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"Graphs of performance changes over time (per commit hash) can then be viewed here: https://galerkintoolkit.github.io/GalerkinToolkit.jl/dev/bench/.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The github action can be configured (in .github/workflows/CI.yml, job benchmark) to fail if the performance change is beyond a given threshold. Look for the alert-threshold: and fail-on-alert: keys.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"More benchmarks can be added (or existing ones modified) in GalerkinToolkitExamples/benchmarks/run_benchmarks.jl.","category":"page"},{"location":"manual/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"GalerkinToolkit is a high-performance finite element toolbox fully implemented in the Julia programming language. Its mission is to provide general-purpose building blocks of finite element (FE) methods to solve a wide variety of partial differential equations (PDEs), using diverse numerical schemes, and across a range of computing platforms, from laptops to supercomputers.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"The toolkit envisions a unified framework that addresses the needs of numerical analysts, domain scientists, and high-performance computing experts; offering a rich API with multiple levels of abstraction:","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"High-level API: Enables users to solve PDEs conveniently using mathematical abstractions instead of implementing low-level code by hand.\nLow-level API: Grants direct access to underlying numerical quantities, allowing custom implementations of numerical schemes or advanced code optimizations not available through the high-level interface.","category":"page"},{"location":"manual/introduction/#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"GalerkinToolkit provides tools for:","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Reading and partitioning computational meshes generated with external mesh generators.\nDefining discrete interpolation spaces on triangulated manifolds, supporting both continuous and discontinuous interpolations.\nIntegrating functions, linear, and bilinear forms for scalar- and vector-valued equations, including single- and multi-field systems.\nSupporting both simplex and hypercube face geometries, with high-order interpolation capabilities.\nDiscretizing a wide range of PDEs into systems of linear, nonlinear, and differential-algebraic equations.\nRepresenting algebraic problems in formats compatible with external solvers.\nVisualization and post-process of results.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Even though not currently available, these other features are being implemented, or are planned to be implemented in the near future:","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Automatic differentiation for non-linear PDEs and gradient-based optimization methods.\nMatrix-free bilinear forms.\nH(div) and H(curl) interpolation spaces.\nDistributed assembly.\nSingle- and multi-GPU support.","category":"page"},{"location":"manual/introduction/#Novelties","page":"Introduction","title":"Novelties","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"GalerkinToolkit is certainly not the first FEM software project, but it introduces it introduces a novel design:","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Unified high- and low-level APIs–  It combines the vision of frameworks like FEniCS and libraries like Deal-ii in a single package and in a single programming language. It addresses the two-language problem of previous FE projects that consider a Python front-end for easiness of use and a C/C++ backend for performance. With GalerkinToolkit, you can use a concise high-level syntax or directly implement integration loops using low-level building blocks, depending on your needs.\nDeep integration with the Julia ecosystem– GalerkinToolkit reuses existing Julia packages in numerous situations. For example:\nComputational meshes generated with Gmsh.\nDifferential operators from ForwardDiff.jl\nVector/tensor types via StaticArrays.jl and Tensors.jl\nExternal solvers for algebraic systems from PartitionedSolvers.jl, PetscCall.jl, LinearSolve.jl, NonLinearSolve.jl, and DifferentialEquations.jl.\nVisualization with Makie.jl and WriteVTK.jl\nThe GalerkinToolkit Form Compiler (GTFC)– GTFC uses Julia’s metaprogramming capabilities to generate efficient code from high-level mathematical abstractions. Unlike other compilers like FFC or TSFC:\nIt does not rely on an external DSL like UFL. It considers a sub-set of the Julia programming language as alternative.\nIn consequence, it allows user-defined types in the weak form.\nMoreover, it supports advanced use cases, such as coupling surface and volume arguments in multi-field weak forms both for continuous and discontinuous interpolations.\nA major overhaul of Gridap– GalerkinToolkit began as a full reimplementation of the core ideas behind Gridap. While Gridap is based on lazily mapped arrays, GalerkinToolkit centers on form compilation and a low-level API designed to easily deal with quantities at integration points. These provide both a loop-free high-level API and manual control of integration loops.","category":"page"},{"location":"manual/introduction/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"GalerkinToolkit is a registered package in the official Julia package registry. As such, you can install GalerkinToolkit easily using the Julia package manager.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Open Julia and type ] to enter package mode.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"julia> ]","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Then, type","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"pkg> add GalerkinToolkit","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"This installs GalerkinToolkit and all its dependencies.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Press ctrl+C to go back to standard mode. Now, you can type","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"julia> import GalerkinToolkit as GT","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"to start using GalerkinToolkit.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"You will need to have Julia installed in your system. See the official Julia installation instructions here.","category":"page"},{"location":"manual/introduction/#This-manual","page":"Introduction","title":"This manual","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"It provides detailed explanations so that users build an understanding of the library. We start detailing the geometrical foundations of the library: computational meshes and domains. Then, we cover the construction of interpolation spaces and the numerical integration capabilities. Finally, we explain the post-processing layer including the visualization of results.","category":"page"},{"location":"src_md/example_stokes/#Stokes-lid-driven-cavity","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"","category":"section"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"(Image: )","category":"page"},{"location":"src_md/example_stokes/#Problem-statement","page":"Stokes lid-driven cavity","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"warning: Warning\nTODO","category":"page"},{"location":"src_md/example_stokes/#Numerical-scheme","page":"Stokes lid-driven cavity","title":"Numerical scheme","text":"","category":"section"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"warning: Warning\nTODO","category":"page"},{"location":"src_md/example_stokes/#Implementation","page":"Stokes lid-driven cavity","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"import GalerkinToolkit as GT\nimport LinearSolve\nimport GLMakie as Makie\nimport ForwardDiff\nimport StaticArrays\nimport Tensors\nusing LinearAlgebra\nimport FileIO # hide\n\n#Mesh\ndomain = (0,1,0,1)\ncells = (20,20)\nD = length(cells)\nmesh = GT.cartesian_mesh(domain,cells)\n\n#Domains\nΩ = GT.interior(mesh)\nΓ = GT.boundary(mesh;group_names=[\"1-face-1\",\"1-face-2\",\"1-face-3\",\"1-face-4\"])\ng = GT.analytical_field(Γ;piecewise=true) do x,name\n    if name == \"1-face-2\"\n        StaticArrays.SVector(1,0)\n    else\n        StaticArrays.SVector(0,0)\n    end\nend\n\n#Velocity interpolation\norder = 2\ntensor_size=Val((D,))\ndirichlet_boundary = Γ\nV = GT.lagrange_space(Ω,order;tensor_size,dirichlet_boundary)\n\n#Pressure interpolation\nspace_type=:P\ndirichlet_boundary=GT.last_dof()\nQ = GT.lagrange_space(Ω,order-1;space_type,dirichlet_boundary)\n\n#Cartesian product space\nVxQ = V × Q\n\n#Dirichlet condition\nuhph_dirichlet = GT.zero_dirichlet_field(Float64,VxQ)\nuhd, = uhph_dirichlet\nGT.interpolate_dirichlet!(g,uhd)\n\n#Weak form\ndΩ = GT.measure(Ω,2*order)\n∇ = ForwardDiff.jacobian\ndiv(u,x) = tr(∇(u,x))\na((u,p),(v,q)) = GT.∫( x-> ∇(v,x)⋅∇(u,x) - div(v,x)*p(x) + q(x)*div(u,x), dΩ)\nl((v,q)) = 0\n\n#Assemble linear problem and solve it\np = GT.SciMLBase_LinearProblem(uhph_dirichlet,a,l)\nsol = LinearSolve.solve(p)\n\n#Get solution fields\nuh,ph = GT.solution_field(uhph_dirichlet,sol)\n\n#Visualize solution\nfig = Makie.Figure()\naspect = Makie.DataAspect()\nax = Makie.Axis(fig[1,1];aspect)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nshading = Makie.NoShading\nGT.makie_surfaces!(Ω;color=ph,shading)\nGT.makie_arrows2d!(Ω,uh;color=x->norm(uh(x)),lengthscale=0.1)\nFileIO.save(joinpath(@__DIR__,\"fig_stokes_1.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/manual_domains/#Domains","page":"Domains","title":"Domains","text":"","category":"section"},{"location":"src_md/manual_domains/","page":"Domains","title":"Domains","text":"","category":"page"},{"location":"src_md/manual_domains/","page":"Domains","title":"Domains","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Introduction\nMeshes\nMesh partitioning\nFor developers","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Introduction-to-the-FEM","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"by Francesc Verdugo (VU Amsterdam)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"In this lecture, we will learn:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The gist of the finite element method (FEM).\nHow to solve a simple partial differential equation (PDE) with it.\nHow to express the key concepts in code using GalerkinToolkit.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"This lecture is useful even if you are a FEM expert and you want to learn GalerkinToolkit. It will walk you through the key parts of the library.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"This lecture is made available under a CC BY 4.0 license. The API documentation and source code of GalerkinToolkit is available under an MIT license.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Problem-statement","page":"Introduction to the FEM","title":"Problem statement","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We show how to solve a simple PDE with the FEM. To make this introduction really an introduction we consider the \"hello, world\" PDE: the Poisson equation.  Our goal is to solve it when adding Dirichlet boundary conditions. These are the inputs of the problem. A domain OmegasubsetmathbbR^d with d being the number of spatial dimensions (d=2 in this example), and two functions f, g such that fgOmegarightarrowmathbbR. The problem is formalized as finding the function uOmegarightarrowmathbbR such that","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"where Delta u = sum_i=1^d partial^2 u  partial x_i^2 is the Laplace operator and partialOmega is the boundary of Omega. We define Omega as a disk of radius one. This is a simple geometry, but yet more complex than a simple two-dimensional box. With this, we illustrate that FEM can be used to solve PDEs on complex geometries beyond simple \"boxes\".","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#The-method-of-manufactured-solutions","page":"Introduction to the FEM","title":"The method of manufactured solutions","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We are going to select f and g in such a way u is a known function. This will allow us to compare the numerical approximation computed with FEM against the theoretical exact solution u. This technique is known as the \"method of manufactured solutions\". Note that u is not known in practical applications.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us, \"manufacture\" f and g such that function u(x)=(sum_i=1^d x_i)^p is the solution of the PDE above. The scalar p is a given integer p0. It will be useful to see how the numerical solution will behave for different values of p.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"To manufacture functions f and g, we apply the PDE operators to the expression for u. Function f is to be computed as f(x)= -Delta ((sum_i=1^d x_i)^p) and g is simply g(x)=(sum_i=1^d x_i)^p. Applying the Laplace operator to (sum_i=1^d x_i)^p, we get the closed-form expression for f, namely f(x)= -d cdot p(p-1)(sum_i=1^d x_i)^(p-2).","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Numerical-approximation","page":"Introduction to the FEM","title":"Numerical approximation","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The FEM transforms a PDE into a system of linear algebraic equations of the form Ax=b, where A is a matrix and b is a vector. This reduces the problem of finding function u to finding vector x, which can be done on a computer using arrays and other numeric data structures. The FEM does not look for the exact function u, but for approximations of it that can be written as a linear combination of a finite number of basis functions,","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u^mathrmfem(x)=sum_j=1^N alpha_j s_j(x)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"where alpha_i are the coefficients of the linear combination and s_i are functions such that s_iOmegarightarrowmathbbR. The integer N is the number of terms in the linear combination. The basis functions s_i are also called \"shape functions\" or \"hat functions\". The goal of FEM is to find suitable values for alpha_i and s_i(x) such that u^mathrmfem is a good approximation of the exact solution u: u^mathrmfem(x)approx u(x) for points xinOmega. The more computational effort we put in building function u^mathrmfem the better will be the approximation.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Workflow","page":"Introduction to the FEM","title":"Workflow","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Function u^mathrmfem is built as follows. First, we define the auxiliary functions s_i(x). This step is referred to as the \"numerical discretization\" and entails defining a computational mesh and a finite element (FE) function space. The next step is building a system of linear algebraic equations Ax=b. This step is called the \"FEM assembly\" step. Then, one solves for the vector x in what is called the \"solver\" or \"solution\" step. At this points, the coefficients alpha_i can be computed using both vector x and the Dirichlet boundary conditions of the PDE. The final step is typically some post-process of function u^mathrmfem. For instance, visualize it, store it in a file, compute some quantity of interest, etc. In summary, these are the key phases in a FEM computation:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Discretization\nAssembly\nSolution\nPost-process","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Mesh-generation","page":"Introduction to the FEM","title":"Mesh generation","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The FEM starts by building a \"triangulation\" mathcalT of the domain Omega in which the PDE is defined. A triangulation mathcalT is a set of simpler domains T_ksubsetmathbbR^d, whose union is an approximation of Omega,  cup_k=1^M T_kapproxOmega. Each domain T_k is called an \"element\", a \"cell\" or a \"face\", and they are typically simple geometries such as triangles, tetrahedra, hexahedra, etc. The integer M denotes the number of elements. The triangulation is also called a computational \"mesh\" or a computational \"grid\".","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let's build a mesh for our domain Omega using code. First, let us load all packages that we will use in this lecture:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"using LinearAlgebra\nusing Random\nimport GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"A common practice in GalerkinToolkit is to load packages in the Julia standard library with using. Other packages are loaded with import. This makes clear from which package each function comes from, while assuming that developers already know functions in the standard library.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The following cell builds a triangulation (a mesh object) using the external mesh generation tool GMSH. The variable mesh_size controls how small are the cells in the mesh. We start with a coarse mesh to make visualization easier. We are not going to comment in detail all code lines. We will discuss only the parts relevant in this high-level introduction. You can refer to the API documentation and other tutorials when needed.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"mesh_size = 0.3\nR = 1 #Radius\nmesh = GT.with_gmsh() do gmsh\n    dim = 2\n    gmsh.option.set_number(\"General.Verbosity\", 2)\n    circle_tag = gmsh.model.occ.add_circle(0,0,0,R)\n    circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])\n    circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])\n    gmsh.model.occ.synchronize()\n    gmsh.model.model.add_physical_group(dim,[circle_surf_tag],-1,\"Omega\")\n    gmsh.option.set_number(\"Mesh.MeshSizeMax\",mesh_size)\n    gmsh.model.mesh.generate(dim)\n    GT.mesh_from_gmsh(gmsh)\nend\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The mesh we just created can be visualized both with Paraview and Makie. We use Makie in this lecture.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"aspect = Makie.DataAspect()\nshading = Makie.NoShading\nkwargs = (;axis=(;aspect),shading)\nGT.makie_surfaces(mesh;color=:pink,kwargs...)\nGT.makie_edges!(mesh;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_mesh.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Computational-domains","page":"Introduction to the FEM","title":"Computational domains","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that two domains appear in the definition of the PDE above, the domain Omega and its boundary partialOmega. We need to build data objects representing them to solve the PDE with GalerkinToolkit. They are built from the mesh objects as follows:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Ω = GT.interior(mesh)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"∂Ω = GT.boundary(mesh)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We can also visualize them using Makie.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"GT.makie_surfaces(Ω;color=:pink,kwargs...)\nGT.makie_edges!(∂Ω;color=:blue,linewidth=3)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_domains.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that Ω is indeed an approximation of the unit disk (visualized as a pink surface), and ∂Ω is its boundary (visualized with thick blue lines).","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#FE-space","page":"Introduction to the FEM","title":"FE space","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us now build the data structure representing the finite element function u^mathrmfem. We need two ingredients, the functions s_i and the coefficients α_i. Functions s_i are linearly independent and can be understood as the basis of a vector space V=mathrmspans_1ldotss_N. This space is called the FE space. There are many ways of defining FE spaces. Here, we will use the simplest one, which is based on Lagrange polynomials. To build it with GalerkinToolkit, we need the computational domain on which the functions of the space are defined and their polynomial degree, since these function are polynomials inside the cells of the mesh.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"degree = 2\nV = GT.lagrange_space(Ω,degree)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We will discus the mathematical derivation of this FE space in another lecture. For now, it is enough to understand that the object V has information about the basis functions s_i. For instance, you can get the number of basis functions with","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"N = GT.num_dofs(V)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The word \"dofs\" stands for degrees of freedom (DOFs). Each coefficent alpha_i can be understood as a degree of freedom, i.e., a quantity that can be tweaked to modify function u^mathrmfem.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The coefficients alpha_i are unknown at this point. We will compute them later. For the moment, we can build a mock u^mathrmfem using some random coefficients alpha_i just to see the connection between the coefficients  alpha_i and the resulting function u^mathrmfem. We create them as a random vector of length N.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Random.seed!(1)\nα = rand(N)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We create the function from these coefficients and the FE space as follows:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u_fem = GT.discrete_field(V,α)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"As suggested by the function name, the numerical approximation is called \"discrete field\" in GalerkinToolkit. The field is \"discrete\" since it is expressed in terms of a finite number of degrees of freedom.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let's us visualize it. We do this by plotting domain Omega, using the function value as the color code.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u_fem,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_rand_field.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"By looking into the figure it is clear that function u^mathrmfem(x) is indeed a function that can be evaluated at any point inside the domain Omega, i.e., a field.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Dual-operators","page":"Introduction to the FEM","title":"Dual operators","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The FEM also consider a basis for V^prime, the dual space of V. Basis functions in the dual space are linear operators sigma_iVrightarrowmathbbR that map functions in the original (primal) space V into real values. The particular definition of these operators is not important in this lecture. See them as black boxes, that fulfill  these properties: The operators sigma_i are linear, there is one operator sigma_i for each shape function s_i, and they  are related with this formula sigma_i(s_j)=delta_ij, where delta_ij is Kroneker's delta. Operator sigma_i maps the shape function s_i to one, sigma_i(s_i)=1, and maps the other shape functions to zero, sigma_i(s_j)=0 for ineq j. This property allows us to compute alpha_i as the application of operator sigma_i to the numerical approximation u^mathrmfem, namely alpha_i=sigma_i(u^mathrmfem). You can understand sigma_i(u^mathrmfem) as \"extract\" coefficient alpha_i from u^mathrmfem. You can easily prove this by taking sigma_i(u^mathrmfem) = sigma_i(sum_j=1^N alpha_j s_j) and considering that sigma_i is linear and sigma_i(s_j)=delta_ji.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#FE-interpolation","page":"Introduction to the FEM","title":"FE interpolation","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Using the dual operators, we can define an interpolation operator that builds a function in the FE space V from a given function fOmegarightarrowmathbbR :","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Pi^mathrmfem f)(x) = sum_j=1^N sigma_j(f) s_j(x)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us do this interpolation using code for a particular function. First, we need to define the function we want to interpolate","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"f = GT.analytical_field(Ω) do x\n    sin(4*pi*x[1])*cos(4*pi*x[2])\nend\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We have build an \"analytical field\", which is a field defined by an analytical function. Let us visualize it.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=f,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_f.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We interpolate the field using code","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"f_fem = GT.interpolate(f,V)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and we visualize the result","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=f_fem,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_f_fem.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that the interpolated field is an approximation of the original one. The \"noisier\" the original field, the worse will be the interpolation. Also the larger the number of DOFs in the space V the better will be the interpolation.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Free-and-Dirichlet-DOFs","page":"Introduction to the FEM","title":"Free and Dirichlet DOFs","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Remember that our goal is to find the coefficients α_i. Most of them are unknown, but not all. Note that the PDE states that u=g on the boundary partialOmega. With this information we can compute some of the coefficients alpha_i directly, without solving a linear system. To find out which coefficients are really unknown and which can be computed from the boundary condition, we classify the shape functions s_i into two groups: the s_i that are zero at any point of the boundary, s_i(x) = 0 for all xinpartialOmega, in one group, and the rest in the second group. We denote s^mathrmf_i the shape function number i in the first group, and s^mathrmd_i function number i in the second group. Letters \"f\" and \"d\" stand for \"free\" and \"Dirichlet\" as they will be associated with unknown (free) coefficients and coefficients computed from the Dirichlet condition respectively. Using this classification  of the shape functions, we can also classify the coefficients alpha_i, and the dual operators sigma_i. Consider starin(mathrmfmathrmd). The coefficient alpha^star_i is the one that multiplies s^star_i and sigma^star_i is its associated dual operator. We can also define the space V^star=mathrmspans^star_1ldotss^star_N^star as the subspace of V generated by the shape functions s^star_i. Finally,  we call N^star the number of shape functions s^star_i for starin(mathrmfmathrmd),  i.e, the number of free and Dirichlet DOFs.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The shape functions are classified in the code by creating a FE space that is aware of the Dirichlet boundary:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"V = GT.lagrange_space(Ω,degree;dirichlet_boundary=∂Ω)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Now the DOFs in this space are split on two groups: free and Dirichlet. We can get the number of free DOFs","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"N_f = GT.num_free_dofs(V)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and the number of Dirichlet DOFs.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"N_d = GT.num_dirichlet_dofs(V)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Dirichlet-Field","page":"Introduction to the FEM","title":"Dirichlet Field","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Using the classification of nodes, we can decompose function u^mathrmfem(x) as the sum of two functions,","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u^mathrmfem(x)=u^mathrmf(x)+u^mathrmd(x)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"with","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u^star(x)=sum_j=1^N^star alpha^star_j s^star_j(x) text for  starin(mathrmfmathrmd)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that u^mathrmfin V^mathrmf is a linear combination of the \"free\" shape functions, and u^mathrmdin V^mathrmd is a linear combination of the \"Dirichlet\" shape functions.  This decomposition is useful because u^mathrmd can be directly computed from the Dirichlet Boundary condition. We refer to u^mathrmd as the \"Dirichlet field\". It is computed by building the coefficients alpha^mathrmd_i=sigma^mathrmd_i(g) as the application of the linear operators for the Dirichlet DOFs on function g. In other words, u^mathrmd is built as the interpolation of the Dirichlet function g onto the space V^mathrmd, u^mathrmd=Pi^mathrmd g. The interpolation to the spaces V^mathrmf and V^mathrmd of a given function f is defined as we did for V, but only taking the corresponding shape functions:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Pi^star f)(x) = sum_j=1^N^star sigma^star_j(f) s^star_j(x) text for  starin(mathrmfmathrmd)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us build the Dirichlet field with code. First, we need to build an analytical field representing the Dirichlet function. We take p=3 for example.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"g = GT.analytical_field(Ω) do x\n    sum(x)^3\nend\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Then, we interpolate this field, but only on the Dirichlet DOFs, yielding the Dirichlet field","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u_d = GT.interpolate_dirichlet(g,V)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that it is a function that (by definition) is possibly non-zero near the Dirichlet boundary.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u_d,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_diri.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Using the Dirichlet field, we can create function u^mathrmfem only from coefficients that are associated with free DOFs. These are going to be computed later by solving a system of linear equations, but we can create a mock version of them with randomly generated values. We generate a vector of length N^mathrmf because it should contain only \"free\" coefficients.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Random.seed!(2)\nα_f = rand(N_f)\nu_fem = GT.solution_field(u_d,α_f)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"In the following figure, one can see that u^mathrmfem generated in this way has random values in the interior of Omega, while matching the Dirichlet boundary condition on partialOmega.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u_fem,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_fem_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#The-weighted-residual-method","page":"Introduction to the FEM","title":"The weighted residual method","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"To solve the problem now, we need to find the coefficients alpha^mathrmf_i associated with the free DOFs. The number of such coefficients is N^mathrmf. Hence, we have N^mathrmf unknowns, which suggests that we needs to consider N^mathrmf equations. These equations will follow from the PDE above.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us introduce the residual of the PDE, namely r(v) = Delta v + f for a given function v. The operator r is such that r(u)=0 for the exact solution of the PDE. The residual provides an estimation of how good a function approximates the solution of the PDE. If r(v) is \"small\", then v is a good approximation of u as long as v also fulfills the Dirichlet boundary condition v=g on partialOmega. Our goal is to find the coefficients alpha^mathrmf_i for which the resulting function u^mathrmfem has a \"small\" residual r(u^mathrmfem). This approach however requires some caution. First, we need to define what \"small\" is. The second problem is that we cannot evaluate r(u^mathrmfem) as this value it is not well defined for all points xinOmega. Function u^mathrmfem is continuous, but its gradient is not continuous at the boundaries of the mesh cells. As a consequence the Laplace operator and the residual r it is not well defined on the cell boundaries.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us visualize one of the components of the gradient of u^mathrmfem to confirm that it is discontinuous. First, let us define the nabla operator.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"∇ = ForwardDiff.gradient\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Then, we visualize the first component of the gradient as follows:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\ngrad1 = x->∇(u_fem,x)[1]\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=grad1,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_grad.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"It is indeed discontinuous at the mesh cell boundaries.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The FEM solves this problem by considering to so-called \"weighted residual method\". First, the method provides a formal definition for what a \"small\" residual is. The method looks for a function u^mathrmfem such that","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"int_Omega r(u^mathrmfem) s^mathrmf_i  dOmega = 0 text for  i=1ldotsN^mathrmf","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"That is, we want the integral of the residual times a free shape function s^mathrmf_i to be zero. Each free shape function provides an equation. Thus, the number of total equations that we build with this expression is N^mathrmf, which coincides with the number of unknowns. Perfect!","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Now, we need to address the second problem: we need to avoid computing Delta u^mathrmfem as this quantity is not well defined for function u^mathrmfem on cell boundaries. Let us expand the integral above, by in-lining the definition of r:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"int_Omega ( (Delta u^mathrmfem) s^mathrmf_i + f s^mathrmf_i ) dOmega = 0","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We can get rid of the Laplace operator by using this identity","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"nablacdot(nabla u^mathrmfem s^mathrmf_i) = (Delta u^mathrmfem) s^mathrmf_i + nabla u^mathrmfem cdot nabla s^mathrmf_i","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"or equivalently","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":" (Delta u^mathrmfem) s^mathrmf_i = nablacdot(nabla u^mathrmfem s^mathrmf_i) - nabla u^mathrmfem cdot nabla s^mathrmf_i","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"This identity is analogous to the well known rule for the derivative of a product, but when the functions are multivariate functions. The quantity nabla v is the gradient of the scalar function v, which is a vector defined as nabla v_k = partial vpartial x_k. The value nablacdot w is the divergence of a vector function w, which is defined as nablacdot w = sum_k^d partial w_kpartial x_k.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Substituting for (Delta u^mathrmfem) s^mathrmf_i in the integral above, we get:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"int_Omega (nablacdot(nabla u^mathrmfem s^mathrmf_i) - nabla u^mathrmfem cdot nabla s^mathrmf_i + f s^mathrmf_i) dOmega = 0","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We still have a second order derivative in the first term inside the integral. We can take rid of this one using the Gauss divergence theorem:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"int_Omega nablacdot(nabla u^mathrmfem s^mathrmf_i)  dOmega = int_partialOmega ncdot(nabla u^mathrmfem s^mathrmf_i) dpartialOmega","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"where n is the unit normal vector on the boundary partialOmega pointing outwards to Omega. Note that the right hand side is an integral on the boundary and we classified the shape functions so that all s^mathrmf_i are zero at the boundary. Using s^mathrmf_i(x)=0 for any xinpartialOmega, we get:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"int_partialOmega ncdot(nabla u^mathrmfem s^mathrmf_i) dpartialOmega = 0","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Using this result and rearranging terms, we get this new formulation of our equations:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":" int_Omega nabla u^mathrmfem cdot nabla s^mathrmf_i  dOmega = int_Omega f s^mathrmf_i  dOmega text for  i=1ldotsN^mathrmf","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that this new formulation does not require computing second order derivatives. Thus, it is well suited for the numerical approximation u^mathrmfem. This equation is called the \"weak form\" of the PDE, since it puts weaker regularity requirements to the numerical approximation u^mathrmfem. In contrast, the original PDE formulation is called the \"strong form\". There are different types of weak forms. Each one is designed for a type of numerical approximation and PDE. This one is for the Poisson equation and continuous approximations with discontinuous gradients. Other weak forms exist for this PDE. For instance, \"discontinuous Galerkin\" methods build the numerical approximation such as it is discontinuous across cell boundaries. One needs to consider another weak form for this case, since we cannot even compute the gradient on cell boundaries.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#System-of-linear-algebraic-equations","page":"Introduction to the FEM","title":"System of linear algebraic equations","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us rewrite the weak equation as a(u^mathrmfems^mathrmf_i) = ell(s^mathrmf_i) with","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"a(u^mathrmfems^mathrmf_i) =  int_Omega nabla u^mathrmfem cdot nabla s^mathrmf_i  dOmega","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"ell(s^mathrmf_i)= int_Omega f s^mathrmf_i  dOmega","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"If we substitute","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u^mathrmfem = sum_j=1^N^mathrmfalpha^mathrmf_j s^mathrmf_j +sum_j=1^N^mathrmdalpha^mathrmd_j s^mathrmd_j","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"we get","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"sum_j=1^N^mathrmfa(s^mathrmf_js^mathrmf_i)alpha^mathrmf_j = ell(s^mathrmf_i) - sum_i=1^N^mathrmda(s^mathrmd_js^mathrmf_i)alpha^mathrmd_j text for  i=1ldotsN^mathrmf","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We have used the fact that a is linear in each one of its arguments to move it inside the sums. If we look closer, this can be written in matrix form as","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"A^mathrmfalpha^mathrmf = b - A^mathrmdalpha^mathrmd","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"where alpha^mathrmf and alpha^mathrmd are two vectors containing the coefficients alpha^mathrmf_i and alpha^mathrmd_i respectively. Values A^mathrmf and A^mathrmd are matrices, and b is a vector. They are defined as","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"A^mathrmf_ij = a(s^mathrmf_js^mathrmf_i)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"A^mathrmd_ij = a(s^mathrmd_js^mathrmf_i)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"b_i = ell(s^mathrmf_i)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Solving for alpha^mathrmf, we find the unknown coefficients in u^mathrmfem.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"In code, we can build these two matrices and vector using a high-level API. First, we define a measure object that allows us to do the integrals over Omega. This object uses a numerical quadrature internally. So, we need to specify the polynomial degree that we want to integrate exactly. Two times the degree of the interpolation space is a good rule of thumb.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"integration_degree = 2*degree\ndΩ = GT.measure(Ω,integration_degree)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Then, we need to define the field representing function f","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"f = GT.analytical_field(Ω) do x\n    p=3\n    -2*p*(p-1)*sum(x)^(p-2)\nend\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and functions representing a and ell.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"a = (u,v) -> GT.∫(x->∇(u,x)⋅∇(v,x), dΩ)\nℓ = v -> GT.∫(x->f(x)*v(x), dΩ)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Now, we can create the matrix and the vector for free DOFs","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"K_f = GT.assemble_matrix(a,Float64,V,V)\nb = GT.assemble_vector(ℓ,Float64,V)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We can also assembly the matrix for the Dirichlet DOFs using an optional argument. Here, we are asking for \"free\" rows and \"Dirichlet\" columns.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"free_or_dirichlet = (GT.FREE,GT.DIRICHLET)\nK_d = GT.assemble_matrix(a,Float64,V,V;free_or_dirichlet)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that to build the final right-hand-side of the system, we compute b-K^mathrmdalpha^mathrmd and we need the Dirichlet coefficients alpha^mathrmd. They can be taken from the Dirichlet field that we created before.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"α_d = GT.dirichlet_values(u_d)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Now, we have all ingredients to build and solve the algebraic system:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"α_f = K_f\\(b-K_d*α_d)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We can finally create the function u^mathrmfem from the computed coefficients.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u_fem = GT.solution_field(u_d,α_f)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"There is a more compact (and efficient) way of building and solving the system. This one generates matrices K^mathrmf and K^mathrmd in a single loop internally. We create a linear problem object, we solve it, and we extract the solution field from it. This approach automatically handles the Dirichlet boundary conditions.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"p = GT.PartitionedSolvers_linear_problem(u_d,a,ℓ)\ns = PS.solve(p)\nu_fem = GT.solution_field(u_d,s)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Finally, we visualize the computed FEM solution.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u_fem,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_fem_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us also define the manufactured solution u","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u = GT.analytical_field(Ω) do x\n    sum(x)^3\nend\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and visualize it","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_sol.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"They look very similar. It seems that we solved the PDE correctly (but we still need to conform it mathematically).","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#FE-error","page":"Introduction to the FEM","title":"FE error","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Lets us introduce the error field, i.e., the difference between the exact and numerical solution, e^mathrmfem(x) = u(x)- u^mathrmfem(x).","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"e_fem = x -> u(x) - u_fem(x)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Visualize it.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=e_fem,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_error.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that the error is not zero! Functions u and u^mathrmfem are not the same, the last one is just an approximation. The result looks promising, but how do we know for sure that this is the expected approximation? This is what we will learn in the next lecture!","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Conclusion","page":"Introduction to the FEM","title":"Conclusion","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We learned the key ingredients to solve a PDE with the FEM. This requires to define a discrete space, and look for a solution in this space that makes the residual of the PDE \"small\". To properly define what a \"small\" residual is, we used the weighted residual method. This also allowed us to rewrite the PDE into a new form called the weak form. This weak form is needed, because only the residual of the weak form makes sense for functions in the discrete space. We also learned that part of the coefficients of the numerical approximation are unknown. A subset of them can be computed directly by interpolating the Dirichlet boundary condition. We used the method of manufactured solutions to build a PDE with known solution so that we can compare it with the computed approximation.  We also learned how to represent all these concepts using GalerkinToolkit. In the next lecture, we will learn how to confirm that our computed approximation is mathematically correct.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/manual_visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"src_md/manual_visualization/","page":"Visualization","title":"Visualization","text":"","category":"page"},{"location":"src_md/manual_visualization/","page":"Visualization","title":"Visualization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_hello_world_lm/#Lagrange-multipliers","page":"Lagrange multipliers","title":"Lagrange multipliers","text":"","category":"section"},{"location":"src_md/example_hello_world_lm/","page":"Lagrange multipliers","title":"Lagrange multipliers","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world_lm/#Problem-statement","page":"Lagrange multipliers","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_hello_world_lm/","page":"Lagrange multipliers","title":"Lagrange multipliers","text":"We solve the same PDE as in the Hello, World! example, but this time using an auxiliary field of Lagrange Multipliers to impose the Dirichlet boundary conditions.","category":"page"},{"location":"src_md/example_hello_world_lm/#Implementation","page":"Lagrange multipliers","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_hello_world_lm/","page":"Lagrange multipliers","title":"Lagrange multipliers","text":"import FileIO # hide\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport ForwardDiff\nimport GLMakie as Makie\nimport LinearSolve\n\n#Geometry\ndomain = (0,1,0,1,0,1)\ncells = (4,4,4)\nmesh = GT.cartesian_mesh(domain,cells)\nD = GT.num_dims(mesh)\nn = GT.unit_normal(mesh,D-1)\nΩ = GT.interior(mesh)\nΓd = GT.boundary(mesh)\n\n#Functions\n∇ = ForwardDiff.gradient\ng = GT.analytical_field(sum,Ω)\nf = GT.analytical_field(x->0,Ω)\n\n#Interpolation\ninterpolation_degree = 1\nV = GT.lagrange_space(Ω,interpolation_degree)\nQ = GT.lagrange_space(Γd,interpolation_degree-1;continuous=false)\nVxQ = V × Q\n\n#Integration\nintegration_degree = 2*interpolation_degree\ndΩ = GT.measure(Ω,integration_degree)\ndΓd = GT.measure(Γd,integration_degree)\n\n#Weak form\na = ((u,p),(v,q)) -> begin\n    GT.∫(dΩ) do x\n        ∇(u,x)⋅∇(v,x)\n    end +\n    GT.∫(dΓd) do x\n        (u(x)+p(x))*(v(x)+q(x)) -\n        u(x)*v(x) -p(x)*q(x)\n    end\nend\nl = ((v,q),) -> begin\n    GT.∫(dΩ) do x\n        v(x)*f(x)\n    end +\n    GT.∫(dΓd) do x\n        g(x)*q(x)\n    end\nend\n\n#Assemble problem\n#and solve it.\np = GT.SciMLBase_LinearProblem(Float64,VxQ,a,l)\nsol = LinearSolve.solve(p)\nuh,qh = GT.solution_field(VxQ,sol)\n\n#Error check\neh = x -> uh(x) - g(x)\nel2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt\n@assert el2 < 1.0e-9\n\n#Visualization\n#of the multipliers\nfig = Makie.Figure()\nax = Makie.Axis3(fig[1,1],aspect=:data)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Γd;color=qh)\nFileIO.save(joinpath(@__DIR__,\"fig_hello_world_lm_1.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_lm/","page":"Lagrange multipliers","title":"Lagrange multipliers","text":"","category":"page"},{"location":"src_md/example_hello_world_lm/","page":"Lagrange multipliers","title":"Lagrange multipliers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_linear_elasticity/#Linear-elasticity","page":"Linear elasticity","title":"Linear elasticity","text":"","category":"section"},{"location":"src_md/example_linear_elasticity/","page":"Linear elasticity","title":"Linear elasticity","text":"(Image: )","category":"page"},{"location":"src_md/example_linear_elasticity/#Problem-statement","page":"Linear elasticity","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_linear_elasticity/#Implementation","page":"Linear elasticity","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_linear_elasticity/","page":"Linear elasticity","title":"Linear elasticity","text":"import FileIO # hide\nusing LinearAlgebra\nusing StaticArrays\nimport GalerkinToolkit as GT\nimport Tensors\nimport LinearSolve\nimport ForwardDiff\nimport GLMakie as Makie\n\n#Read the mesh file\nassets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"solid.msh\")\nmesh = GT.mesh_from_msh(msh_file)\n\n#Computational domains\nmaterial_1 = \"material_1\"\nmaterial_2 = \"material_2\"\nsurface_1 = \"surface_1\"\nsurface_2 = \"surface_2\"\nΩ = GT.interior(mesh;group_names=[material_1,material_2])\nΓ = GT.boundary(mesh;group_names=[surface_1,surface_2])\n\n#Vector-valued mask telling which components\n#of the solution on Γ are enforced\n#with Dirichlet conditions\npiecewise = Val(true)\nmask = GT.analytical_field(Γ;piecewise) do x,name\n    if name === surface_1\n        SVector(true,true,false)\n    elseif name === surface_2\n        SVector(true,true,true)\n    end\nend\n\n#Create interpolation space\norder = 2\ntensor_size = Val((3,))\ndirichlet_boundary = mask\nV = GT.lagrange_space(Ω,order;tensor_size,dirichlet_boundary)\n\n#Dirichlet displacements\n#NB. The third component on surface_1\n#will be ignored according to the mask above\nud = GT.analytical_field(Γ;piecewise) do x,name\n    if name === surface_1\n        δ = 0.005\n        SVector(δ,0.,0.)\n    elseif name === surface_2\n        SVector(0.,0.,0.)\n    end\nend\n\n#Interpolate Dirichlet function\nuhd = GT.interpolate_dirichlet(ud,V)\n\n#Material dependent parameters\nparams = GT.analytical_field(Ω;piecewise) do x,name\n    if name === material_1\n        E=70.0e9\n        ν=0.33\n    elseif name === material_2\n        E=200.0e9\n        ν=0.33\n    end\n    λ = (E*ν)/((1+ν)*(1-2*ν))\n    μ = E/(2*(1+ν))\n    (λ,μ)\nend\n\n#Definition of strain\nfunction ε(∇u)\n    Tensors.symmetric(Tensors.Tensor{2,3}(∇u))\nend\n\n#Definition of stress from strain\nfunction σ(ε,params)\n    λ = params[1]\n    μ = params[2]\n    λ*tr(ε)*one(ε) + 2*μ*ε\nend\n\n#von-Misses stress for visualization\nfunction σv(σ)\n    J2 = (1/2)*tr(σ⋅σ) - (1/6)*tr(σ)^2\n    sqrt(3*J2)\nend\n\n#Weak form\ndegree = 2*order\ndΩ = GT.quadrature(Ω,degree)\na = (u,v) -> begin\n    GT.∫(dΩ) do x\n        ∇_v = GT.jacobian(v,x)\n        ∇_u = GT.jacobian(u,x)\n        ε_v = GT.external(ε,∇_v)\n        ε_u = GT.external(ε,∇_u)\n        σ_u = GT.external(σ,ε_u,params(x))\n        GT.external(Tensors.dcontract,σ_u,ε_v)\n    end\nend\nl = 0\n\n#Solver phase\nproblem = GT.SciMLBase_LinearProblem(uhd,a,l)\nsolution = LinearSolve.solve(problem)\nuh = GT.solution_field(uhd,solution)\n\n#Prepare figure\nfig = Makie.Figure()\nelevation = 0.4π\nazimuth = -0.5π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\n\n#Visualze the domain warp by the displacement\n#and color by von Misses stress\nwarp_by_vector = uh\nwarp_scale = 30\ncolor = x-> begin\n    ∇_uh = GT.jacobian(uh,x)\n    ε_uh = GT.external(ε,∇_uh)\n    σ_uh = GT.external(σ,ε_uh,params(x))\n    GT.external(σv,σ_uh)\nend\ncolorrange = (0.0,5e8)\nGT.makie_surfaces!(ax,Ω;color,colorrange,warp_by_vector,warp_scale)\n\nFileIO.save(joinpath(@__DIR__,\"fig_linear_elasticity_1.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/example_linear_elasticity/","page":"Linear elasticity","title":"Linear elasticity","text":"","category":"page"},{"location":"src_md/example_linear_elasticity/","page":"Linear elasticity","title":"Linear elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/manual_meshes/#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"A mesh object in GalerkinToolkit contains all geometrical information needed in a finite element (FE) computation. A mesh is a set of polygons (or polytopes in general) which we refer to as faces or d-faces, where d is the face parametric dimension. We call vertices, edges, surfaces, and volumes to faces of 0, 1, 2, and 3 dimensions respectively. Meshes also include additional metadata, including face groups used to identify particular faces in the mesh, e.g., to impose boundary conditions.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"It is worth noting that GalerkinToolkit is not a mesh generation library. The mesh implementation is designed to provide the rich geometrical information needed in FE methods, rather than mesh generation. Meshes are often generated with external tools and then transformed into GalerkinToolkit objects with helper functions such as mesh_from_gmsh.","category":"page"},{"location":"src_md/manual_meshes/#Code-dependencies","page":"Meshes","title":"Code dependencies","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"We use the following dependencies in the code snippets in this page.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"import GalerkinToolkit as GT\nimport GLMakie\nimport Makie\nimport StaticArrays\nimport FileIO # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"In GalerkinToolkit we load dependencies from the Julia standard library with using statements, and from other packages with import statements. The latter forces to qualify functions with the package name, which explicitly reveals their origin. We do not qualify functions from the standard library since they are well known by Julia programmers.","category":"page"},{"location":"src_md/manual_meshes/#Mesh-specification","page":"Meshes","title":"Mesh specification","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"All types implementing meshes are subtypes of AbstractMesh. Important features of a mesh include:","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"A mesh can potentially contain faces with different number of dimensions. I.e., the same mesh object can include vertices, edges, surfaces, and volumes. The number of dimensions of a mesh is the maximum number of dimension of its faces.\nThe number of dimensions of a mesh can be smaller or equal to the number of ambient dimension. The latter is the number of components in a node coordinate vector.\nA mesh might or might not represent a cell complex. However, many algorithms require to work with a cell complex.\nPhysical faces are defined using reference interpolation spaces and node coordinates. A physical face F=varphi(hat F) is defined by transforming a reference face hat F with a mapping varphi hat F rightarrow mathbbR^D, where D is the number of ambient dimensions.  The mapping is defined as varphi(hat x) = sum_i hat s_i(hat x) x_(Fi). Function hat s_i hat F rightarrow mathbbR is the scalar basis function number i in the reference (interpolation) space of F. The vector x_(Fi) contains the coordinates of the local node i in face F.","category":"page"},{"location":"src_md/manual_meshes/#Creating-a-mesh","page":"Meshes","title":"Creating a mesh","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Arbitrary mesh objects are defined from low-level quantities with function create_mesh.","category":"page"},{"location":"src_md/manual_meshes/#GalerkinToolkit.create_mesh-src_md-manual_meshes","page":"Meshes","title":"GalerkinToolkit.create_mesh","text":"create_mesh(;kwargs...)\n\nBuild an arbitrary mesh object.\n\nSee also cartesian_mesh, mesh_from_msh, and mesh_from_gmsh.\n\nLevel\n\nIntermediate\n\nKeyword arguments\n\nnode_coordinates: The vector containing the coordinates of all mesh nodes. node_coordinates[i] is the coordinate vector for global node number i.\nface_nodes: A highly-nested vector containing the node ids for each face in the mesh. node_coordinates[n] with n=face_nodes[d+1][i][k] is the global node coordinate vector for local node number k in face i of dimension d. The object face_nodes[d+1] is a long vector of small vectors of integers. It is often represented using a JaggedArray object that uses continuous linear memory for performance.\nreference_spaces: A nested tuple containing the reference spaces for faces. reference_spaces[d+1][i] is the reference space number i in dimension d. Reference interpolation spaces are defined with functions like lagrange_space.\nface_reference_id [optional]: A nested vector containing which reference space is assigned to each face. reference_sapces[d+1][r] with r=face_reference_id[d+1][i] is the reference space associated with face number i of dimension d. By default, all faces are assigned to the first reference space in its dimension.\ngroup_faces [optional]: A vector of dictionaries containing labeled groups of faces. group_faces[d+1][group_name] is a vector of integers containing the ids  of the faces of dimension d in the group named group_name. These groups might overlap. By default, no faces groups are created.\nis_cell_complex=Val(false) [optional]: Val(true) if the input data represents a cell complex, Val(false) otherwise.\nnormals=nothing [optinal]: Vector containing the normal vectors for the faces of maximum dimension of the mesh. This is relevant for meshes of dimension d embedded in d+1 dimensions as there is no way to tell which should be the orientation of the normals from the other quantities in the mesh.  normals[f] gives the normal vector of face number f of dimension d=length(face_nodes)-1.\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_meshes/#Example","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"In the following example, we generate and visualize a mesh of three first order triangles. Only faces of dimension 2 are present in this example. The arrays for vertices and edges are empty.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Node coordinates\nT = StaticArrays.SVector{2,Float64}\nnode_coordinates = T[(0,0),(1,0),(0,1),(1,1),(2,0)]\n\n#Face nodes\nface_nodes_0 = Vector{Int}[]\nface_nodes_1 = Vector{Int}[]\nface_nodes_2 = [[1,2,3],[2,3,4],[2,4,5]]\nface_nodes = [\n    face_nodes_0,\n    face_nodes_1,\n    face_nodes_2]\n\n#Reference spaces\nreference_spaces_0 = ()\nreference_spaces_1 = ()\norder = 1\ntriangle = GT.unit_simplex(Val(2))\ntriangle3 = GT.lagrange_space(triangle,order)\nreference_spaces_2 = (triangle3,)\nreference_spaces = (\n    reference_spaces_0,\n    reference_spaces_1,\n    reference_spaces_2)\n\n#Create mesh\nmesh = GT.create_mesh(;\n    node_coordinates,\n    face_nodes,\n    reference_spaces)\n\n#Visualize\naxis = (;aspect=Makie.DataAspect())\nshading = Makie.NoShading\nGT.makie_surfaces(mesh;axis,shading)\nGT.makie_edges!(mesh;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_1.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"(Image: )","category":"page"},{"location":"src_md/manual_meshes/#Example-2","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"In this other slightly more complex example, we define a mesh including faces of different dimensions: surfaces, edges and vertices. To be able to see all faces in the visualization, we need to \"shrink\" them. Otherwise, the surfaces would hide the edges and vertices.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Face nodes\nface_nodes_0 = [[1],[3]]\nface_nodes_1 = [[1,2],[2,5],[5,4]]\nface_nodes_2 = [[1,2,3],[2,3,4],[2,4,5]]\nface_nodes = [\n    face_nodes_0,\n    face_nodes_1,\n    face_nodes_2]\n\n#Reference spaces\nvertex = GT.unit_simplex(Val(0))\nvertex1 = GT.lagrange_space(vertex,order)\nsegment = GT.unit_simplex(Val(1))\nsegment2 = GT.lagrange_space(segment,order)\nreference_spaces_0 = (vertex1,)\nreference_spaces_1 = (segment2,)\nreference_spaces_2 = (triangle3,)\nreference_spaces = (\n    reference_spaces_0,\n    reference_spaces_1,\n    reference_spaces_2)\n\n#Create mesh\nmesh = GT.create_mesh(;\n    node_coordinates,\n    face_nodes,\n    reference_spaces)\n\n#Visualize\naxis = (;aspect=Makie.DataAspect())\nshrink = 0.8\nGT.makie_surfaces(mesh;axis,shading,shrink)\nGT.makie_edges!(mesh;dim=1,shrink)\nGT.makie_vertices!(mesh;dim=0)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_2.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"(Image: )","category":"page"},{"location":"src_md/manual_meshes/#Creating-a-chain","page":"Meshes","title":"Creating a chain","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Using function create_mesh might be tedious if all faces are of the same dimension. In this case, we can use the simpler constructor create_chain. It works like create_mesh, but we pass data only for one face dimension. The resulting object is still a mesh object whose type is a subtype of AbstractMesh.","category":"page"},{"location":"src_md/manual_meshes/#GalerkinToolkit.create_chain-src_md-manual_meshes","page":"Meshes","title":"GalerkinToolkit.create_chain","text":"create_chain(;kwargs...)\n\nBuild an arbitrary mesh object, containing all faces of the same dimension. This function is similar to create_mesh but it only receives face arrays of one dimension.\n\nSee also create_mesh.\n\nLevel\n\nIntermediate\n\nKeyword arguments\n\nnode_coordinates: Like for create_mesh.\nface_nodes: A nested vector containing the node ids for each face in the mesh. node_coordinates[n] with n=face_nodes[i][k] is the global node coordinate vector for local node number k in face i. \nreference_spaces: A tuple containing the reference spaces for faces. reference_spaces[i] is the reference space number i.\nface_reference_id [optional]: A vector containing which reference space is assigned to each face. reference_sapces[r] with r=face_reference_id[i] is the reference space associated with face number i. By default, all faces are assigned to the first reference space in its dimension.\ngroup_faces [optional]: A Dictionary containing labeled groups of faces. group_faces[group_name] is a vector of integers containing the ids  of the faces in the group named group_name. These groups might overlap. By default, no faces groups are created.\nnormals=nothing [optinal]: Like for create_mesh.\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_meshes/#Example-3","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"We create the mesh of the first example, but using create_chain.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Face nodes\nface_nodes = [[1,2,3],[2,3,4],[2,4,5]]\n\n#Reference spaces\nreference_spaces = (triangle3,)\n\n#Create mesh\nchain = GT.create_chain(;\n    node_coordinates,\n    face_nodes,\n    reference_spaces)\n\n#Visualize\nGT.makie_surfaces(chain;axis,shading)\nGT.makie_edges!(chain;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_1a.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"(Image: )","category":"page"},{"location":"src_md/manual_meshes/#Accessing-mesh-data","page":"Meshes","title":"Accessing mesh data","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"The underlying data defining a mesh can be accessed with functions listed in the docstring of the type AbstractMesh.","category":"page"},{"location":"src_md/manual_meshes/#GalerkinToolkit.AbstractMesh-src_md-manual_meshes","page":"Meshes","title":"GalerkinToolkit.AbstractMesh","text":"abstract type AbstractMesh <: AbstractType end\n\nAbstract type representing a computational mesh.\n\nLevel\n\nBeginner\n\nConstructors\n\ncreate_mesh\nmesh_from_msh\nmesh_from_gmsh\ncartesian_mesh\ncomplexify\nsimplexify\n\nQueries\n\nnum_dims\nnum_ambient_dims\nnum_codims\nnum_faces\nnum_nodes\nnode_coordinates\nface_nodes\nface_reference_id\nreference_spaces\ngroup_faces\ngroup_names\nis_cell_complex\nnormals\n\n\n\n\n\n","category":"type"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Several of these queries return information for faces of all dimensions present in the mesh. For instance, GT.num_faces(mesh) returns a vector containing the number of faces in each dimension. It is often possible to restrict these queries to a given dimension. The call GT.num_faces(mesh,d) returns an integer with the number of faces of dimension d. When information for all dimensions is returned in a vector, position d+1 in the vector contains the information for dimension d. Remember that the lowest dimension is d=0 for the vertices. In particular, GT.num_faces(mesh,d) == GT.num_faces(mesh)[d+1].","category":"page"},{"location":"src_md/manual_meshes/#Example-4","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Let us get some information from the mesh object we created in the previous example. First, let us get the number of dimensions, number of nodes and number of faces","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"GT.num_dims(mesh)","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"GT.num_nodes(mesh)","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"GT.num_faces(mesh)","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"To get the number of faces in a dimension 2, we do","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"GT.num_faces(mesh,2)","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Similarly we can get the node coordinates and face nodes for faces of dimension 2.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"GT.node_coordinates(mesh)","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"GT.face_nodes(mesh,2)","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"To get the face node ids for all dimensions, we skip the second argument:","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"GT.face_nodes(mesh)","category":"page"},{"location":"src_md/manual_meshes/#Reference-spaces","page":"Meshes","title":"Reference spaces","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Information about the interpolation spaces used to define the mesh physical geometry is available via the function reference_spaces and face_reference_id. Given a mesh object mesh, one accesses the reference space of face number f in dimension d calling ref_space = GT.reference_spaces(mesh,d)[r] with r=GT.face_reference_id(mesh,d). A mesh has typically a small number of reference spaces, and vector GT.face_reference_id(mesh,d) indicates which reference space is assigned to each mesh face. The object ref_space is of a type that implements the AbstractSpace interface. All details about interpolation spaces are given in the section about Interpolation. In particular, we can get some basic information from this space like the number of degrees of freedom (DOFs), and the shape functions.","category":"page"},{"location":"src_md/manual_meshes/#Example-5","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"We manually build the physical map that transforms a reference face into a physical face. We consider face number f=2 in dimension d=1 from the mesh previously defined. We need to get the reference shape functions and the face node coordinates for the given face.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Get data\nd = 1\nf = 2\nr = GT.face_reference_id(mesh,d)[f]\nref_space = GT.reference_spaces(mesh,d)[r]\nlnode_s = GT.shape_functions(ref_space)\nlnode_node = GT.face_nodes(mesh,d)[f]\nnlnodes = length(lnode_node)\nnode_x = GT.node_coordinates(mesh)\n\n#Define the map\nφ = y -> begin\n    sum(1:nlnodes) do lnode\n        s = lnode_s[lnode]\n        x = node_x[lnode_node[lnode]]\n        s(y)*x\n    end\nend\n\n#Apply the map to a given 1-d point\ny = StaticArrays.SVector(0.5,)\nφ(y)","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"The returned value should be the mid point of the edge number 2.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Geting information from a mesh might be tedious for the many array indirection present. To fix this, the library provides iterators to visit the faces of the mesh. These functions are fully explained in Section Iterators. We rewrite this example using an iterator object.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Face iterator\nd = 1\nmesh_faces = GT.each_face(mesh,d)\n\n#Restrict iterator at current face\nface = 2\nmesh_face = mesh_faces[face]\nlnode_s = GT.shape_functions(mesh_face)\nlnode_x = GT.node_coordinates(mesh_face)\n\n#Define the map\nφ = y -> begin\n    sum(1:nlnodes) do lnode\n        s = lnode_s[lnode]\n        x = lnode_x[lnode]\n        s(y)*x\n    end\nend\n\n#Apply the map to a given 1-d point\ny = StaticArrays.SVector(0.5,)\nφ(y)","category":"page"},{"location":"src_md/manual_meshes/#Cell-complexes","page":"Meshes","title":"Cell complexes","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"The mesh object described above is general enough to describe cell or polyhedral complexes, but it is not guaranteed that the mesh is indeed a cell complex. For instance, none of the meshes in the two last examples is a cell complex. The first one has no vertices nor edges. The second one has only few vertices and edges, but many are missing. One can complete a given mesh with all low-dimensional faces needed to be a cell complex with function complexify. Calling is_cell_complex on the returned mesh, will give true.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"For function complexify to work, neighboring faces should share node ids. I.e., duplicated nodes are not allowed in the input mesh. Otherwise, duplicated faces might be generated, or the functions might not work at all.","category":"page"},{"location":"src_md/manual_meshes/#Example-6","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Let us complete the mesh we generated in the last example into a cell complex.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Convert\nmesh2 = GT.complexify(mesh)\n@assert GT.is_cell_complex(mesh2)\n\n#Visualize\nGT.makie_surfaces(mesh2;axis,shading,shrink)\nGT.makie_edges!(mesh2;dim=1,shrink)\nGT.makie_vertices!(mesh2;dim=0)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_3.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"(Image: )","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Note that the mesh contains now all low-dimensional faces.","category":"page"},{"location":"src_md/manual_meshes/#Mesh-topology","page":"Meshes","title":"Mesh topology","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"When a mesh is a cell complex, there are well-defined face incidence relationships. All face incidence relations are stored in an object called mesh topology. A mesh topology is represented by the type AbstractTopology.","category":"page"},{"location":"src_md/manual_meshes/#GalerkinToolkit.AbstractTopology-src_md-manual_meshes","page":"Meshes","title":"GalerkinToolkit.AbstractTopology","text":"abstract type AbstractTopology\n\nAbstract type representing the incidence relations in a cell complex.\n\nLevel\n\nIntermediate\n\nConstructors\n\ntopology\n\nQueries\n\nface_incidence\nface_reference_id\nface_permutation_ids\nreference_topologies\nvertex_permutations\n\n\n\n\n\n","category":"type"},{"location":"src_md/manual_meshes/#Incidence-relations","page":"Meshes","title":"Incidence relations","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"A mesh topology is obtained with function topology called on a given mesh object: topo = GT.topology(mesh). The mesh needs to be a cell complex for this to work.  Then, one uses function face_incidence on the topology object to get the incidence relations. GT.face_incidence(topo,D,d) is a long vector of small vectors of integers, often implemented with a JaggedArray.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"For d<D, GT.face_incidence(topo,D,d)[F] is a vector of integers containing the ids of the faces of dimension d on the boundary of face number F of dimension D.\nFor d<D, GT.face_incidence(topo,d,D)[f] is a vector of integers containing the ids of the faces of dimension D around the face number f of dimension d.\nFor d==D, GT.face_incidence(topo,D,D)[F] == [F].","category":"page"},{"location":"src_md/manual_meshes/#Example-7","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Let us get some of the incidence relations for the cell complex we generated above.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"topo = GT.topology(mesh2)\nsurface_to_edges = GT.face_incidence(topo,2,1)","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"This output is read as follows. Surface 1 has edges 1, 4, and 5 on its boundary; surface 2 has edges 5, 6, 7 on its boundary; etc.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"edge_to_surfaces = GT.face_incidence(topo,1,2)","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"According to this output, edge 1 touches surface 1, edge 2 touches surface 3, etc. We can also see that there are two interior edges touching two surfaces. Edge 5 touches surfaces 1 and 2, and edge 6 touches surfaces 2 and 3.","category":"page"},{"location":"src_md/manual_meshes/#Reference-topologies","page":"Meshes","title":"Reference topologies","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"The reference faces in a mesh are also cell complexes. For instance, a reference volume has surfaces, edges, and vertices on its boundary. The incidence relation between the faces in a reference face are obtained using  a reference topology. Reference topologies are accessed with function reference_topologies given a topology object.","category":"page"},{"location":"src_md/manual_meshes/#GalerkinToolkit.reference_topologies-src_md-manual_meshes","page":"Meshes","title":"GalerkinToolkit.reference_topologies","text":"reference_topologies(topo)\nreference_topologies(topo,d)\nreference_topologies(topo,Val(d))\n\nReturn the list (a vector or a tuple) of reference topologies in topo of dimension d. If the second argument is omitted, then the function returns a collection such that reference_topologies(topo)[d+1] is equivalent to reference_topologies(topo,Val(d)).\n\nThe face reference topology of face f of dimension d, is accessed as reference_topologies(topo,d)[r] with r=face_reference_id(topo,d)[f].\n\nSee also face_reference_id.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"The rationale behind accessing reference topologies is analogous to accessing reference spaces in a mesh. Note, however, that the face reference ids in  a mesh mesh, GT.face_reference_id(mesh,d) might be different from the ones in the corresponding mesh topology topo, GT.face_reference_id(topo,d), since different interpolation spaces can be defined on the same reference face (e.g., in p-adaptive methods).","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"A reference topology object behaves like any other topology object and can be queried with the methods from the AbstractTopology interface.","category":"page"},{"location":"src_md/manual_meshes/#Example-8","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"We get the reference topology of the first 2-face of the previously generated topology, which corresponds to a reference triangle. Then, we show the incidence relation between edges and vertices, i.e., for each edge which are the vertices on its boundary.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Get the reference topology\nf = 1\nr = GT.face_reference_id(topo,2)[f]\nref_topo = GT.reference_topologies(topo,2)[r]\n\n#See the edge to vertex relations\nedge_to_vertices = GT.face_incidence(ref_topo,1,0)","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"The first edge goes from vertex 1 to 2, the second edge from vertex 1 to 3, and the third edge from vertex 2 to 3.","category":"page"},{"location":"src_md/manual_meshes/#Permutations","page":"Meshes","title":"Permutations","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"If a mesh is a cell complex, each face in the boundary of a face is also explicitly contained in the mesh. However, the incidence relations of these two faces are the same but might be stored in different order.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Let us consider a topology  object topo and two integers d<D. We get the incident relations D_d = GT.face_incidence(topo,D,d), d_0 = GT.face_incidence(topo,d,0) and D_0 = GT.face_incidence(topo,D,0). Consider face number v in dimension D. The d-faces on its boundary are given in vector D_d[v]. Consider the integer in l position in this list, namely s=D_d[v][l]. s is the id of a face of dimension d. The 0-faces on the boundary of v are  in D_0[v] and on the boundary of s are in d_0[s].  Now, consider the reference topology of face v, namely ref_topo_v. We get this incidence relation from the reference topology: ref_d_0 = GT.face_incidence(ref_topo_v,d,0). This gives us an alternative way of obtaining the 0-faces of s, namely D_0[v][ref_d_0[l]]. That is, we can take the id s and compute directly d_0[s], or we can go to the neighbor face v and compute D_0[v][ref_d_0[l]] using the local id l corresponding to s in v. The vectors d_0[s] and  D_0[v][ref_d_0[l]] contain the same vertex ids, but not in the same order!","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"To fix this issue, we provide the permutation P that transforms one vector into the other, namely d_0[s][P] == D_0[v][ref_d_0[l]]. For d==1, the permutation vector P is either [1,2] or [2,1] since an edge has two vertices. In general, the possible permutations are enumerated and stored in the reference topology associated with face s, namely ref_topo_s. They are accessed with function vertex_permutations in this way: k_P = GT.vertex_permutations(ref_topo_s). This is a vector of vectors containing all permutations. To get the permutation P from this list, we use function face_permutation_ids. First we get an index into the list of permutations with k=GT.face_permutation_ids(topo,D,0)[v][l] and using the index k, we get the permutation from the list P = k_P[k].","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"This information is needed in many situations, including the generation of high-order interpolation spaces and integration of jump and average terms on interior faces in discontinuous Galerkin methods.","category":"page"},{"location":"src_md/manual_meshes/#Face-groups","page":"Meshes","title":"Face groups","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Face groups allow us to select specific faces in a mesh for different modeling purposes: impose boundary conditions, define different equations in different parts of the mesh etc. A face group is a vector of integers containing the ids of the faces in this group plus a string containing a name for this group. This groups are stored using a dictionary that maps strings to vectors (group names to group definitions) in a per dimension basis (one dictionary per dimension). The vector contains faces of the same dimension, but it is possible define groups containing faces of different dimensions by splitting them in a vector per dimension. Face groups can overlap and can be added after the mesh object is created.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Face groups are accessed and added using the function group_faces.","category":"page"},{"location":"src_md/manual_meshes/#GalerkinToolkit.group_faces-src_md-manual_meshes","page":"Meshes","title":"GalerkinToolkit.group_faces","text":"group_faces(mesh)\ngroup_faces(mesh,d)\n\nReturn the dictionary containing the faces in each group in dimension d. If d is omitted, it returns the dictionaries for all dimensions in a vector. I.e., calling group_faces(mesh,d) is equivalent to group_faces(mesh)[d+1].\n\nThe faces of dimension d in group group are group_faces(mesh,d)[group_name], where group_name is a string with the group name. One can create new groups by adding new keys to these dictionaries as long as the key is not already present. Calling group_faces(mesh,d)[new_group_name] = faces_in_newgroup will add a new group to dimension d with name equal to the string new_group_name with faces in vector faces_in_newgroup.\n\nSee also group_names.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_meshes/#Common-face-groups","page":"Meshes","title":"Common face groups","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"GalerkinToolkit provides a number of functions that generate commonly used face groups.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"group_boundary_faces!\ngroup_interior_faces!\ngroup_faces_in_dim!","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"These functions do what the name suggests (see the docstrings for further details). The first one is often used to impose boundary conditions and the second one in discontinuous Galerkin methods to define interior penalty terms. They are often called under the hood when calling functions like boundary and skeleton.","category":"page"},{"location":"src_md/manual_meshes/#Example-9","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Let us add some face groups to the last mesh we created. We add a group for the boundary edges, for the interior edges, and a group for the two first surfaces.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"GT.group_boundary_faces!(mesh2;group_name=\"boundary\")\nGT.group_interior_faces!(mesh2;group_name=\"interior\")\nGT.group_faces(mesh2,2)[\"foo\"] = [1,2]\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"We can also visualize the faces with colors telling if a face belongs to a group or not. We can visualize the mesh faces labeled as \"boundary\" in orange color, and the rest in blue:","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"color = GT.FaceColor(\"boundary\")\nblue = Makie.wong_colors()[1]\norange = Makie.wong_colors()[2]\ncolormap = [blue,orange]\nGT.makie_surfaces(mesh2;axis,shrink,shading,color,colormap)\nGT.makie_edges!(mesh2;dim=1,shrink,color,colormap)\nGT.makie_vertices!(mesh2;dim=0,color,colormap)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_4.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"(Image: )","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Idem, but now visualizing the group \"foo\".","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"color = GT.FaceColor(\"foo\")\nGT.makie_surfaces(mesh2;axis,shrink,shading,color,colormap)\nGT.makie_edges!(mesh2;dim=1,shrink,color,colormap)\nGT.makie_vertices!(mesh2;dim=0,color,colormap)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_5.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"(Image: )","category":"page"},{"location":"src_md/manual_meshes/#Gmsh-meshes","page":"Meshes","title":"Gmsh meshes","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Meshes generated with gmsh can be transformed into GalerkinToolkit mesh objects using functions mesh_from_gmsh and mesh_from_msh. The physical groups defined within gmsh will be transformed into face groups in the GalerkinToolkit mesh, which is useful to impose boundary conditions. We use Gmsh.jl under the hood as the wrapper to the Julia API of gmsh.","category":"page"},{"location":"src_md/manual_meshes/#A-mesh-from-a-msh-file","page":"Meshes","title":"A mesh from a msh file","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Function mesh_from_msh reads and crates a mesh object from a .msh file (the default format used by gmsh to export meshes).","category":"page"},{"location":"src_md/manual_meshes/#GalerkinToolkit.mesh_from_msh-src_md-manual_meshes","page":"Meshes","title":"GalerkinToolkit.mesh_from_msh","text":"mesh_from_msh(msh_file;kwargs...)\n\nCreate a mesh object from a .msh file found in path msh_file.\n\nSee also mesh_from_gmsh and with_gmsh.\n\nKeyword arguments\n\ncomplexify=true [optional]: If complexify==true, the mesh will be completed with all low dimensional faces into a cell complex.\nrenumber=true [optional]: If renumber==true, then gmsh.model.mesh.renumberNodes() and gmsh.model.mesh.renumberElements() will be called.\nAny other keyword argument will be passed to function with_gmsh.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_meshes/#Example-10","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"We create a mesh from a .msh file and visualize it. In this case, we only visualize the 2-faces in the mesh. We color them according to the face group named \"sides\". Faces in the group are visualized in orange and other faces in blue. This face group is only defined for 2-faces. If you visualize the 3-faces (as by default), you would not see this face group.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Read the mesh\nassets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"model.msh\")\nmesh = GT.mesh_from_msh(msh_file)\n\n#Visualize it\nfig = Makie.Figure()\nax = Makie.Axis3(fig[1,1];aspect=:data)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\ncolor = GT.FaceColor(\"sides\")\nGT.makie_surfaces!(mesh;dim=2,color,colormap)\nGT.makie_edges!(mesh;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_6.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"(Image: )","category":"page"},{"location":"src_md/manual_meshes/#Meshes-from-the-gmsh-API","page":"Meshes","title":"Meshes from the gmsh API","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"It is also possible to generate meshes in Julia code using the gmsh API and then convert them to GalerkinToolkit objects. This is done with two functions: See also with_gmsh and mesh_from_gmsh.","category":"page"},{"location":"src_md/manual_meshes/#GalerkinToolkit.with_gmsh-src_md-manual_meshes","page":"Meshes","title":"GalerkinToolkit.with_gmsh","text":"with_gmsh(f[;options])\n\nA safe way of initialize and finalize the gmsh module. The given function is called f(gmsh) on the gmsh module after is has been initialized. The module is finalized automatically when the function returns.\n\nThe optional keyword argument options is a vector for pairs k=>v containing gmesh options. Each of these options are set with gmsh.option.setNumber(k,v) just after gmsh has been initialized.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_meshes/#GalerkinToolkit.mesh_from_gmsh-src_md-manual_meshes","page":"Meshes","title":"GalerkinToolkit.mesh_from_gmsh","text":"mesh_from_gmsh(gmsh::Module;complexify=true)\n\nCreate a mesh objects from the current state of the gmsh module. If complexify==true, the mesh will be completed with all low dimensional faces into a cell complex.\n\nSee also mesh_from_msh and with_gmsh.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_meshes/#Example-11","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"We generate a simple 2d mesh with the gmsh Julia API.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Generate mesh with GMSH Julia API\nmesh = GT.with_gmsh() do gmsh\n    mesh_size=0.04\n    T=2\n    N=100\n    R = 0.15\n    dim = 2\n    gmsh.option.set_number(\"General.Verbosity\", 2)\n    rect_tag = gmsh.model.occ.add_rectangle(0,0,0,1,1)\n    circle_tag = gmsh.model.occ.add_circle(0.5,0.5,0,R)\n    circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])\n    circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])\n    gmsh.model.occ.cut([(dim,rect_tag)],[(dim,circle_surf_tag)]);\n    gmsh.model.occ.synchronize()\n    domain_tags = [1]\n    outer_tags = [6,7,8,9]\n    inner_tags = [5]\n    gmsh.model.model.add_physical_group(dim,domain_tags,-1,\"domain\")\n    gmsh.model.model.add_physical_group(dim-1,outer_tags,-1,\"outer\")\n    gmsh.model.model.add_physical_group(dim-1,inner_tags,-1,\"inner\")\n    gmsh.option.set_number(\"Mesh.MeshSizeMax\",mesh_size)\n    gmsh.model.mesh.generate(dim)\n    #Transform it to a mesh object\n    GT.mesh_from_gmsh(gmsh)\nend\n\n#Visualize\nfig = Makie.Figure()\nax,sc = GT.makie_surfaces(fig[1,1],mesh;axis,shading)\nGT.makie_edges!(mesh;color=:black)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_7.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"(Image: )","category":"page"},{"location":"src_md/manual_meshes/#Cartesian-meshes","page":"Meshes","title":"Cartesian meshes","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"GalerkinToolkit comes with a built-in Cartesian mesh generator implemented in function cartesian_mesh.","category":"page"},{"location":"src_md/manual_meshes/#GalerkinToolkit.cartesian_mesh","page":"Meshes","title":"GalerkinToolkit.cartesian_mesh","text":"cartesian_mesh(domain,cells_per_dir)\n\nCreate a multi-dimensional Cartesian mesh. The dimension of the mesh is defined by the length of cells_per_dir. The number of cells in direction i is given by cells_per_dir[i]. The extends of the Cartesian mesh are given in domain. The range in direction i covered by the mesh is given by domain[2*i-1,2*i].\n\nKeyword arguments\n\nboundary=true [optional]: Include faces on the boundary and generate face groups identifying which faces are  on which face of  bounding box of the mesh. The groups are named $d-face-$i for the face i of dimension d of the bounding box.\ncomplexify=true [optional]: Generate all low dimensional faces so that the mesh is  a cell complex.\nsimplexify=false [optional]: Generate a mesh of simplex faces instead of hyper-cubes.\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_meshes/#Example-12","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Generate a 3D Cartesian mesh  of the box (01)times(-11)times(34) with 10, 20 , and 10 cells in each axis.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Create mesh\ndomain = (0,1,-1,1,3,4)\ncells = (10,20,10)\nmesh = GT.cartesian_mesh(domain,cells)\n\n#Visualize it\nGT.makie_surfaces(mesh;axis=(;aspect=:data))\nGT.makie_edges!(mesh;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_8.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"(Image: )","category":"page"},{"location":"src_md/manual_meshes/#Example-13","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Create a mesh with the same geometry as before, but using simplex cells instead. We also manually add a face group named \"foo\" containing all volumes to the left of the plain y=0. To build this group, we check if the cell mid point is on the left of the plain. This example also shows how to use accessors to compute the midpoint of each volume in the mesh.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Create mesh\ndomain = (0,1,-1,1,3,4)\ncells = (10,20,10)\nmesh = GT.cartesian_mesh(domain,cells;simplexify=true)\n\n#Find faces in new group\nmesh_faces = GT.each_face(mesh)\nnew_group_faces = findall(mesh_faces) do mesh_face\n    lnode_x = GT.node_coordinates(mesh_face)\n    xm = sum(lnode_x) / length(lnode_x)\n    xm[2] < 0\nend\n\n#Add new group to mesh\nd = GT.num_dims(mesh)\nGT.group_faces(mesh,d)[\"foo\"] = new_group_faces\n\n#Visualize\ncolor = GT.FaceColor(\"foo\")\nGT.makie_surfaces(mesh;color,colormap,axis=(;aspect=:data))\nGT.makie_edges!(mesh;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_9.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"(Image: )","category":"page"},{"location":"src_md/manual_meshes/#Example-14","page":"Meshes","title":"Example","text":"","category":"section"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Create a coarse cartesian mesh of the unit square with 4 and 4 cells in each axis. Visualize faces in all dimensions, shrinking them to avoid overlaps.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Generate mesh\ndomain = (0,1,0,1)\ncells = (4,4)\nmesh = GT.cartesian_mesh(domain,cells)\n\n#Visualize it\nGT.makie_surfaces(mesh;axis,shading,shrink)\nGT.makie_edges!(mesh;dim=1,shrink)\nGT.makie_vertices!(mesh;dim=0)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_10.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"(Image: )","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"Now, the same as before, but only generate low-dimensional faces on the boundary.","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"#Generate mesh\ndomain = (0,1,0,1)\ncells = (4,4)\nmesh = GT.cartesian_mesh(domain,cells;complexify=false)\n\n#Visualize it\nGT.makie_surfaces(mesh;axis,shading,shrink)\nGT.makie_edges!(mesh;dim=1,shrink)\nGT.makie_vertices!(mesh;dim=0)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_11.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"(Image: )","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"","category":"page"},{"location":"src_md/manual_meshes/","page":"Meshes","title":"Meshes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#API","page":"API","title":"API","text":"","category":"section"},{"location":"reference/#GalerkinToolkit.AbstractDomain","page":"API","title":"GalerkinToolkit.AbstractDomain","text":"abstract type AbstractDomain <: AbstractType end\n\nAbstract type representing a subset of mathbbR^d, typically din0123. Domains are defined using an underlying computational mesh. See also AbstractMesh.\n\nLevel\n\nBeginner\n\nBasic constructors\n\nunit_simplex\nunit_n_cube\ndomain\ninterior\nboundary\nskeleton\n\nBasic queries\n\nnum_dims\nnum_ambient_dims\nnum_codims\nis_axis_aligned\nis_simplex\nis_n_cube\nis_unit_n_cube\nis_unit_simplex\nis_unitary\nbounding_box\nvertex_permutations\nmesh\nfaces\ninverse_faces\noptions\nis_boundary\nface_around\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceDomain","page":"API","title":"GalerkinToolkit.AbstractFaceDomain","text":"abstract type AbstractFaceDomain <: AbstractDomain end\n\nA domain defined on a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\nBasic constructors\n\nunit_simplex\nunit_n_cube\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceSpace","page":"API","title":"GalerkinToolkit.AbstractFaceSpace","text":"abstract type AbstractFaceSpace <: AbstractSpace end\n\nLike AbstractSpace, but for a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceTopology","page":"API","title":"GalerkinToolkit.AbstractFaceTopology","text":"abstract type AbstractFaceTopology <: AbstractTopology end\n\nLike AbstractTopology, but for a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractMesh","page":"API","title":"GalerkinToolkit.AbstractMesh","text":"abstract type AbstractMesh <: AbstractType end\n\nAbstract type representing a computational mesh.\n\nLevel\n\nBeginner\n\nConstructors\n\ncreate_mesh\nmesh_from_msh\nmesh_from_gmsh\ncartesian_mesh\ncomplexify\nsimplexify\n\nQueries\n\nnum_dims\nnum_ambient_dims\nnum_codims\nnum_faces\nnum_nodes\nnode_coordinates\nface_nodes\nface_reference_id\nreference_spaces\ngroup_faces\ngroup_names\nis_cell_complex\nnormals\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractMeshDomain","page":"API","title":"GalerkinToolkit.AbstractMeshDomain","text":"abstract type AbstractMeshDomain <: AbstractDomain end\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractQuadrature","page":"API","title":"GalerkinToolkit.AbstractQuadrature","text":"abstract type AbstractQuadrature\n\nBasic queries\n\ndomain\ncoordinates\nweights\nnum_points\nface_reference_id\nreference_quadratures\n\nBasic constructors\n\nquadrature\nduffy_quadrature\ntensor_product_quadrature\nnode_quadrature\n\nSupertype hierarchy\n\nAbstractQuadrature <: GT.AbstractType\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractSpace","page":"API","title":"GalerkinToolkit.AbstractSpace","text":"abstract type AbstractSpace <: AbstractType end\n\nAbstract type representing a finite element space.\n\nLevel\n\nBasic\n\nBasic constructors\n\nlagrange_space raviart_thomas_space\n\nBasic queries\n\ndomain\nnum_dofs\nface_dofs\nface_nodes\nface_reference_id\nreference_spaces\ngeometry_own_dofs\ngeometry_own_dofs_permutations\n\nAdditional queries\n\nFor spaces, used as reference spaces in AbstractMesh specializations.\n\nnum_nodes\ninterior_nodes\ninterior_nodes_permutations\ngeometry_interior_nodes\ngeometry_interior_nodes_permutations\ngeometry_nodes\ngeometry_nodes_permutations\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractTopology","page":"API","title":"GalerkinToolkit.AbstractTopology","text":"abstract type AbstractTopology\n\nAbstract type representing the incidence relations in a cell complex.\n\nLevel\n\nIntermediate\n\nConstructors\n\ntopology\n\nQueries\n\nface_incidence\nface_reference_id\nface_permutation_ids\nreference_topologies\nvertex_permutations\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractType","page":"API","title":"GalerkinToolkit.AbstractType","text":"abstract type AbstractType end\n\nParent of all types defined in GalerkinToolkit.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.Options","page":"API","title":"GalerkinToolkit.Options","text":"struct Options{...} <: AbstractType\n\nType of the objects returned by function options. All properties and type parameters are private.\n\nBasic queries\n\nreference_int_type\nint_type\nglobal_int_type\nreal_type\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.UnitNCube","page":"API","title":"GalerkinToolkit.UnitNCube","text":"struct UnitNCube{...} <: AbstractFaceDomain\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.UnitSimplex","page":"API","title":"GalerkinToolkit.UnitSimplex","text":"struct UnitSimplex{...} <: AbstractFaceDomain\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.ast_hoist!-Tuple{Any}","page":"API","title":"GalerkinToolkit.ast_hoist!","text":"ast_hoist!(ast)\n\nHoist loop invariant definitions in ast. The new AST is overwritten in ast.\n\nHypotheses:\n\nThe root of the AST is a code block.\nThe code block contains only for-loops, function calls, array indexing, definitions, and increments. No while loops, if statements, lambdas, etc.\nFunctions that appear in a rhs of a definition are pure functions.\nRHSs contain a function call at most.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.ast_lhs_indices-Tuple{Any}","page":"API","title":"GalerkinToolkit.ast_lhs_indices","text":"ast_lhs_indices(ast)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.boundary","page":"API","title":"GalerkinToolkit.boundary","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.bounding_box","page":"API","title":"GalerkinToolkit.bounding_box","text":"p0,p1 = bounding_box(x)\n\nReturn a tuple of two vectors, where the vectors p0 and p1 define the span of the bounding box of x.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.cartesian_mesh-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.cartesian_mesh","text":"cartesian_mesh(domain,cells_per_dir)\n\nCreate a multi-dimensional Cartesian mesh. The dimension of the mesh is defined by the length of cells_per_dir. The number of cells in direction i is given by cells_per_dir[i]. The extends of the Cartesian mesh are given in domain. The range in direction i covered by the mesh is given by domain[2*i-1,2*i].\n\nKeyword arguments\n\nboundary=true [optional]: Include faces on the boundary and generate face groups identifying which faces are  on which face of  bounding box of the mesh. The groups are named $d-face-$i for the face i of dimension d of the bounding box.\ncomplexify=true [optional]: Generate all low dimensional faces so that the mesh is  a cell complex.\nsimplexify=false [optional]: Generate a mesh of simplex faces instead of hyper-cubes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.complexify","page":"API","title":"GalerkinToolkit.complexify","text":"complexify(x)\n\nConvert x into a mesh representing a cell complex.\n\nSee also is_cell_complex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.coordinates","page":"API","title":"GalerkinToolkit.coordinates","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.create_chain-Tuple{}","page":"API","title":"GalerkinToolkit.create_chain","text":"create_chain(;kwargs...)\n\nBuild an arbitrary mesh object, containing all faces of the same dimension. This function is similar to create_mesh but it only receives face arrays of one dimension.\n\nSee also create_mesh.\n\nLevel\n\nIntermediate\n\nKeyword arguments\n\nnode_coordinates: Like for create_mesh.\nface_nodes: A nested vector containing the node ids for each face in the mesh. node_coordinates[n] with n=face_nodes[i][k] is the global node coordinate vector for local node number k in face i. \nreference_spaces: A tuple containing the reference spaces for faces. reference_spaces[i] is the reference space number i.\nface_reference_id [optional]: A vector containing which reference space is assigned to each face. reference_sapces[r] with r=face_reference_id[i] is the reference space associated with face number i. By default, all faces are assigned to the first reference space in its dimension.\ngroup_faces [optional]: A Dictionary containing labeled groups of faces. group_faces[group_name] is a vector of integers containing the ids  of the faces in the group named group_name. These groups might overlap. By default, no faces groups are created.\nnormals=nothing [optinal]: Like for create_mesh.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.create_mesh","page":"API","title":"GalerkinToolkit.create_mesh","text":"create_mesh(;kwargs...)\n\nBuild an arbitrary mesh object.\n\nSee also cartesian_mesh, mesh_from_msh, and mesh_from_gmsh.\n\nLevel\n\nIntermediate\n\nKeyword arguments\n\nnode_coordinates: The vector containing the coordinates of all mesh nodes. node_coordinates[i] is the coordinate vector for global node number i.\nface_nodes: A highly-nested vector containing the node ids for each face in the mesh. node_coordinates[n] with n=face_nodes[d+1][i][k] is the global node coordinate vector for local node number k in face i of dimension d. The object face_nodes[d+1] is a long vector of small vectors of integers. It is often represented using a JaggedArray object that uses continuous linear memory for performance.\nreference_spaces: A nested tuple containing the reference spaces for faces. reference_spaces[d+1][i] is the reference space number i in dimension d. Reference interpolation spaces are defined with functions like lagrange_space.\nface_reference_id [optional]: A nested vector containing which reference space is assigned to each face. reference_sapces[d+1][r] with r=face_reference_id[d+1][i] is the reference space associated with face number i of dimension d. By default, all faces are assigned to the first reference space in its dimension.\ngroup_faces [optional]: A vector of dictionaries containing labeled groups of faces. group_faces[d+1][group_name] is a vector of integers containing the ids  of the faces of dimension d in the group named group_name. These groups might overlap. By default, no faces groups are created.\nis_cell_complex=Val(false) [optional]: Val(true) if the input data represents a cell complex, Val(false) otherwise.\nnormals=nothing [optinal]: Vector containing the normal vectors for the faces of maximum dimension of the mesh. This is relevant for meshes of dimension d embedded in d+1 dimensions as there is no way to tell which should be the orientation of the normals from the other quantities in the mesh.  normals[f] gives the normal vector of face number f of dimension d=length(face_nodes)-1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.domain","page":"API","title":"GalerkinToolkit.domain","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.domain-Tuple{GalerkinToolkit.AbstractMesh, Any}","page":"API","title":"GalerkinToolkit.domain","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.duffy_quadrature-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.duffy_quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.face_around","page":"API","title":"GalerkinToolkit.face_around","text":"face_around(x)\n\nReturn an integer that allows to break ties when faces in x need to point to faces around of one dimension higher. Return nothing if x does not break such ties.\n\nNote: This function will eventually return a vector of integers.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_dofs","page":"API","title":"GalerkinToolkit.face_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_incidence","page":"API","title":"GalerkinToolkit.face_incidence","text":"face_incidence(x,d)\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_nodes","page":"API","title":"GalerkinToolkit.face_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_permutation_ids","page":"API","title":"GalerkinToolkit.face_permutation_ids","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_reference_id","page":"API","title":"GalerkinToolkit.face_reference_id","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.faces","page":"API","title":"GalerkinToolkit.faces","text":"faces(x)\n\nReturn the subset of face ids in mesh(x) of dimension num_dims(x) defining the domain x. This is effectively the map from domain face id to mesh face id.\n\nSee also inverse_faces.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometries","page":"API","title":"GalerkinToolkit.geometries","text":"geometries(x,d)\ngeometries(x,Val(d))\n\nReturn a vector of domains representing the geometrical entities of x of dimension d. The returned domains and x are defined on the same mesh. That is, faces(geometries(x,1)[2]) are the face ids in mesh(x) representing the second edge of x.\n\nNotation\n\ngeometries(x,Val(0)) are referred to as the vertices of x. geometries(x,Val(1)) are referred to as the edges of x. geometries(x,Val(d)) are referred to as the d-faces of x.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_interior_nodes","page":"API","title":"GalerkinToolkit.geometry_interior_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_interior_nodes_permutations","page":"API","title":"GalerkinToolkit.geometry_interior_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_nodes","page":"API","title":"GalerkinToolkit.geometry_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_nodes_permutations","page":"API","title":"GalerkinToolkit.geometry_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_own_dofs","page":"API","title":"GalerkinToolkit.geometry_own_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_own_dofs_permutations","page":"API","title":"GalerkinToolkit.geometry_own_dofs_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.global_int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.global_int_type","text":"global_int_type(options::Options)\n\nReturn the type of the integers used to enumerate global quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.group_boundary_faces!","page":"API","title":"GalerkinToolkit.group_boundary_faces!","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.group_faces","page":"API","title":"GalerkinToolkit.group_faces","text":"group_faces(mesh)\ngroup_faces(mesh,d)\n\nReturn the dictionary containing the faces in each group in dimension d. If d is omitted, it returns the dictionaries for all dimensions in a vector. I.e., calling group_faces(mesh,d) is equivalent to group_faces(mesh)[d+1].\n\nThe faces of dimension d in group group are group_faces(mesh,d)[group_name], where group_name is a string with the group name. One can create new groups by adding new keys to these dictionaries as long as the key is not already present. Calling group_faces(mesh,d)[new_group_name] = faces_in_newgroup will add a new group to dimension d with name equal to the string new_group_name with faces in vector faces_in_newgroup.\n\nSee also group_names.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.group_faces_in_dim!","page":"API","title":"GalerkinToolkit.group_faces_in_dim!","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.group_interior_faces!","page":"API","title":"GalerkinToolkit.group_interior_faces!","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.group_names","page":"API","title":"GalerkinToolkit.group_names","text":"group_names(mesh)\ngroup_names(mesh,d)\n\nReturn the names of the groups in dimension d. Calling group_names(mesh,d) is equivalent to group_names(mesh)[d+1].\n\nSee also group_faces.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.int_type","text":"int_type(options::Options)\n\nReturn the default integer type used in the computation except for reference and global quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.interior","page":"API","title":"GalerkinToolkit.interior","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.interior_node_permutations-Tuple{GalerkinToolkit.LagrangeFaceSpace}","page":"API","title":"GalerkinToolkit.interior_node_permutations","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.interior_nodes","page":"API","title":"GalerkinToolkit.interior_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.interior_nodes_permutations","page":"API","title":"GalerkinToolkit.interior_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.inverse_faces","page":"API","title":"GalerkinToolkit.inverse_faces","text":"inverse_faces(x)\n\nReturn the inverse integer mas of faces(x). This is effectively the map from mesh face id to domain face id. Mesh faces not present in the domain, receive an invalid index id.\n\nSee also faces.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_axis_aligned","page":"API","title":"GalerkinToolkit.is_axis_aligned","text":"is_axis_aligned(x)\n\nTrue if x is a unit simplex or a unit cube.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_boundary","page":"API","title":"GalerkinToolkit.is_boundary","text":"is_boundary(x)\n\nTrue if x represent an (internal) boundary. Faces in an internal boundary \"point\" to only of the two faces around of a dimension higher.\n\nSee also face_around.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_cell_complex","page":"API","title":"GalerkinToolkit.is_cell_complex","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_n_cube","page":"API","title":"GalerkinToolkit.is_n_cube","text":"is_n_cube(x)\n\nTrue if x is a n-cube (hypercube).\n\nSee also is_simplex, is_unit_simplex, is_unit_n_cube.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_simplex","page":"API","title":"GalerkinToolkit.is_simplex","text":"is_simplex(x)\n\nTrue if x is a simplex.\n\nSee also is_n_cube, is_unit_simplex, is_unit_n_cube.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unit_n_cube","page":"API","title":"GalerkinToolkit.is_unit_n_cube","text":"is_unit_n_cube(x)\n\nTrue if x is a unit n-cube.\n\nSee also is_n_cube, is_unit_simplex, is_simplex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unit_simplex","page":"API","title":"GalerkinToolkit.is_unit_simplex","text":"is_unit_simplex(x)\n\nTrue if x is a unit simplex.\n\nSee also is_n_cube, is_unit_n_cube, is_simplex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unitary","page":"API","title":"GalerkinToolkit.is_unitary","text":"is_unitary(x)\n\nTrue bounding_box(x) coincides with a unit n-cube.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.lagrange_space","page":"API","title":"GalerkinToolkit.lagrange_space","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.mesh-Tuple{GalerkinToolkit.Chain}","page":"API","title":"GalerkinToolkit.mesh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_gmsh-Tuple{Module}","page":"API","title":"GalerkinToolkit.mesh_from_gmsh","text":"mesh_from_gmsh(gmsh::Module;complexify=true)\n\nCreate a mesh objects from the current state of the gmsh module. If complexify==true, the mesh will be completed with all low dimensional faces into a cell complex.\n\nSee also mesh_from_msh and with_gmsh.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_msh-Tuple{Any}","page":"API","title":"GalerkinToolkit.mesh_from_msh","text":"mesh_from_msh(msh_file;kwargs...)\n\nCreate a mesh object from a .msh file found in path msh_file.\n\nSee also mesh_from_gmsh and with_gmsh.\n\nKeyword arguments\n\ncomplexify=true [optional]: If complexify==true, the mesh will be completed with all low dimensional faces into a cell complex.\nrenumber=true [optional]: If renumber==true, then gmsh.model.mesh.renumberNodes() and gmsh.model.mesh.renumberElements() will be called.\nAny other keyword argument will be passed to function with_gmsh.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_space","page":"API","title":"GalerkinToolkit.mesh_from_space","text":"mesh_from_space(space)\n\nReturn the mesh induced by space. For instance, a (high order) Lagrange space can be interpreted as a mesh using this function.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.node_coordinates","page":"API","title":"GalerkinToolkit.node_coordinates","text":"node_coordinates(x)\n\nReturn the vector of node coordinates associated with `x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.node_permutations-Tuple{GalerkinToolkit.LagrangeFaceSpace}","page":"API","title":"GalerkinToolkit.node_permutations","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.node_quadrature","page":"API","title":"GalerkinToolkit.node_quadrature","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.normals","page":"API","title":"GalerkinToolkit.normals","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_ambient_dims","page":"API","title":"GalerkinToolkit.num_ambient_dims","text":"num_ambient_dims(x)\n\nReturn the ambient dimension where object x lives.\n\nSee also num_codims, num_dims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_codims","page":"API","title":"GalerkinToolkit.num_codims","text":"num_codims(x)\n\nReturn num_ambient_dims(x)-num_dims(x).\n\nSee also num_ambient_dims, num_dims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_dims","page":"API","title":"GalerkinToolkit.num_dims","text":"num_dims(x)\n\nReturn the parametric dimension of x.\n\nSee also num_ambient_dims, num_codims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_dofs","page":"API","title":"GalerkinToolkit.num_dofs","text":"num_dofs(x)\n\nReturn the number of degrees of freedom of x.\n\nSee also num_nodes.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_faces","page":"API","title":"GalerkinToolkit.num_faces","text":"num_faces(x)\nnum_faces(x,d)\n\nReturn the number of faces  of dimension d in mesh(x). If d is omitted, return a vector with the number of faces in each dimension, starting from dimension 0 up to num_dims(x).\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_nodes","page":"API","title":"GalerkinToolkit.num_nodes","text":"num_nodes(x)\n\nReturn the number of nodes of x.\n\nSee also num_dofs.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_points","page":"API","title":"GalerkinToolkit.num_points","text":"num_points(x)\n\nReturn the number of integration points in x.\n\nSee also num_nodes.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.options-Tuple{}","page":"API","title":"GalerkinToolkit.options","text":"options(;kwargs...) -> Options\n\nCreate an object representing the default options for the current simulation. This object can be used as an optional argument in several object constructors in GalerkinToolkit, such as the mesh constructors cartesian_mesh and mesh_from_msh. In this case, the computations using the generated mesh, will use the given options by default.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.periodic_nodes","page":"API","title":"GalerkinToolkit.periodic_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.push","page":"API","title":"GalerkinToolkit.push","text":"push(a,ai)\n\nLike push!, but creates a new object to store the result.  This function is used to push to immutable collections such as tuples.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.quadrature-Tuple{GalerkinToolkit.AbstractFaceDomain, Any}","page":"API","title":"GalerkinToolkit.quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.raviart_thomas_space","page":"API","title":"GalerkinToolkit.raviart_thomas_space","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.real_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.real_type","text":"real_type(options::Options)\n\nReturn the default real type used in the computation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.reference_int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.reference_int_type","text":"reference_int_type(options::Options)\n\nReturn the type of the integers used to enumerate reference quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.reference_quadratures","page":"API","title":"GalerkinToolkit.reference_quadratures","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_spaces","page":"API","title":"GalerkinToolkit.reference_spaces","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_topologies","page":"API","title":"GalerkinToolkit.reference_topologies","text":"reference_topologies(topo)\nreference_topologies(topo,d)\nreference_topologies(topo,Val(d))\n\nReturn the list (a vector or a tuple) of reference topologies in topo of dimension d. If the second argument is omitted, then the function returns a collection such that reference_topologies(topo)[d+1] is equivalent to reference_topologies(topo,Val(d)).\n\nThe face reference topology of face f of dimension d, is accessed as reference_topologies(topo,d)[r] with r=face_reference_id(topo,d)[f].\n\nSee also face_reference_id.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.shape_functions-Tuple{GalerkinToolkit.AbstractSpace}","page":"API","title":"GalerkinToolkit.shape_functions","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.simplexify","page":"API","title":"GalerkinToolkit.simplexify","text":"simplexify(x)\n\nConvert x into a mesh made of simplex cells.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.skeleton","page":"API","title":"GalerkinToolkit.skeleton","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.tabulator-Tuple{GalerkinToolkit.AbstractSpace}","page":"API","title":"GalerkinToolkit.tabulator","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.tensor_product_quadrature-Tuple{GalerkinToolkit.AbstractFaceDomain, Any}","page":"API","title":"GalerkinToolkit.tensor_product_quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.topology-Tuple{GalerkinToolkit.AbstractMesh}","page":"API","title":"GalerkinToolkit.topology","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.unit_n_cube-Tuple{Any}","page":"API","title":"GalerkinToolkit.unit_n_cube","text":"unit_n_cube(d)\nunit_n_cube(Val(d))\n\nReturn an object representing a unit d-cube.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.unit_simplex-Tuple{Any}","page":"API","title":"GalerkinToolkit.unit_simplex","text":"unit_simplex(d)\nunit_simplex(Val(d))\n\nReturn an object representing a unit simplex of dimension d.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.val_parameter-Tuple{Any}","page":"API","title":"GalerkinToolkit.val_parameter","text":"val_parameter(a)\n\nFor a::Val{A} it returns A. Otherwise, it returns a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.vertex_permutations","page":"API","title":"GalerkinToolkit.vertex_permutations","text":"vertex_permutations(x)\n\nReturn a list of permutations representing the admissible re-labelings of the vertices of x.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.weights","page":"API","title":"GalerkinToolkit.weights","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.with_gmsh-Tuple{Any}","page":"API","title":"GalerkinToolkit.with_gmsh","text":"with_gmsh(f[;options])\n\nA safe way of initialize and finalize the gmsh module. The given function is called f(gmsh) on the gmsh module after is has been initialized. The module is finalized automatically when the function returns.\n\nThe optional keyword argument options is a vector for pairs k=>v containing gmesh options. Each of these options are set with gmsh.option.setNumber(k,v) just after gmsh has been initialized.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.with_mesh_partitioner","page":"API","title":"GalerkinToolkit.with_mesh_partitioner","text":"with_mesh_partitioner(mesher[,partitioner];[parts])\n\nGenerate a mesh calling mesher() partition it, and distribute it over the part ids in parts.\n\nArguments\n\nFunction mesher() should have no arguments and returns a sequential mesh object. This function is called only on one process.\npartitioner [optional]: A function that takes a graph encoded as a sparse matrix, and returns a vector containing the part id of each node in the graph. Defaults to Metis.partition.\n\nKeyword arguments\n\nparts [optional]: A vector containing the part indices 1:P where P is the number of parts in the data distribution. By default, P is the number of MPI ranks and 1:P is distributed one item per rank.\n\n\n\n\n\n","category":"function"},{"location":"refindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"refindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"src_md/example_transient_heat_eq/#Transient-heat-equation","page":"Transient heat equation","title":"Transient heat equation","text":"","category":"section"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation","title":"Transient heat equation","text":"(Image: )","category":"page"},{"location":"src_md/example_transient_heat_eq/#Problem-statement","page":"Transient heat equation","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation","title":"Transient heat equation","text":"warning: Warning\nTODO","category":"page"},{"location":"src_md/example_transient_heat_eq/#Numerical-scheme","page":"Transient heat equation","title":"Numerical scheme","text":"","category":"section"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation","title":"Transient heat equation","text":"warning: Warning\nTODO","category":"page"},{"location":"src_md/example_transient_heat_eq/#Implementation","page":"Transient heat equation","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation","title":"Transient heat equation","text":"using LinearAlgebra\nimport GalerkinToolkit as GT\nimport DifferentialEquations\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide\n\n#Parameters\nmesh_size=0.02\nR=0.15\nT=2\nN=100\n\n#Generate mesh with GMSH Julia API\nmesh = GT.with_gmsh() do gmsh\n    R = 0.15\n    dim = 2\n    gmsh.option.set_number(\"General.Verbosity\", 2)\n    rect_tag = gmsh.model.occ.add_rectangle(0,0,0,1,1)\n    circle_tag = gmsh.model.occ.add_circle(0.5,0.5,0,R)\n    circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])\n    circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])\n    gmsh.model.occ.cut([(dim,rect_tag)],[(dim,circle_surf_tag)]);\n    gmsh.model.occ.synchronize()\n    domain_tags = [1]\n    outer_tags = [6,7,8,9]\n    inner_tags = [5]\n    gmsh.model.model.add_physical_group(dim,domain_tags,-1,\"domain\")\n    gmsh.model.model.add_physical_group(dim-1,outer_tags,-1,\"outer\")\n    gmsh.model.model.add_physical_group(dim-1,inner_tags,-1,\"inner\")\n    gmsh.option.set_number(\"Mesh.MeshSizeMax\",mesh_size)\n    gmsh.model.mesh.generate(dim)\n    GT.mesh_from_gmsh(gmsh)\nend\n\n#Domains\nΩ = GT.interior(mesh;group_names=[\"domain\"])\nΓ = GT.boundary(mesh;group_names=[\"outer\",\"inner\"])\n\n#Interpolation\nk = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γ)\nuh = GT.undef_field(Float64,V)\n\n#Integration\ndegree = 2*GT.order(V)\ndΩ = GT.measure(Ω,degree)\n\n#Initial condition\nu0 = GT.analytical_field(x->0.0,Ω)\nGT.interpolate_free!(u0,uh)\n\n#Time-dependent Dirichlet function\nα = t -> sin(3*pi*t)\nfunction dirichlet_dynamics!(t,uh,duh=nothing)\n    if uh !== nothing\n        g = GT.analytical_field(Γ;piecewise=true) do x,name\n            if name == \"inner\"\n                α(t)\n            else\n                0.0\n            end\n        end\n        GT.interpolate_dirichlet!(g,uh)\n    end\n    if duh !== nothing\n        g = GT.analytical_field(Γ;piecewise=true) do x,name\n            if name == \"inner\"\n                ForwardDiff.derivative(α,t)\n            else\n                0.0\n            end\n        end\n        GT.interpolate_dirichlet!(g,duh)\n    end\nend\n\n#Definition of the ODE problem\nC = 10\n∇ = ForwardDiff.gradient\nm = (u,v) -> GT.∫(x->C*v(x)*u(x),dΩ)\na = (u,v) -> -1*GT.∫(x->∇(u,x)⋅∇(v,x), dΩ)\nr = (uh,t) -> v -> a(uh,v)\nj = (uh,t) -> a\ntspan = (0.0,T)\nproblem = GT.SciMLBase_ODEProblem(tspan,uh,m,r,j;dirichlet_dynamics!)\n\n#Selection and setup of the ODE solver\ndt = T/N\nsolver = DifferentialEquations.QNDF(autodiff=false);\ninitializealg=DifferentialEquations.NoInit()\nadaptive=false\nsave_on=false\nintegrator = DifferentialEquations.init(\n    problem,solver;initializealg,dt,adaptive,save_on)\n\n#Setup Makie scene\naxis = (aspect = Makie.DataAspect(),)\nfig = Makie.Figure()\ncolorrange = (-1,1)\nax,sc = GT.makie_surfaces(fig[1,1],Ω;color=uh,axis,colorrange)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\n\n#Record Makie scene while solving\nfn = \"fig_transient_heat_equation_1.gif\"\nfile = joinpath(@__DIR__,fn)\nMakie.record(fig,file,integrator) do integrator\n    sc.color = GT.solution_field(integrator)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation","title":"Transient heat equation","text":"","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation","title":"Transient heat equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) (Image: ) (Image: )\nHello, World! Interior penalty Lagrange multipliers\n(Image: ) (Image: ) (Image: )\nPoisson equation p-Laplacian Linear elasticity\n(Image: ) (Image: ) \nStokes lid-driven cavity Transient heat equation ","category":"page"},{"location":"src_md/manual_interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"src_md/manual_interpolation/","page":"Interpolation","title":"Interpolation","text":"","category":"page"},{"location":"src_md/manual_interpolation/","page":"Interpolation","title":"Interpolation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation page of GalerkinToolkit!","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Home – This page.\nManual – The user and developer guide. It gives the detailed explanations on how to use and extend the library.\nExamples – They provide a quick overview of the main functionality of the library.\nTutorials – Learning material to get familiar with the building blocks of the library and the basics of the FEM. They are useful even if you are FEM expert as they walk you through the library step by step.\nAPI – All the docstrings are here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"NB. This documentation is organized based on the Diátaxis model.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#What","page":"Home","title":"What","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GalerkinToolkit is a high-performance finite element (FE) toolbox fully implemented in the Julia programming language. It provides modular building blocks to easily implement custom finite element codes to solve partial differential equations (PDEs), using a variety of numerical schemes, and across diverse computing environments.  GalerkinToolkit integrates seamlessly with the broader Julia ecosystem. It supports external solvers such as PartitionedSolvers.jl, PetscCall.jl, LinearSolve.jl, NonLinearSolve.jl, and DifferentialEquations.jl to handle the algebraic systems resulting from PDE discretizations. For visualization, the toolkit provides plotting recipes for Makie.jl and utilities for exporting results in VTK format using WriteVTK.jl.","category":"page"},{"location":"#Why","page":"Home","title":"Why","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GalerkinToolkit is definitively not the first FEM software project out there, but it has some unique features. This includes a unified API with high- and low-level abstractions, a deep integration with the Julia package ecosystem, a new form compiler, and  a redesign of the core ideas behind Gridap.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Find more information about GalerkinToolkit's features and novelties in the Introduction of the manual.","category":"page"},{"location":"#Code-examples","page":"Home","title":"Code examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: )\nHello, World! Interior penalty Lagrange multipliers\n(Image: ) (Image: ) (Image: )\nPoisson equation p-Laplacian Linear elasticity\n(Image: ) (Image: ) \nStokes lid-driven cavity Transient heat equation ","category":"page"},{"location":"#How-to-start","page":"Home","title":"How to start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Manual, you will find explanations about the software design and guides for users and developers.  Look into the Examples section for an overview of how to solve different types of PDEs with GalerkinToolkit. Learn how to use the library (and the basics of FEM) with the tutorials in the Tutorials section.","category":"page"},{"location":"#Pre-requisites","page":"Home","title":"Pre-requisites","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You need to be fluent in Julia before using GalerkinToolkit. You can learn Julia using the learning materials in julialang.org or the lecture notes in https://www.francescverdugo.com/XM_40017/dev/.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is also required to be familiar with the basics of FE methods. The basics are explained in the Tutorials section. For more in depth introduction, you can use the following books:","category":"page"},{"location":"","page":"Home","title":"Home","text":"C. Johnson [1]\nJ. Whiteley [2]\nS.C. Brenner and L. R. Scott [3]","category":"page"},{"location":"#Help-and-discussion","page":"Home","title":"Help and discussion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can open a new discussion to ask questions here.\nIf you have found a bug, open an issue here. Do not forget to include a (minimal) reproducer.","category":"page"},{"location":"#How-to-cite","page":"Home","title":"How to cite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the CITATION.cff file.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is under active development and there are several ways to contribute:","category":"page"},{"location":"","page":"Home","title":"Home","text":"by enhancing the documentation (e.g., fixing typos, enhancing doc strings, adding examples).\nby addressing one of the issues waiting for help.\nby adding more tests to increase the code coverage.\nby extending the current functionality. In this case, open a discussion here to coordinate with the package maintainers before proposing significant changes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Discuss with the package authors before working on any non-trivial contribution.","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since July 2024, this package is being developed with support from the Netherlands eScience Center under grant ID NLESC.SS.2023.008.","category":"page"},{"location":"#Affiliations","page":"Home","title":"Affiliations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is maintained at the Computer Science department of Vrije Universiteit Amsterdam.","category":"page"},{"location":"src_md/example_hello_world_dg/#Interior-penalty","page":"Interior penalty","title":"Interior penalty","text":"","category":"section"},{"location":"src_md/example_hello_world_dg/","page":"Interior penalty","title":"Interior penalty","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world_dg/#Problem-statement","page":"Interior penalty","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_hello_world_dg/","page":"Interior penalty","title":"Interior penalty","text":"We solve the same PDE as in the Hello, World! example, but this time using a discontinuous Galerkin scheme.","category":"page"},{"location":"src_md/example_hello_world_dg/#Numerical-scheme","page":"Interior penalty","title":"Numerical scheme","text":"","category":"section"},{"location":"src_md/example_hello_world_dg/","page":"Interior penalty","title":"Interior penalty","text":"We consider the symmetric interior penalty method [4].","category":"page"},{"location":"src_md/example_hello_world_dg/#Implementation","page":"Interior penalty","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_hello_world_dg/","page":"Interior penalty","title":"Interior penalty","text":"We solve the problem and visualize the solution. In this case, we draw the average of solution field  on the interior 2-faces of the computational mesh. There faces are where the interior penalty is enforced.","category":"page"},{"location":"src_md/example_hello_world_dg/#Implementation-2","page":"Interior penalty","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_hello_world_dg/","page":"Interior penalty","title":"Interior penalty","text":"import FileIO # hide\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport ForwardDiff\nimport GLMakie as Makie\nimport LinearSolve\n\n#Geometry\ndomain = (0,1,0,1,0,1)\ncells = (4,4,4)\nmesh = GT.cartesian_mesh(domain,cells)\nD = GT.num_dims(mesh)\nn = GT.unit_normal(mesh,D-1)\nΩ = GT.interior(mesh)\nΓd = GT.boundary(mesh)\nΛ = GT.skeleton(mesh)\nh_Λ = GT.face_diameter_field(Λ)\nh_Γd = GT.face_diameter_field(Γd)\n\n#Functions\nconst ∇ = ForwardDiff.gradient\nconst g = GT.analytical_field(sum,Ω)\nconst f = GT.analytical_field(x->0,Ω)\nmean(f,u,x) = 0.5*(f(u[1],x)+f(u[2],x))\njump(u,n,x) = u[2](x)*n[2](x) + u[1](x)*n[1](x)\n\n#Interpolation\nk = 1\nconst γ0 = k*(k+1)/10\nγ = GT.uniform_quantity(γ0)\nV = GT.lagrange_space(Ω,k;continuous=false)\n\n#Integration\ndegree = 2*k\ndΩ = GT.quadrature(Ω,degree)\ndΛ = GT.quadrature(Λ,degree)\ndΓd = GT.quadrature(Γd,degree)\n\n#Weak form\na = (u,v) -> begin\n    #Laplace operator\n    GT.∫(dΩ) do x\n        ∇(u,x)⋅∇(v,x)\n    end +\n    #Interior penalty\n    GT.∫(dΛ) do x\n        (γ/h_Λ(x))*jump(v,n,x)⋅jump(u,n,x)-\n        jump(v,n,x)⋅mean(∇,u,x)-\n        mean(∇,v,x)⋅jump(u,n,x)\n    end +\n    #Nitsche term\n    GT.∫(dΓd) do x\n        (γ/h_Γd(x))*v(x)*u(x)-\n        v(x)*n(x)⋅∇(u,x)-\n        n(x)⋅∇(v,x)*u(x)\n    end\nend\nl = v -> begin\n    #RHS\n    GT.∫(dΩ) do x\n         v(x)*f(x)\n    end +\n    #Nietche term\n    GT.∫(dΓd) do x\n        (γ/h_Γd(x))*v(x)*g(x)-\n        n(x)⋅∇(v,x)*g(x)\n    end\nend\n\n#Linear problem\np = GT.SciMLBase_LinearProblem(Float64,V,a,l)\nsol = LinearSolve.solve(p)\nuh = GT.solution_field(V,sol)\n\n#Error check\neh = x -> uh(x) - g(x)\nel2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt\n@assert el2 < 1.0e-9\n\n#Visualization\nfig = Makie.Figure()\nax = Makie.Axis3(fig[1,1],aspect=:data)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Λ;color=x->mean(GT.value,uh,x))\nFileIO.save(joinpath(@__DIR__,\"fig_hello_world_dg_1.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_dg/#Explicit-integration-loops","page":"Interior penalty","title":"Explicit integration loops","text":"","category":"section"},{"location":"src_md/example_hello_world_dg/","page":"Interior penalty","title":"Interior penalty","text":"This other code version implements the integration loops manually instead of relying on the underlying automatic code generation.","category":"page"},{"location":"src_md/example_hello_world_dg/","page":"Interior penalty","title":"Interior penalty","text":"function assemble_Ω!(A_alloc,b_alloc,V,dΩ)\n\n    #Temporaries\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Loop over bulk faces\n    tabulate = (∇,GT.value)\n    compute=(GT.coordinate,)\n    for V_face in GT.each_face(V,dΩ;tabulate,compute)\n        dofs = GT.dofs(V_face)\n        ndofs = length(dofs)\n        fill!(Auu,zero(T))\n        fill!(bu,zero(T))\n        for V_point in GT.each_point(V_face)\n            dV = GT.weight(V_point)\n            dof_∇s = GT.shape_functions(∇,V_point)\n            dof_s = GT.shape_functions(GT.value,V_point)\n            x = GT.coordinate(V_point)\n            fx = f.definition(x)\n            for i in 1:ndofs\n                v = dof_s[i]\n                bu[i] += v*fx*dV\n            end\n            for j in 1:ndofs\n                ∇u = dof_∇s[j]\n                for i in 1:ndofs\n                    ∇v = dof_∇s[i]\n                    Auu[i,j] += ∇v⋅∇u*dV\n                end\n            end\n        end\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n        GT.contribute!(b_alloc,bu,dofs)\n    end\n\nend\n\nfunction assemble_Λ!(A_alloc,V,dΛ)\n\n    #Temporaries\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n\n    #Loop over skeleton faces\n    tabulate = (∇,GT.value)\n    compute=(GT.unit_normal,)\n    V_dfaces = GT.each_face(V,dΛ;tabulate,compute)\n    dΛ_dfaces = GT.each_face(dΛ)\n    for (dΛ_dface,V_dface) in zip(dΛ_dfaces,V_dfaces)\n        h = GT.diameter(dΛ_dface)\n        dΛ_points = GT.each_point(dΛ_dface)\n        for V_Dface_i in GT.each_face_around(V_dface)\n            dofs_i = GT.dofs(V_Dface_i)\n            ndofs_i = length(dofs_i)\n            V_points_i = GT.each_point(V_Dface_i)\n            for V_Dface_j in GT.each_face_around(V_dface)\n                V_points_j = GT.each_point(V_Dface_j)\n                dofs_j = GT.dofs(V_Dface_j)\n                ndofs_j = length(dofs_j)\n                fill!(Auu,zero(T))\n                for (dΛ_point,V_point_i,V_point_j) in zip(dΛ_points,V_points_i,V_points_j)\n                    dS = GT.weight(dΛ_point)\n                    s_i = GT.shape_functions(GT.value,V_point_i)\n                    s_j = GT.shape_functions(GT.value,V_point_j)\n                    ∇s_i = GT.shape_functions(∇,V_point_i)\n                    ∇s_j = GT.shape_functions(∇,V_point_j)\n                    n_i = GT.unit_normal(V_point_i)\n                    n_j = GT.unit_normal(V_point_j)\n                    for j in 1:ndofs_j\n                        for i in 1:ndofs_i\n                            jump_jump = (γ0/h)*(s_i[i]*n_i)⋅(s_j[j]*n_j)\n                            jump_mean = (s_i[i]*n_i)⋅(0.5*∇s_j[j])\n                            mean_jump = (0.5*∇s_i[i])⋅(s_j[j]*n_j)\n                            Auu[i,j] += (jump_jump - jump_mean - mean_jump)*dS\n                        end\n                    end\n                end\n                GT.contribute!(A_alloc,Auu,dofs_i,dofs_j)\n            end\n        end\n    end\n\nend\n\nfunction assemble_Γd!(A_alloc,b_alloc,V,dΓd)\n\n    #Temporaries\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Loop over Dirichlet boundary\n    dΓd_dfaces = GT.each_face(dΓd)\n    tabulate = (∇,GT.value)\n    compute=(GT.unit_normal,)\n    V_dfaces = GT.each_face(V,dΓd;tabulate,compute)\n    for (V_dface,dΓd_dface) in zip(V_dfaces,dΓd_dfaces)\n        dofs = GT.dofs(V_dface)\n        ndofs = length(dofs)\n        V_points = GT.each_point(V_dface)\n        h = GT.diameter(dΓd_dface)\n        dΓd_points = GT.each_point(dΓd_dface)\n        fill!(Auu,zero(T))\n        fill!(bu,zero(T))\n        for (V_point,dΓd_point) in zip(V_points,dΓd_points)\n            dS = GT.weight(dΓd_point)\n            x = GT.coordinate(dΓd_point)\n            dof_s = GT.shape_functions(GT.value,V_point)\n            dof_∇s = GT.shape_functions(∇,V_point)\n            n = GT.unit_normal(V_point)\n            gx = g.definition(x)\n            for i in 1:ndofs\n                ∇v = dof_∇s[i]\n                v = dof_s[i]\n                bu[i] += ((γ0/h)*v*gx - n⋅∇v*gx)*dS\n            end\n            for j in 1:ndofs\n                ∇u = dof_∇s[j]\n                u = dof_s[j]\n                for i in 1:ndofs\n                    ∇v = dof_∇s[i]\n                    v = dof_s[i]\n                    Auu[i,j] += ((γ0/h)*v*u - v*n⋅∇u - n⋅∇v*u)*dS\n                end\n            end\n        end\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n        GT.contribute!(b_alloc,bu,dofs)\n    end\n\nend\n\nfunction integrate_l2_error(g,uh,dΩ)\n\n    #Iterators to the quantities on the\n    #integration points\n    tabulate = (GT.value,)\n    compute = (GT.coordinate,)\n    uh_faces = GT.each_face(uh,dΩ;tabulate,compute)\n\n    #Numerical integration loop\n    s = 0.0\n    for uh_face in uh_faces\n        for uh_point in GT.each_point(uh_face)\n\n            #Get quantities at current integration point\n            x = GT.coordinate(uh_point)\n            dV = GT.weight(uh_point)\n            uhx = GT.field(GT.value,uh_point)\n\n            #Add contribution\n            s += abs2(uhx-g.definition(x))*dV\n        end\n    end\n\n    #Compute the l2 norm\n    el2 = sqrt(s)\nend\n\n#Allocate matrix for free columns\nT = Float64\nA_alloc = GT.allocate_matrix(T,V,V,Ω,Λ,Γd)\nb_alloc = GT.allocate_vector(T,V,Ω,Γd)\n\n#Fill allocations with the function we wrote above\nassemble_Ω!(A_alloc,b_alloc,V,dΩ)\nassemble_Λ!(A_alloc,V,dΛ)\nassemble_Γd!(A_alloc,b_alloc,V,dΓd)\n\n#Compress matrix into the final format\nA = GT.compress(A_alloc)\nb = GT.compress(b_alloc)\n\n#Build the linear system\np = LinearSolve.LinearProblem(A,b)\n\n#Solve the problem\nsol = LinearSolve.solve(p)\nuh = GT.solution_field(V,sol)\n\n#Integrate the error l2 norm\n#with the function we wrote above\nel2 = integrate_l2_error(g,uh,dΩ)\n@assert el2 < 1.0e-9\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_dg/","page":"Interior penalty","title":"Interior penalty","text":"","category":"page"},{"location":"src_md/example_hello_world_dg/","page":"Interior penalty","title":"Interior penalty","text":"This page was generated using Literate.jl.","category":"page"}]
}
