var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"C. Johnson. Numerical Solution of Partial Differential Equations by the Finite Element Method (Dover Publications, 2009).\n\n\n\nJ. Whiteley. Finite Element Methods, A Practical Guide (Springer, 2017).\n\n\n\nS. C. Brenner and R. Scott. The mathematical theory of finite element methods. 3 Edition, Texts in applied mathematics (Springer, New York, NY, 2007).\n\n\n\nD. N. Arnold, F. Brezzi, B. Cockburn and L. D. Marini. Unified analysis of discontinuous Galerkin methods for elliptic problems. SIAM J. Numer. Anal. 39, 1749–1779 (2002).\n\n\n\n","category":"section"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"Introduction to the FEM","category":"section"},{"location":"src_md/manual_mesh_generation/#Mesh-generation","page":"Mesh generation","title":"Mesh generation","text":"To create mesh objects M::AbstractMesh  one can use external mesh generators (gmsh at the moment), the built-in Cartesian mesh generator, or instantiate meshes from raw data.","category":"section"},{"location":"src_md/manual_mesh_generation/#Gmsh-meshes","page":"Mesh generation","title":"Gmsh meshes","text":"Meshes generated with gmsh can be transformed into GalerkinToolkit mesh objects using functions mesh_from_gmsh and mesh_from_msh. The physical groups defined within gmsh will be transformed into face groups in the GalerkinToolkit mesh, which is useful to impose boundary conditions. We use Gmsh.jl under the hood as the wrapper to the Julia API of gmsh.","category":"section"},{"location":"src_md/manual_mesh_generation/#A-mesh-from-a-msh-file","page":"Mesh generation","title":"A mesh from a msh file","text":"Function mesh_from_msh reads and crates a mesh object from a .msh file (the default format used by gmsh to export meshes).","category":"section"},{"location":"src_md/manual_mesh_generation/#Example","page":"Mesh generation","title":"Example","text":"We create a mesh from a .msh file and visualize it. In this case, we only visualize the 2-faces in the mesh. We color them according to the face group named \"sides\". Faces in the group are visualized in orange and other faces in blue. This face group is only defined for 2-faces. If you visualize the 3-faces (as by default), you would not see this face group.\n\nmodule MeshGen01 # hide\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport FileIO # hide\n\n#Read the mesh\nassets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"model.msh\")\nmesh = GT.mesh_from_msh(msh_file)\n\n#Visualize it\nfig = Makie.Figure()\nax = Makie.Axis3(fig[1,1];aspect=:data)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\ncolor = GT.FaceColor(\"sides\")\nGT.makie_surfaces!(mesh;dim=2,color)\nGT.makie_edges!(mesh;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_mesh_generation_1.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"src_md/manual_mesh_generation/#Meshes-from-GMSH-Julia-API","page":"Mesh generation","title":"Meshes from GMSH Julia API","text":"It is also possible to generate meshes in Julia code using the gmsh API and then convert them to GalerkinToolkit objects. This is done with two functions: See also with_gmsh and mesh_from_gmsh.","category":"section"},{"location":"src_md/manual_mesh_generation/#Example-2","page":"Mesh generation","title":"Example","text":"We generate a simple 2d mesh with the gmsh Julia API.\n\nmodule MeshGen02 # hide\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport FileIO # hide\n\n#Generate mesh with GMSH Julia API\nmesh = GT.with_gmsh() do gmsh\n    mesh_size=0.04\n    T=2\n    N=100\n    R = 0.15\n    dim = 2\n    gmsh.option.set_number(\"General.Verbosity\", 2)\n    rect_tag = gmsh.model.occ.add_rectangle(0,0,0,1,1)\n    circle_tag = gmsh.model.occ.add_circle(0.5,0.5,0,R)\n    circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])\n    circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])\n    gmsh.model.occ.cut([(dim,rect_tag)],[(dim,circle_surf_tag)]);\n    gmsh.model.occ.synchronize()\n    domain_tags = [1]\n    outer_tags = [6,7,8,9]\n    inner_tags = [5]\n    gmsh.model.model.add_physical_group(dim,domain_tags,-1,\"domain\")\n    gmsh.model.model.add_physical_group(dim-1,outer_tags,-1,\"outer\")\n    gmsh.model.model.add_physical_group(dim-1,inner_tags,-1,\"inner\")\n    gmsh.option.set_number(\"Mesh.MeshSizeMax\",mesh_size)\n    gmsh.model.mesh.generate(dim)\n    #Transform it to a mesh object\n    GT.mesh_from_gmsh(gmsh)\nend\n\n#Visualize\nfig = Makie.Figure()\naxis = (;aspect=Makie.DataAspect())\nshading = Makie.NoShading\nax,sc = GT.makie_surfaces(fig[1,1],mesh;axis,shading)\nGT.makie_edges!(mesh;color=:black)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nFileIO.save(joinpath(@__DIR__,\"fig_mesh_generation_2.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"src_md/manual_mesh_generation/#Cartesian-meshes","page":"Mesh generation","title":"Cartesian meshes","text":"GalerkinToolkit comes with a built-in Cartesian mesh generator implemented in function cartesian_mesh.","category":"section"},{"location":"src_md/manual_mesh_generation/#Example-3","page":"Mesh generation","title":"Example","text":"Generate a 3D Cartesian mesh  of the box (01)times(-11)times(34) with 10, 20 , and 10 cells in each axis.\n\nmodule MeshGen03 # hide\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport FileIO # hide\n\n#Create mesh\ndomain = (0,1,-1,1,3,4)\ncells = (10,20,10)\nmesh = GT.cartesian_mesh(domain,cells)\n\n#Visualize it\nGT.makie_surfaces(mesh;axis=(;aspect=:data))\nGT.makie_edges!(mesh;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_mesh_generation_3.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"src_md/manual_mesh_generation/#Example-4","page":"Mesh generation","title":"Example","text":"Create a coarse cartesian mesh of the unit square with 4 and 4 cells in each axis. Visualize faces in all dimensions, shrinking them to avoid overlaps.\n\nmodule MeshGen04 # hide\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport FileIO # hide\n\n#Generate mesh\ndomain = (0,1,0,1)\ncells = (4,4)\nmesh = GT.cartesian_mesh(domain,cells)\n\n#Visualize it\naxis = (;aspect=Makie.DataAspect())\nshading = Makie.NoShading\nshrink = 0.8\nGT.makie_surfaces(mesh;axis,shading,shrink)\nGT.makie_edges!(mesh;dim=1,shrink)\nGT.makie_vertices!(mesh;dim=0)\nFileIO.save(joinpath(@__DIR__,\"fig_mesh_generation_4.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )\n\nNow, the same as before, but only generate low-dimensional faces on the boundary.\n\nmodule MeshGen05 # hide\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport FileIO # hide\n\n#Generate mesh\ndomain = (0,1,0,1)\ncells = (4,4)\nmesh = GT.cartesian_mesh(domain,cells;complexify=false)\n\n#Visualize it\naxis = (;aspect=Makie.DataAspect())\nshading = Makie.NoShading\nshrink = 0.8\nGT.makie_surfaces(mesh;axis,shading,shrink)\nGT.makie_edges!(mesh;dim=1,shrink)\nGT.makie_vertices!(mesh;dim=0)\nFileIO.save(joinpath(@__DIR__,\"fig_mesh_generation_5.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"src_md/manual_mesh_generation/#Instantiating-a-mesh","page":"Mesh generation","title":"Instantiating a mesh","text":"","category":"section"},{"location":"src_md/manual_mesh_generation/#Creating-a-mesh","page":"Mesh generation","title":"Creating a mesh","text":"The general way of creating an instance of the type Mesh is with function create_mesh. This is the lowest-level way of creating a mesh. Other more user-friendly ways of building a mesh are discussed in the Mesh generation section.","category":"section"},{"location":"src_md/manual_mesh_generation/#Example-5","page":"Mesh generation","title":"Example","text":"In the following example, we generate and visualize a mesh of three first order triangles. Only faces of dimension 2 are present in this example. The arrays for vertices and edges are empty.\n\nmodule Meshes01 # hide\n#Import dependencies\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport StaticArrays\nimport FileIO # hide\n\n#Node coordinates\nT = StaticArrays.SVector{2,Float64}\nnode_coordinates = T[(0,0),(1,0),(0,1),(1,1),(2,0)]\n\n#Face nodes\nface_nodes_0 = Vector{Int}[]\nface_nodes_1 = Vector{Int}[]\nface_nodes_2 = [[1,2,3],[2,3,4],[2,4,5]]\nface_nodes = [\n    face_nodes_0,\n    face_nodes_1,\n    face_nodes_2]\n\n#Reference spaces\nreference_spaces_0 = ()\nreference_spaces_1 = ()\norder = 1\ntriangle = GT.unit_simplex(Val(2))\ntriangle3 = GT.lagrange_space(triangle,order)\nreference_spaces_2 = (triangle3,)\nreference_spaces = (\n    reference_spaces_0,\n    reference_spaces_1,\n    reference_spaces_2)\n\n#Create mesh\nmesh = GT.create_mesh(;\n    node_coordinates,\n    face_nodes,\n    reference_spaces)\n\n#Visualize\naxis = (;aspect=Makie.DataAspect())\nshading = Makie.NoShading\nGT.makie_surfaces(mesh;axis,shading)\nGT.makie_edges!(mesh;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_1.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"src_md/manual_mesh_generation/#Example-6","page":"Mesh generation","title":"Example","text":"In this other slightly more complex example, we define a mesh including faces of different dimensions: surfaces, edges and vertices. To be able to see all faces in the visualization, we need to \"shrink\" them. Otherwise, the surfaces would hide the edges and vertices.\n\nmodule Meshes02 # hide\n#Import dependencies\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport StaticArrays\nimport FileIO # hide\n\n#Node coordinates\nT = StaticArrays.SVector{2,Float64}\nnode_coordinates = T[(0,0),(1,0),(0,1),(1,1),(2,0)]\n\n#Face nodes\nface_nodes_0 = [[1],[3]]\nface_nodes_1 = [[1,2],[2,5],[5,4]]\nface_nodes_2 = [[1,2,3],[2,3,4],[2,4,5]]\nface_nodes = [\n    face_nodes_0,\n    face_nodes_1,\n    face_nodes_2]\n\n#Reference spaces\norder = 1\nvertex = GT.unit_simplex(Val(0))\nvertex1 = GT.lagrange_space(vertex,order)\nsegment = GT.unit_simplex(Val(1))\nsegment2 = GT.lagrange_space(segment,order)\ntriangle = GT.unit_simplex(Val(2))\ntriangle3 = GT.lagrange_space(triangle,order)\nreference_spaces_0 = (vertex1,)\nreference_spaces_1 = (segment2,)\nreference_spaces_2 = (triangle3,)\nreference_spaces = (\n    reference_spaces_0,\n    reference_spaces_1,\n    reference_spaces_2)\n\n#Create mesh\nmesh = GT.create_mesh(;\n    node_coordinates,\n    face_nodes,\n    reference_spaces)\n\n#Visualize\naxis = (;aspect=Makie.DataAspect())\nshrink = 0.8\nshading = Makie.NoShading\nGT.makie_surfaces(mesh;axis,shading,shrink)\nGT.makie_edges!(mesh;dim=1,shrink)\nGT.makie_vertices!(mesh;dim=0)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_2.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"src_md/manual_mesh_generation/#Creating-a-chain","page":"Mesh generation","title":"Creating a chain","text":"Using function create_mesh might be tedious if all faces are of the same dimension. In this case, we can use the slightly simpler constructor create_chain. It works like create_mesh, but we pass data only for one face dimension.","category":"section"},{"location":"src_md/manual_mesh_generation/#Example-7","page":"Mesh generation","title":"Example","text":"We create the mesh of the first example, but using create_chain.\n\nmodule Meshes03 # hide\n#Import dependencies\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport StaticArrays\nimport FileIO # hide\n\n#Node coordinates\nT = StaticArrays.SVector{2,Float64}\nnode_coordinates = T[(0,0),(1,0),(0,1),(1,1),(2,0)]\n\n#Face nodes\nface_nodes = [[1,2,3],[2,3,4],[2,4,5]]\n\n#Reference spaces\norder = 1\ntriangle = GT.unit_simplex(Val(2))\ntriangle3 = GT.lagrange_space(triangle,order)\nreference_spaces = (triangle3,)\n\n#Create mesh\nchain = GT.create_chain(;\n    node_coordinates,\n    face_nodes,\n    reference_spaces)\n\n#Visualize\naxis = (;aspect=Makie.DataAspect())\nshading = Makie.NoShading\nGT.makie_surfaces(chain;axis,shading)\nGT.makie_edges!(chain;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_1a.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"src_md/manual_mesh_generation/#GalerkinToolkit.mesh_from_msh-src_md-manual_mesh_generation","page":"Mesh generation","title":"GalerkinToolkit.mesh_from_msh","text":"mesh_from_msh(msh_file;kwargs...)\n\nCreate a mesh object from a .msh file found in path msh_file.\n\nSee also mesh_from_gmsh and with_gmsh.\n\nKeyword arguments\n\ncomplexify=true [optional]: If complexify==true, the mesh will be completed with all low dimensional faces into a face complex.\nrenumber=true [optional]: If renumber==true, then gmsh.model.mesh.renumberNodes() and gmsh.model.mesh.renumberElements() will be called.\nAny other keyword argument will be passed to function with_gmsh.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_mesh_generation/#GalerkinToolkit.with_gmsh-src_md-manual_mesh_generation","page":"Mesh generation","title":"GalerkinToolkit.with_gmsh","text":"with_gmsh(f[;options])\n\nA safe way of initialize and finalize the gmsh module. The given function is called f(gmsh) on the gmsh module after is has been initialized. The module is finalized automatically when the function returns.\n\nThe optional keyword argument options is a vector for pairs k=>v containing gmesh options. Each of these options are set with gmsh.option.setNumber(k,v) just after gmsh has been initialized.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_mesh_generation/#GalerkinToolkit.mesh_from_gmsh-src_md-manual_mesh_generation","page":"Mesh generation","title":"GalerkinToolkit.mesh_from_gmsh","text":"mesh_from_gmsh(gmsh::Module;complexify=true)\n\nCreate a mesh objects from the current state of the gmsh module. If complexify==true, the mesh will be completed with all low dimensional faces into a face complex.\n\nSee also mesh_from_msh and with_gmsh.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_mesh_generation/#GalerkinToolkit.cartesian_mesh","page":"Mesh generation","title":"GalerkinToolkit.cartesian_mesh","text":"cartesian_mesh(domain,cells_per_dir)\n\nCreate a multi-dimensional Cartesian mesh. The dimension of the mesh is defined by the length of cells_per_dir. The number of cells in direction i is given by cells_per_dir[i]. The extends of the Cartesian mesh are given in domain. The range in direction i covered by the mesh is given by domain[2*i-1,2*i].\n\nKeyword arguments\n\nboundary=true [optional]: Include faces on the boundary and generate face groups identifying which faces are  on which face of  bounding box of the mesh. The groups are named $d-face-$i for the face i of dimension d of the bounding box.\ncomplexify=true [optional]: Generate all low dimensional faces so that the mesh is  a face complex.\nsimplexify=false [optional]: Generate a mesh of simplex faces instead of hyper-cubes.\n\n\n\n\n\n","category":"function"},{"location":"src_md/example_p_laplacian/#p-Laplacian","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"section"},{"location":"src_md/example_p_laplacian/#Problem-statement","page":"p-Laplacian","title":"Problem statement","text":"Find the scalar-field u such that\n\nleftlbrace\nbeginaligned\n-nabla cdot sigma(u) = f textin Omega\nu = -1  texton  Gamma_0\nu = 1  texton  Gamma_1\nsigma(u)cdot n = 0  textelsewhere on  partialOmega\nendaligned\nright\n\nwith sigma(u) = nabla u^p-2  nabla u and p2. The vector field n is the outwards unit normal vector to partialOmega. The computational domains are defined in the mesh file model.msh. The domain Omega is represented by the 3D faces in this mesh. The domain Gamma_0 is represented by the physical group named \"sides\" and Gamma_1 is the union of the physical groups named \"circle\", \"triangle\", and \"square\".","category":"section"},{"location":"src_md/example_p_laplacian/#Numerical-scheme","page":"p-Laplacian","title":"Numerical scheme","text":"We discretize the problem with a space V with piece-wise continuous Lagrangian basis functions. For this formulation, the nonlinear weak form reads: find uin V_g such that r(u)(v) = 0 for all vin V_0. The auxiliary spaces V_g and V_0 are the subsets of V that fulfill the Dirichlet boundary condition g and 0 on partialOmega respectively.\n\nThe weak residual r(u) evaluated at a function  uin V_g is the linear form defined as\n\nr(u)(v) doteq int_Omega nabla v cdot left( nabla u^p-2 nabla u right)  rm dOmega - int_Omega v f  rm dOmega\n\nIn order to solve this nonlinear weak equation, we consider a Newton-Raphson method, which is associated with a linearization of the problem in an arbitrary direction delta uin V_0, namely r(u+delta u)(v)approx r(u)(v) + j(u)(delta uv). In previous formula,  j(u) is the Jacobian evaluated at uin V_g, which is the bilinear form\n\nj(u)(delta uv) = int_Omega nabla v cdot left( nabla u^p-2 nabla delta u right)  rm dOmega + (p-2) int_Omega nabla v cdot left(  nabla u^p-4 (nabla u cdot nabla delta u) nabla u  right)  rm dOmega","category":"section"},{"location":"src_md/example_p_laplacian/#Implementation","page":"p-Laplacian","title":"Implementation","text":"import FileIO # hide\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport NonlinearSolve\nimport ForwardDiff\nimport GLMakie as Makie\n\n#Read and visualize the mesh\nassets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"model.msh\")\nmesh = GT.mesh_from_msh(msh_file)\n\n#Define domains\ndirichlet_names = [\"sides\",\"circle\", \"triangle\", \"square\"]\nΩ = GT.interior(mesh)\nΓd = GT.boundary(mesh;group_names=dirichlet_names)\n\n#Define forcing data\ng = GT.analytical_field(Γd;piecewise=true) do x,name\n    if name == \"sides\"\n        -1\n    else\n        1\n    end\nend\n\n#Define the interpolation space\nk = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n\n#Interpolate Dirichlet values\nT = Float64\nuh = GT.rand_field(T,V)\nGT.interpolate_dirichlet!(g,uh)\n\n#Define numerical integration\ndegree = 2*k\ndΩ = GT.measure(Ω,degree)\n\n#Define weak form.\n∇ = ForwardDiff.gradient\nq = 3\nflux(∇u) = norm(∇u)^(q-2) * ∇u\ndflux(∇du,∇u) = (q-2)*norm(∇u)^(q-4)*(∇u⋅∇du)*∇u+norm(∇u)^(q-2)*∇du\nr = u -> v -> GT.∫( x-> ∇(v,x)⋅GT.call(flux,∇(u,x)), dΩ)\nj = u -> (du,v) -> GT.∫( x-> ∇(v,x)⋅GT.call(dflux,∇(du,x),∇(u,x)) , dΩ)\n\n#Define non-linear problem\np = GT.SciMLBase_NonlinearProblem(uh,r,j)\n\n#Solve it\nsol = NonlinearSolve.solve(p;show_trace=Val(true))\n@assert sol.retcode == NonlinearSolve.ReturnCode.Success\n\n#Get the FE solution object\nuh = GT.solution_field(uh,sol)\n\n#Visualize the solution\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Ω;color=uh)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_1.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"section"},{"location":"src_md/example_p_laplacian/#Building-the-algebraic-non-linear-problem-explicitly","page":"p-Laplacian","title":"Building the algebraic non-linear problem explicitly","text":"In this other version, we explicitly build the algebraic residual and Jacobian (functions that take plain Julia vectors) and build a algebraic non-linear problem from them.\n\nimport SciMLBase\n\n#Initial guess\nx = rand(T,GT.num_free_dofs(V))\nGT.solution_field!(uh,x)\n\n#Initial residual and Jacobian\nreuse = Val(true)\nparameters = (uh,)\nb,residual_cache = GT.assemble_vector(r(uh),T,V;parameters,reuse)\nA,jacobian_cache = GT.assemble_matrix(j(uh),T,V,V;parameters,reuse)\n\n#Algebraic residual and Jacobian functions\nfunction f(dx,x,p)\n    GT.solution_field!(uh,x)\n    GT.update_vector!(dx,residual_cache;parameters)\n    dx\nend\n\nfunction jac(J,x,p)\n    GT.solution_field!(uh,x)\n    GT.update_matrix!(J,jacobian_cache;parameters)\n    J\nend\n\n#Build the nonlinear problem\njac_prototype = A\nnlfun = SciMLBase.NonlinearFunction(f;jac,jac_prototype)\np = SciMLBase.NonlinearProblem(nlfun,x)\n\n#Solve it\nsol = NonlinearSolve.solve(p;show_trace=Val(true))\n@assert sol.retcode == NonlinearSolve.ReturnCode.Success\n\n#Get the FE solution object\nx = sol.u\nGT.solution_field!(uh,x)\n\n#Visualize the solution\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Ω;color=uh)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_2.png\"),Makie.current_figure()) # hide\nnothing # hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"src_md/example_hello_world/#Hello,-World!","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"section"},{"location":"src_md/example_hello_world/#Problem-statement","page":"Hello, World!","title":"Problem statement","text":"In this example, we show how to solve the \"Hello, world\" PDE example: the Laplace equation on the unit hyper-cube Omega  =01^d, d=3, with Dirichlet boundary conditions.\n\nleftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright\n\nwith f=0 and g(x)=textsum(x). In this case, we know that the solution is u=g which allows us to check that we solve the problem correctly, by integration an error norm.","category":"section"},{"location":"src_md/example_hello_world/#Numerical-scheme","page":"Hello, World!","title":"Numerical scheme","text":"We use a conventional Galerkin finite element (FE) method with conforming Lagrangian FE spaces (see, e.g., [1]).  The weak form equation we solve consists in finding u_hin V_g such that a(u_hv) = ell(v) for all vin V_0. To this end we build a space V spanned by continuous and piece-wise Lagrangian basis functions. The auxiliary spaces V_g and V_0 are the subsets of V that fulfill the Dirichlet boundary condition g and 0 on partialOmega respectively. The bilinear and linear forms are\n\n  a(uv) doteq int_Omega nabla v cdot nabla u  rm dOmega quad b(v) doteq int_Omega v f   rm  dOmega\n\nThis equation results in a system of linear algebraic equations that is solved using an external linear solver from LinearSolve.jl.","category":"section"},{"location":"src_md/example_hello_world/#Implementation","page":"Hello, World!","title":"Implementation","text":"import FileIO # hide\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport ForwardDiff\nimport GLMakie as Makie\nimport LinearSolve\n\n#Geometry\ndomain = (0,1,0,1,0,1)\ncells = (10,10,10)\nmesh = GT.cartesian_mesh(domain,cells)\nΩ = GT.interior(mesh)\nΓd = GT.boundary(mesh)\n\n#Functions\n∇ = ForwardDiff.gradient\ng = GT.analytical_field(sum,Ω)\nf = GT.analytical_field(x->0,Ω)\n\n#Interpolation\nk = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\nT = Float64\nuhd = GT.zero_dirichlet_field(T,V)\nGT.interpolate_dirichlet!(g,uhd)\n\n#Weak form\ndegree = 2*k\ndΩ = GT.measure(Ω,degree)\na = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\nl = v -> GT.∫( x->v(x)*f(x), dΩ)\n\n#Linear problem\np = GT.SciMLBase_LinearProblem(uhd,a,l)\nsol = LinearSolve.solve(p)\nuh = GT.solution_field(uhd,sol)\n\n#Error check\neh = x -> uh(x) - g(x)\nel2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt\n@assert el2 < 1.0e-9\n\n#Visualization\nfig = Makie.Figure()\nax = Makie.Axis3(fig[1,1],aspect=:data)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Ω;color=uh)\nFileIO.save(joinpath(@__DIR__,\"fig_hello_world_1.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"section"},{"location":"src_md/example_hello_world/#Explicit-integration-loops","page":"Hello, World!","title":"Explicit integration loops","text":"This other code version implements the integration loops manually instead of relying on the underlying automatic code generation.\n\n#Manually written matrix assembly function\n#Always use a function, never the global scope\nfunction assemble_matrix!(A_alloc,Ad_alloc,V,dΩ)\n\n    ∇ = ForwardDiff.gradient\n\n    #Iterators to the quantities on the\n    #integration points\n    V_faces = GT.each_face(V,dΩ;tabulate=(∇,))\n\n    #Temporaries\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n\n    #Numerical integration loop\n    for V_face in V_faces\n\n        #Get quantities at current face\n        dofs = GT.dofs(V_face)\n\n        #Reset face matrix\n        fill!(Auu,zero(T))\n\n        #Loop over integration points\n        for V_point in GT.each_point(V_face)\n\n            #Get quantities at current integration point\n            dV = GT.weight(V_point)\n            dof_∇s = GT.shape_functions(∇,V_point)\n\n            #Fill in face matrix\n            for (i,dofi) in enumerate(dofs)\n                ∇v = dof_∇s[i]\n                for (j,dofj) in enumerate(dofs)\n                    ∇u = dof_∇s[j]\n                    Auu[i,j] += ∇v⋅∇u*dV\n                end\n            end\n        end\n\n        #Add face contribution to the\n        #global allocations\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n        GT.contribute!(Ad_alloc,Auu,dofs,dofs)\n    end\nend\n\n#Manually written integration of the error\n#Always use a function, never the global scope\nfunction integrate_l2_error(g,uh,dΩ)\n\n    #Iterators to the quantities on the\n    #integration points\n    tabulate = (GT.value,)\n    compute = (GT.coordinate,)\n    uh_faces = GT.each_face(uh,dΩ;tabulate,compute)\n\n    #Numerical integration loop\n    s = 0.0\n    for uh_face in uh_faces\n        for uh_point in GT.each_point(uh_face)\n\n            #Get quantities at current integration point\n            x = GT.coordinate(uh_point)\n            dV = GT.weight(uh_point)\n            uhx = GT.field(GT.value,uh_point)\n\n            #Add contribution\n            s += abs2(uhx-g.definition(x))*dV\n        end\n    end\n\n    #Compute the l2 norm\n    el2 = sqrt(s)\nend\n\n#Allocate matrix for free columns\nA_alloc = GT.allocate_matrix(T,V,V,Ω)\n\n#Allocate matrix for dirichlet columns\nfree_or_dirichlet=(GT.FREE,GT.DIRICHLET)\nAd_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet)\n\n#Fill allocations with the function we wrote above\nassemble_matrix!(A_alloc,Ad_alloc,V,dΩ)\n\n#Compress matrix into the final format\nA = GT.compress(A_alloc)\nAd = GT.compress(Ad_alloc)\n\n#Build the linear system\nxd = GT.dirichlet_values(uhd)\nb = -Ad*xd\np = LinearSolve.LinearProblem(A,b)\n\n#Solve the problem\nsol = LinearSolve.solve(p)\nuh = GT.solution_field(uhd,sol)\n\n#Integrate the error l2 norm\n#with the function we wrote above\nel2 = integrate_l2_error(g,uh,dΩ)\n@assert el2 < 1.0e-9\nnothing # hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"src_md/manual_mesh_partitioning/#Mesh-partitioning","page":"Mesh partitioning","title":"Mesh partitioning","text":"One can partition mesh objects and distribute them over different process for computations on large-scale parallel systems. PartitionedArrays.jl is used under-the-hood to distribute the vectors defining the mesh object. This allows one to use several backends including MPI (by default), and the debug-backend of PartitionedArrays for developing and debugging purposes.","category":"section"},{"location":"src_md/manual_mesh_partitioning/#Data-partition-model","page":"Mesh partitioning","title":"Data partition model","text":"A partitioned mesh is made of the same vectors as a sequential mesh, except for the fact that these vectors are of type PVector, the type representing a distributed vector in PartitionedArrays. Thus, one can work with a partitioned mesh as with a sequential mesh, as long as you don't index the PVector objects directly (which is intentionally forbidden by PartitionedArrays for performance reasons). The usage of partitioned meshes is transparent to the user in most of the cases, as one rarely works with the underlying data directly. Functions that you call on a partitioned mesh and access the underlying mesh data, are dispatched to parallel implementations that carefully access the partitioned data. In particular, types that build on top of a partitioned mesh also distribute data using PVector objects. The same usage remarks apply to them.\n\nThe mesh data in a mesh object is partitioned as follows:\n\nGT.node_coordinates(mesh) is a PVector distributed over nodes containing node coordinates.\nGT.face_nodes(mesh,d) is a PVector distributed over d-faces of containing global node ids.\nGT.reference_spaces(mesh,d) is typically a small tuple which is replicated across all processes.\nGT.face_reference_id(mesh,d) is a PVector distributed over d-faces  containing global reference indices.\nGT.group_faces(mesh,d) is a Dict{String,PVector} object whose keys are replicated on all processes. GT.group_faces(mesh,d)[key] is a PVector distributed over the faces in this group containing global face ids.\nOther vectors like normals(mesh) are distributed following the same principle.\n\nAll these PVector objects only include own indices and point to global indices.  This allows us to distribute node and face data in an arbitrary way.","category":"section"},{"location":"src_md/manual_mesh_partitioning/#Creating-partitioned-meshes","page":"Mesh partitioning","title":"Creating partitioned meshes","text":"A partitioned mesh can be created with function with_mesh_partitioner.","category":"section"},{"location":"src_md/manual_mesh_partitioning/#Example","page":"Mesh partitioning","title":"Example","text":"Create a 3D mesh from a msh file partitioned into 5 parts. Visualize the mesh using colors according to part owner.\n\nmodule mesh_partitioning_1 # hide\nimport GalerkinToolkit as GT\nimport GLMakie\nimport Makie\nimport FileIO # hide\n\nparts = 1:5\nmesh = GT.with_mesh_partitioner(;parts) do\n    assets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\n    msh_file = joinpath(assets_dir,\"model.msh\")\n    GT.mesh_from_msh(msh_file)\nend\n\n#Visualize it\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\ncolor = GT.FaceColor(\"__OWNER__\")\nGT.makie_surfaces!(mesh;color)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_12.png\"),Makie.current_figure()) # hide\nend # hide\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"src_md/manual_mesh_partitioning/#GalerkinToolkit.with_mesh_partitioner-src_md-manual_mesh_partitioning","page":"Mesh partitioning","title":"GalerkinToolkit.with_mesh_partitioner","text":"with_mesh_partitioner(mesher[,partitioner];[parts])\n\nGenerate a mesh calling mesher() partition it, and distribute it over the part ids in parts.\n\nArguments\n\nFunction mesher() should have no arguments and returns a sequential mesh object. This function is called only on one process.\npartitioner [optional]: A function that takes a graph encoded as a sparse matrix, and returns a vector containing the part id of each node in the graph. Defaults to Metis.partition.\n\nKeyword arguments\n\nparts [optional]: A vector containing the part indices 1:P where P is the number of parts in the data distribution. By default, P is the number of MPI ranks and 1:P is distributed one item per rank.\n\n\n\n\n\n","category":"function"},{"location":"src_md/example_poisson_equation/#Poisson-equation","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"section"},{"location":"src_md/example_poisson_equation/#Problem-statement","page":"Poisson equation","title":"Problem statement","text":"We want to solve a simple Poisson equation, but this time on a more complex domain and also including Neumann boundary conditions.  Dirichlet boundary conditions are applied on Gamma_rm D, non-homogeneous Neumann conditions are applied on Gamma_rm N,   and homogeneous Neumann boundary conditions are applied on the remaining portion of the boundary. The computational domains are defined in the mesh file model.msh. The domain Omega is represented by the 3D faces in this mesh. The domain Gamma_rm D is represented by the physical group named \"sides\" and Gamma_rm N is the union of the physical groups named \"circle\", \"triangle\", and \"square\".\n\nFormally, the problem to solve is: find the scalar field u such that\n\nleftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton Gamma_rm D\nnabla ucdot n = h  texton  Gamma_rm N\nnabla ucdot n = 0  textelsewhere on  partial Omega\nendaligned\nright\n\nbeing n the outwards unit normal vector to partialOmega. In this example, we chose f(x) = 1, g(x) = 2, and h(x)=3. The variable x is the position vector x=(x_1x_2x_3).","category":"section"},{"location":"src_md/example_poisson_equation/#Numerical-scheme","page":"Poisson equation","title":"Numerical scheme","text":"We use a conventional Galerkin finite element (FE) method with conforming Lagrangian FE spaces (see, e.g., [1]).  The weak form equation we solve consists in finding u_hin V_g such that a(u_hv) = ell(v) for all vin V_0. To this end we build a space V spanned by continuous and piece-wise Lagrangian basis functions. The auxiliary spaces V_g and V_0 are the subsets of V that fulfill the Dirichlet boundary condition g and 0 on partialOmega respectively. The bilinear and linear forms are\n\n  a(uv) doteq int_Omega nabla v cdot nabla u  rm dOmega quad b(v) doteq int_Omega v f   rm  dOmega + int_Gamma_rm N v h  rm dGamma_rm N\n\nThis equation results in a system of linear algebraic equations that is solved using an external linear solver from LinearSolve.jl.","category":"section"},{"location":"src_md/example_poisson_equation/#Implementation","page":"Poisson equation","title":"Implementation","text":"import FileIO # hide\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport LinearSolve\nimport ForwardDiff\nimport GLMakie as Makie\n\n#Read the mesh file\nassets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"model.msh\")\nmesh = GT.mesh_from_msh(msh_file)\n\n#Geometry\ndirichlet_names = [\"sides\"]\nneumann_names = [\"circle\", \"triangle\", \"square\"]\nΩ = GT.interior(mesh)\nΓd = GT.boundary(mesh;group_names=dirichlet_names)\nΓn = GT.boundary(mesh;group_names=neumann_names)\n\n#Define forcing data\nf = GT.analytical_field(x->1.0,Ω)\ng = GT.analytical_field(x->2.0,Ω)\nh = GT.analytical_field(x->3.0,Ω)\n\n#Define the interpolation space.\nk = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n\n#Interpolate Dirichlet values.\nT = Float64\nuhd = GT.zero_dirichlet_field(T,V)\nGT.interpolate_dirichlet!(g,uhd)\n\n#Define numerical integration.\ndegree = 2*k\ndΩ = GT.measure(Ω,degree)\ndΓn = GT.measure(Γn,degree)\nnothing # hide\n\n#Define weak form.\n∇ = ForwardDiff.gradient\na = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\nl = v -> GT.∫( x->v(x)*f(x), dΩ) + GT.∫( x->v(x)*h(x), dΓn)\n\n#Assemble the problem and solve it\np = GT.SciMLBase_LinearProblem(uhd,a,l)\nsol = LinearSolve.solve(p)\n\n#Build the FE solution.\nuh = GT.solution_field(uhd,sol)\n\n#Visualize the solution.\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Ω;color=uh)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_1.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"section"},{"location":"src_md/example_poisson_equation/#Explicit-integration-loops","page":"Poisson equation","title":"Explicit integration loops","text":"This other code version implements the integration loops manually instead of relying on the underlying automatic code generation. It shows how to handle the source term and the Neumann boundary condition.\n\n#Manually written assembly function\n#Always use a function, never the global scope\nfunction assemble_in_Ω!(A_alloc,Ad_alloc,b_alloc,V,f,dΩ)\n\n    #Iterators to the quantities on the\n    #integration points\n    tabulate = (GT.value,∇)\n    compute = (GT.coordinate,)\n    V_faces = GT.each_face(V,dΩ;tabulate,compute)\n\n    #Temporaries\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Numerical integration loop\n    for V_face in V_faces\n\n        #Get quantities at current face\n        dofs = GT.dofs(V_face)\n\n        #Reset face matrix\n        fill!(Auu,zero(T))\n        fill!(bu,zero(T))\n\n        #Loop over integration points\n        for V_point in GT.each_point(V_face)\n\n            #Get quantities at current integration point\n            x = GT.coordinate(V_point)\n            dV = GT.weight(V_point)\n            dof_s = GT.shape_functions(GT.value,V_point)\n            dof_∇s = GT.shape_functions(∇,V_point)\n\n            #Fill in face matrix and vector\n            for (i,dofi) in enumerate(dofs)\n                v = dof_s[i]\n                ∇v = dof_∇s[i]\n                bu[i] += f.definition(x)*v*dV\n                for (j,dofj) in enumerate(dofs)\n                    ∇u = dof_∇s[j]\n                    Auu[i,j] += ∇v⋅∇u*dV\n                end\n            end\n        end\n\n        #Add face contribution to the\n        #global allocations\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n        GT.contribute!(Ad_alloc,Auu,dofs,dofs)\n        GT.contribute!(b_alloc,bu,dofs)\n    end\nend\n\n#Manually written assembly function\n#Always use a function, never the global scope\nfunction assemble_in_Γn!(b_alloc,V,h,dΓn)\n\n    #Iterators to the quantities on the\n    #integration points\n    tabulate = (GT.value,)\n    compute = (GT.coordinate,)\n    V_faces = GT.each_face(V,dΓn;tabulate,compute)\n\n    #Temporaries\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Numerical integration loop\n    for V_face in V_faces\n\n        #Get quantities at current face\n        dofs = GT.dofs(V_face)\n\n        #Reset face vector\n        fill!(bu,zero(T))\n\n        #Loop over integration points\n        for V_point in GT.each_point(V_face)\n\n            #Get quantities at current integration point\n            x = GT.coordinate(V_point)\n            dV = GT.weight(V_point)\n            dof_s = GT.shape_functions(GT.value,V_point)\n\n            #Fill in face matrix and vector\n            for (i,dofi) in enumerate(dofs)\n                v = dof_s[i]\n                bu[i] += h.definition(x)*v*dV\n            end\n        end\n\n        #Add face contribution to the\n        #global allocations\n        GT.contribute!(b_alloc,bu,dofs)\n    end\nend\n\n#Allocate matrix for free columns\nA_alloc = GT.allocate_matrix(T,V,V,Ω)\n\n#Allocate matrix for dirichlet columns\nfree_or_dirichlet=(GT.FREE,GT.DIRICHLET)\nAd_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet)\n\n#Allocate rhs vector\nb_alloc = GT.allocate_vector(T,V,Ω,Γn)\n\n#Fill allocations with the function we wrote above\nassemble_in_Ω!(A_alloc,Ad_alloc,b_alloc,V,f,dΩ)\nassemble_in_Γn!(b_alloc,V,h,dΓn)\n\n#Compress matrix and vector into the final format\nA = GT.compress(A_alloc)\nAd = GT.compress(Ad_alloc)\nb = GT.compress(b_alloc)\n\n#Build the linear system\nxd = GT.dirichlet_values(uhd)\nb .= b .- Ad*xd\np = LinearSolve.LinearProblem(A,b)\n\n#Solve the problem\nsol = LinearSolve.solve(p)\nuh = GT.solution_field(uhd,sol)\n\n#Visualize the solution.\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Ω;color=uh)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_2.png\"),Makie.current_figure()) # hide\nnothing # hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"manual/for_developers/#For-developers","page":"For developers","title":"For developers","text":"","category":"section"},{"location":"manual/for_developers/#Building-the-documentation-locally","page":"For developers","title":"Building the documentation locally","text":"","category":"section"},{"location":"manual/for_developers/#Setup-the-docs-folder-environment","page":"For developers","title":"Setup the docs folder environment","text":"We assume that your terminal is located in the root folder of the GalerkingToolkit.jl repo. Open Julia, pointing to the docs folder.\n\n$ julia --project=docs/\n\nDevelop your current copy of GalerkingToolkit.\n\njulia> ]\n(docs) pkg> dev .\n\nYou will need to do this each time the dependencies of the documentation or of GalerkinToolkit change.","category":"section"},{"location":"manual/for_developers/#Standard-build","page":"For developers","title":"Standard build","text":"After the setup, exit package mode and run\n\njulia> include(\"docs/make.jl\")\n\nThis will take a while. When it is done, you will have the html docs in the folder docs/build.","category":"section"},{"location":"manual/for_developers/#Visualizing-the-documentation","page":"For developers","title":"Visualizing the documentation","text":"The easiest way to visualize the documentation is using LiveServer as follows.\n\njulia> using LiveServer\nserve(dir=\"docs/build/\")\n\nAfter it, your docs will be served at the given url.\n\nIf nor yet done, you can install LiveServer as follows. We recommend to install it in your global environment.\n\njulia> ]\npkg> activate\npgk> add LiveServer","category":"section"},{"location":"manual/for_developers/#Quick-build","page":"For developers","title":"Quick build","text":"The standard build takes a long time since it runs several examples. This delay makes this approach impractical to write documentation, since one needs to build the docs often to check the final result.\n\nTo avoid this, one can run all the files in docs/src/src_jl in advance using\n\njulia> include(\"docs/make_media.jl\")\n\nand then one can quickly build the documentation with\n\njulia> include(\"docs/make_with_media.jl\")\n\nThis will work as long as you are not including new figures or animations that are generated by running the files in the docs/src/src_jl folder. Otherwise you will need to run the particular file with\n\njulia> include(\"docs/src/src_jl/<file that generates the figure>.jl\")\n\nor running again\n\njulia> include(\"docs/media.jl\")\n\nThe output documentation is not exactly the same as the generated with the standard build method, but it is good enough for development.","category":"section"},{"location":"manual/for_developers/#Performance-Benchmarks","page":"For developers","title":"Performance Benchmarks","text":"There is a benchmark suite defined in GalerkinToolkitExamples/benchmarks. This uses BenchmarkTools.jl to perform the timings and github-action-benchmark to collect the results and store them in the benchmarks branch. Upon merging of a PR, and after the docs have built, the benchmark results are copied from the benchmarks branch into the gh-pages branch. This is required to prevent overwriting of the previous results by docs deployment etc.\n\nGraphs of performance changes over time (per commit hash) can then be viewed here: https://galerkintoolkit.github.io/GalerkinToolkit.jl/dev/bench/.\n\nThe github action can be configured (in .github/workflows/CI.yml, job benchmark) to fail if the performance change is beyond a given threshold. Look for the alert-threshold: and fail-on-alert: keys.\n\nMore benchmarks can be added (or existing ones modified) in GalerkinToolkitExamples/benchmarks/run_benchmarks.jl.","category":"section"},{"location":"manual/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"GalerkinToolkit is a high-performance finite element toolbox fully implemented in the Julia programming language. Its mission is to provide general-purpose building blocks of finite element (FE) methods to solve a wide variety of partial differential equations (PDEs), using diverse numerical schemes, and across a range of computing platforms, from laptops to supercomputers.\n\nThe toolkit envisions a unified framework that addresses the needs of numerical analysts, domain scientists, and high-performance computing experts; offering a rich API with multiple levels of abstraction:\n\nHigh-level API: Enables users to solve PDEs conveniently using mathematical abstractions instead of implementing low-level code by hand.\nLow-level API: Grants direct access to underlying numerical quantities, allowing custom implementations of numerical schemes or advanced code optimizations not available through the high-level interface.","category":"section"},{"location":"manual/introduction/#Features","page":"Introduction","title":"Features","text":"GalerkinToolkit provides tools for:\n\nReading and partitioning computational meshes generated with external mesh generators.\nDefining discrete interpolation spaces on triangulated manifolds, supporting both continuous and discontinuous interpolations.\nIntegrating functions, linear, and bilinear forms for scalar- and vector-valued equations, including single- and multi-field systems.\nSupporting both simplex and hypercube face geometries, with high-order interpolation capabilities.\nDiscretizing a wide range of PDEs into systems of linear, nonlinear, and differential-algebraic equations.\nRepresenting algebraic problems in formats compatible with external solvers.\nVisualization and post-process of results.\n\nEven though not currently available, these other features are being implemented, or are planned to be implemented in the near future:\n\nAutomatic differentiation for non-linear PDEs and gradient-based optimization methods.\nMatrix-free bilinear forms.\nH(div) and H(curl) interpolation spaces.\nDistributed assembly.\nSingle- and multi-GPU support.","category":"section"},{"location":"manual/introduction/#Novelties","page":"Introduction","title":"Novelties","text":"GalerkinToolkit is certainly not the first FEM software project, but it introduces it introduces a novel design:\n\nUnified high- and low-level APIs–  It combines the vision of frameworks like FEniCS and libraries like Deal-ii in a single package and in a single programming language. It addresses the two-language problem of previous FE projects that consider a Python front-end for easiness of use and a C/C++ backend for performance. With GalerkinToolkit, you can use a concise high-level syntax or directly implement integration loops using low-level building blocks, depending on your needs.\nDeep integration with the Julia ecosystem– GalerkinToolkit reuses existing Julia packages in numerous situations. For example:\nComputational meshes generated with Gmsh.\nDifferential operators from ForwardDiff.jl\nVector/tensor types via StaticArrays.jl and Tensors.jl\nExternal solvers for algebraic systems from PartitionedSolvers.jl, PetscCall.jl, LinearSolve.jl, NonLinearSolve.jl, and DifferentialEquations.jl.\nVisualization with Makie.jl and WriteVTK.jl\nThe GalerkinToolkit Form Compiler (GTFC)– GTFC uses Julia’s metaprogramming capabilities to generate efficient code from high-level mathematical abstractions. Unlike other compilers like FFC or TSFC:\nIt does not rely on an external DSL like UFL. It considers a sub-set of the Julia programming language as alternative.\nIn consequence, it allows user-defined types in the weak form.\nMoreover, it supports advanced use cases, such as coupling surface and volume arguments in multi-field weak forms both for continuous and discontinuous interpolations.\nA major overhaul of Gridap– GalerkinToolkit began as a full reimplementation of the core ideas behind Gridap. While Gridap is based on lazily mapped arrays, GalerkinToolkit centers on form compilation and a low-level API designed to easily deal with quantities at integration points. These provide both a loop-free high-level API and manual control of integration loops.","category":"section"},{"location":"manual/introduction/#Installation","page":"Introduction","title":"Installation","text":"GalerkinToolkit is a registered package in the official Julia package registry. As such, you can install GalerkinToolkit easily using the Julia package manager.\n\nOpen Julia and type ] to enter package mode.\n\njulia> ]\n\nThen, type\n\npkg> add GalerkinToolkit\n\nThis installs GalerkinToolkit and all its dependencies.\n\nPress ctrl+C to go back to standard mode. Now, you can type\n\njulia> import GalerkinToolkit as GT\n\nto start using GalerkinToolkit.\n\nYou will need to have Julia installed in your system. See the official Julia installation instructions here.","category":"section"},{"location":"manual/introduction/#This-manual","page":"Introduction","title":"This manual","text":"It provides detailed explanations so that users build an understanding of the library. We start detailing the geometrical foundations of the library: computational meshes and domains. Then, we cover the construction of interpolation spaces and the numerical integration capabilities. Finally, we explain the post-processing layer including the visualization of results.","category":"section"},{"location":"src_md/example_stokes/#Stokes-lid-driven-cavity","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"(Image: )","category":"section"},{"location":"src_md/example_stokes/#Problem-statement","page":"Stokes lid-driven cavity","title":"Problem statement","text":"warning: Warning\nTODO","category":"section"},{"location":"src_md/example_stokes/#Numerical-scheme","page":"Stokes lid-driven cavity","title":"Numerical scheme","text":"warning: Warning\nTODO","category":"section"},{"location":"src_md/example_stokes/#Implementation","page":"Stokes lid-driven cavity","title":"Implementation","text":"import GalerkinToolkit as GT\nimport LinearSolve\nimport GLMakie as Makie\nimport ForwardDiff\nimport StaticArrays\nimport Tensors\nusing LinearAlgebra\nimport FileIO # hide\n\n#Mesh\ndomain = (0,1,0,1)\ncells = (20,20)\nD = length(cells)\nmesh = GT.cartesian_mesh(domain,cells)\n\n#Domains\nΩ = GT.interior(mesh)\nΓ = GT.boundary(mesh;group_names=[\"1-face-1\",\"1-face-2\",\"1-face-3\",\"1-face-4\"])\ng = GT.analytical_field(Γ;piecewise=true) do x,name\n    if name == \"1-face-2\"\n        StaticArrays.SVector(1,0)\n    else\n        StaticArrays.SVector(0,0)\n    end\nend\n\n#Velocity interpolation\norder = 2\ntensor_size=Val((D,))\ndirichlet_boundary = Γ\nV = GT.lagrange_space(Ω,order;tensor_size,dirichlet_boundary)\n\n#Pressure interpolation\nspace_type=:P\ndirichlet_boundary=GT.last_dof()\nQ = GT.lagrange_space(Ω,order-1;space_type,dirichlet_boundary)\n\n#Cartesian product space\nVxQ = V × Q\n\n#Dirichlet condition\nuhph_dirichlet = GT.zero_dirichlet_field(Float64,VxQ)\nuhd, = uhph_dirichlet\nGT.interpolate_dirichlet!(g,uhd)\n\n#Weak form\ndΩ = GT.measure(Ω,2*order)\n∇ = ForwardDiff.jacobian\ndiv(u,x) = tr(∇(u,x))\na((u,p),(v,q)) = GT.∫( x-> ∇(v,x)⋅∇(u,x) - div(v,x)*p(x) + q(x)*div(u,x), dΩ)\nl((v,q)) = 0\n\n#Assemble linear problem and solve it\np = GT.SciMLBase_LinearProblem(uhph_dirichlet,a,l)\nsol = LinearSolve.solve(p)\n\n#Get solution fields\nuh,ph = GT.solution_field(uhph_dirichlet,sol)\n\n#Visualize solution\nfig = Makie.Figure()\naspect = Makie.DataAspect()\nax = Makie.Axis(fig[1,1];aspect)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nshading = Makie.NoShading\nGT.makie_surfaces!(Ω;color=ph,shading)\nGT.makie_arrows2d!(Ω,uh;color=x->norm(uh(x)),lengthscale=0.1)\nFileIO.save(joinpath(@__DIR__,\"fig_stokes_1.png\"),Makie.current_figure()) # hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"src_md/manual_domains/#Domains","page":"Domains","title":"Domains","text":"\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"Introduction\nMesh geometry\nMesh topology\nMesh generation\nMesh partitioning\nFor developers","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#Introduction-to-the-FEM","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"by Francesc Verdugo (VU Amsterdam)\n\nIn this lecture, we will learn:\n\nThe gist of the finite element method (FEM).\nHow to solve a simple partial differential equation (PDE) with it.\nHow to express the key concepts in code using GalerkinToolkit.\n\nThis lecture is useful even if you are a FEM expert and you want to learn GalerkinToolkit. It will walk you through the key parts of the library.","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#Problem-statement","page":"Introduction to the FEM","title":"Problem statement","text":"We show how to solve a simple PDE with the FEM. To make this introduction really an introduction we consider the \"hello, world\" PDE: the Poisson equation.  Our goal is to solve it when adding Dirichlet boundary conditions. These are the inputs of the problem. A domain OmegasubsetmathbbR^d with d being the number of spatial dimensions (d=2 in this example), and two functions f, g such that fgOmegarightarrowmathbbR. The problem is formalized as finding the function uOmegarightarrowmathbbR such that\n\nleftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright\n\nwhere Delta u = sum_i=1^d partial^2 u  partial x_i^2 is the Laplace operator and partialOmega is the boundary of Omega. We define Omega as a disk of radius one. This is a simple geometry, but yet more complex than a simple two-dimensional box. With this, we illustrate that FEM can be used to solve PDEs on complex geometries beyond simple \"boxes\".","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#The-method-of-manufactured-solutions","page":"Introduction to the FEM","title":"The method of manufactured solutions","text":"We are going to select f and g in such a way u is a known function. This will allow us to compare the numerical approximation computed with FEM against the theoretical exact solution u. This technique is known as the \"method of manufactured solutions\". Note that u is not known in practical applications.\n\nLet us, \"manufacture\" f and g such that function u(x)=(sum_i=1^d x_i)^p is the solution of the PDE above. The scalar p is a given integer p0. It will be useful to see how the numerical solution will behave for different values of p.\n\nTo manufacture functions f and g, we apply the PDE operators to the expression for u. Function f is to be computed as f(x)= -Delta ((sum_i=1^d x_i)^p) and g is simply g(x)=(sum_i=1^d x_i)^p. Applying the Laplace operator to (sum_i=1^d x_i)^p, we get the closed-form expression for f, namely f(x)= -d cdot p(p-1)(sum_i=1^d x_i)^(p-2).","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#Numerical-approximation","page":"Introduction to the FEM","title":"Numerical approximation","text":"The FEM transforms a PDE into a system of linear algebraic equations of the form Ax=b, where A is a matrix and b is a vector. This reduces the problem of finding function u to finding vector x, which can be done on a computer using arrays and other numeric data structures. The FEM does not look for the exact function u, but for approximations of it that can be written as a linear combination of a finite number of basis functions,\n\nu^mathrmfem(x)=sum_j=1^N alpha_j s_j(x)\n\nwhere alpha_i are the coefficients of the linear combination and s_i are functions such that s_iOmegarightarrowmathbbR. The integer N is the number of terms in the linear combination. The basis functions s_i are also called \"shape functions\" or \"hat functions\". The goal of FEM is to find suitable values for alpha_i and s_i(x) such that u^mathrmfem is a good approximation of the exact solution u: u^mathrmfem(x)approx u(x) for points xinOmega. The more computational effort we put in building function u^mathrmfem the better will be the approximation.","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#Workflow","page":"Introduction to the FEM","title":"Workflow","text":"Function u^mathrmfem is built as follows. First, we define the auxiliary functions s_i(x). This step is referred to as the \"numerical discretization\" and entails defining a computational mesh and a finite element (FE) function space. The next step is building a system of linear algebraic equations Ax=b. This step is called the \"FEM assembly\" step. Then, one solves for the vector x in what is called the \"solver\" or \"solution\" step. At this points, the coefficients alpha_i can be computed using both vector x and the Dirichlet boundary conditions of the PDE. The final step is typically some post-process of function u^mathrmfem. For instance, visualize it, store it in a file, compute some quantity of interest, etc. In summary, these are the key phases in a FEM computation:\n\nDiscretization\nAssembly\nSolution\nPost-process","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#Computational-meshes","page":"Introduction to the FEM","title":"Computational meshes","text":"The FEM starts by building a \"triangulation\" mathcalT of the domain Omega in which the PDE is defined. A triangulation mathcalT is a set of simpler domains T_ksubsetmathbbR^d, whose union is an approximation of Omega,  cup_k=1^M T_kapproxOmega. Each domain T_k is called an \"element\", a \"cell\" or a \"face\", and they are typically simple geometries such as triangles, tetrahedra, hexahedra, etc. The integer M denotes the number of elements. The triangulation is also called a computational \"mesh\" or a computational \"grid\".\n\nLet's build a mesh for our domain Omega using code. First, let us load all packages that we will use in this lecture:\n\nusing LinearAlgebra\nusing Random\nimport GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide\n\nA common practice in GalerkinToolkit is to load packages in the Julia standard library with using. Other packages are loaded with import. This makes clear from which package each function comes from, while assuming that developers already know functions in the standard library.\n\nThe following cell builds a triangulation (a mesh object) using the external mesh generation tool GMSH. The variable mesh_size controls how small are the cells in the mesh. We start with a coarse mesh to make visualization easier. We are not going to comment in detail all code lines. We will discuss only the parts relevant in this high-level introduction. You can refer to the API documentation and other tutorials when needed.\n\nmesh_size = 0.3\nR = 1 #Radius\nmesh = GT.with_gmsh() do gmsh\n    dim = 2\n    gmsh.option.set_number(\"General.Verbosity\", 2)\n    circle_tag = gmsh.model.occ.add_circle(0,0,0,R)\n    circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])\n    circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])\n    gmsh.model.occ.synchronize()\n    gmsh.model.model.add_physical_group(dim,[circle_surf_tag],-1,\"Omega\")\n    gmsh.option.set_number(\"Mesh.MeshSizeMax\",mesh_size)\n    gmsh.model.mesh.generate(dim)\n    GT.mesh_from_gmsh(gmsh)\nend\nnothing # hide\n\nThe mesh we just created can be visualized both with Paraview and Makie. We use Makie in this lecture.\n\naspect = Makie.DataAspect()\nshading = Makie.NoShading\nkwargs = (;axis=(;aspect),shading)\nGT.makie_surfaces(mesh;color=:pink,kwargs...)\nGT.makie_edges!(mesh;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_mesh.png\"),Makie.current_figure()) # hide\n\n(Image: )","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#Computational-domains","page":"Introduction to the FEM","title":"Computational domains","text":"Note that two domains appear in the definition of the PDE above, the domain Omega and its boundary partialOmega. We need to build data objects representing them to solve the PDE with GalerkinToolkit. They are built from the mesh objects as follows:\n\nΩ = GT.interior(mesh)\nnothing # hide\n\nand\n\n∂Ω = GT.boundary(mesh)\nnothing # hide\n\nWe can also visualize them using Makie.\n\nGT.makie_surfaces(Ω;color=:pink,kwargs...)\nGT.makie_edges!(∂Ω;color=:blue,linewidth=3)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_domains.png\"),Makie.current_figure()) # hide\n\n(Image: )\n\nNote that Ω is indeed an approximation of the unit disk (visualized as a pink surface), and ∂Ω is its boundary (visualized with thick blue lines).","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#FE-space","page":"Introduction to the FEM","title":"FE space","text":"Let us now build the data structure representing the finite element function u^mathrmfem. We need two ingredients, the functions s_i and the coefficients α_i. Functions s_i are linearly independent and can be understood as the basis of a vector space V=mathrmspans_1ldotss_N. This space is called the FE space. There are many ways of defining FE spaces. Here, we will use the simplest one, which is based on Lagrange polynomials. To build it with GalerkinToolkit, we need the computational domain on which the functions of the space are defined and their polynomial degree, since these function are polynomials inside the cells of the mesh.\n\ndegree = 2\nV = GT.lagrange_space(Ω,degree)\nnothing # hide\n\nWe will discus the mathematical derivation of this FE space in another lecture. For now, it is enough to understand that the object V has information about the basis functions s_i. For instance, you can get the number of basis functions with\n\nN = GT.num_dofs(V)\n\nThe word \"dofs\" stands for degrees of freedom (DOFs). Each coefficent alpha_i can be understood as a degree of freedom, i.e., a quantity that can be tweaked to modify function u^mathrmfem.\n\nThe coefficients alpha_i are unknown at this point. We will compute them later. For the moment, we can build a mock u^mathrmfem using some random coefficients alpha_i just to see the connection between the coefficients  alpha_i and the resulting function u^mathrmfem. We create them as a random vector of length N.\n\nRandom.seed!(1)\nα = rand(N)\nnothing # hide\n\nWe create the function from these coefficients and the FE space as follows:\n\nu_fem = GT.discrete_field(V,α)\nnothing # hide\n\nAs suggested by the function name, the numerical approximation is called \"discrete field\" in GalerkinToolkit. The field is \"discrete\" since it is expressed in terms of a finite number of degrees of freedom.\n\nLet's us visualize it. We do this by plotting domain Omega, using the function value as the color code.\n\nfig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u_fem,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_rand_field.png\"),Makie.current_figure()) # hide\n\n(Image: )\n\nBy looking into the figure it is clear that function u^mathrmfem(x) is indeed a function that can be evaluated at any point inside the domain Omega, i.e., a field.","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#Dual-operators","page":"Introduction to the FEM","title":"Dual operators","text":"The FEM also consider a basis for V^prime, the dual space of V. Basis functions in the dual space are linear operators sigma_iVrightarrowmathbbR that map functions in the original (primal) space V into real values. The particular definition of these operators is not important in this lecture. See them as black boxes, that fulfill  these properties: The operators sigma_i are linear, there is one operator sigma_i for each shape function s_i, and they  are related with this formula sigma_i(s_j)=delta_ij, where delta_ij is Kroneker's delta. Operator sigma_i maps the shape function s_i to one, sigma_i(s_i)=1, and maps the other shape functions to zero, sigma_i(s_j)=0 for ineq j. This property allows us to compute alpha_i as the application of operator sigma_i to the numerical approximation u^mathrmfem, namely alpha_i=sigma_i(u^mathrmfem). You can understand sigma_i(u^mathrmfem) as \"extract\" coefficient alpha_i from u^mathrmfem. You can easily prove this by taking sigma_i(u^mathrmfem) = sigma_i(sum_j=1^N alpha_j s_j) and considering that sigma_i is linear and sigma_i(s_j)=delta_ji.","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#FE-interpolation","page":"Introduction to the FEM","title":"FE interpolation","text":"Using the dual operators, we can define an interpolation operator that builds a function in the FE space V from a given function fOmegarightarrowmathbbR :\n\n(Pi^mathrmfem f)(x) = sum_j=1^N sigma_j(f) s_j(x)\n\nLet us do this interpolation using code for a particular function. First, we need to define the function we want to interpolate\n\nf = GT.analytical_field(Ω) do x\n    sin(4*pi*x[1])*cos(4*pi*x[2])\nend\nnothing # hide\n\nWe have build an \"analytical field\", which is a field defined by an analytical function. Let us visualize it.\n\nfig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=f,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_f.png\"),Makie.current_figure()) # hide\n\n(Image: )\n\nWe interpolate the field using code\n\nf_fem = GT.interpolate(f,V)\nnothing # hide\n\nand we visualize the result\n\nfig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=f_fem,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_f_fem.png\"),Makie.current_figure()) # hide\n\n(Image: )\n\nNote that the interpolated field is an approximation of the original one. The \"noisier\" the original field, the worse will be the interpolation. Also the larger the number of DOFs in the space V the better will be the interpolation.","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#Free-and-Dirichlet-DOFs","page":"Introduction to the FEM","title":"Free and Dirichlet DOFs","text":"Remember that our goal is to find the coefficients α_i. Most of them are unknown, but not all. Note that the PDE states that u=g on the boundary partialOmega. With this information we can compute some of the coefficients alpha_i directly, without solving a linear system. To find out which coefficients are really unknown and which can be computed from the boundary condition, we classify the shape functions s_i into two groups: the s_i that are zero at any point of the boundary, s_i(x) = 0 for all xinpartialOmega, in one group, and the rest in the second group. We denote s^mathrmf_i the shape function number i in the first group, and s^mathrmd_i function number i in the second group. Letters \"f\" and \"d\" stand for \"free\" and \"Dirichlet\" as they will be associated with unknown (free) coefficients and coefficients computed from the Dirichlet condition respectively. Using this classification  of the shape functions, we can also classify the coefficients alpha_i, and the dual operators sigma_i. Consider starin(mathrmfmathrmd). The coefficient alpha^star_i is the one that multiplies s^star_i and sigma^star_i is its associated dual operator. We can also define the space V^star=mathrmspans^star_1ldotss^star_N^star as the subspace of V generated by the shape functions s^star_i. Finally,  we call N^star the number of shape functions s^star_i for starin(mathrmfmathrmd),  i.e, the number of free and Dirichlet DOFs.\n\nThe shape functions are classified in the code by creating a FE space that is aware of the Dirichlet boundary:\n\nV = GT.lagrange_space(Ω,degree;dirichlet_boundary=∂Ω)\nnothing # hide\n\nNow the DOFs in this space are split on two groups: free and Dirichlet. We can get the number of free DOFs\n\nN_f = GT.num_free_dofs(V)\n\nand the number of Dirichlet DOFs.\n\nN_d = GT.num_dirichlet_dofs(V)","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#Dirichlet-Field","page":"Introduction to the FEM","title":"Dirichlet Field","text":"Using the classification of nodes, we can decompose function u^mathrmfem(x) as the sum of two functions,\n\nu^mathrmfem(x)=u^mathrmf(x)+u^mathrmd(x)\n\nwith\n\nu^star(x)=sum_j=1^N^star alpha^star_j s^star_j(x) text for  starin(mathrmfmathrmd)\n\nNote that u^mathrmfin V^mathrmf is a linear combination of the \"free\" shape functions, and u^mathrmdin V^mathrmd is a linear combination of the \"Dirichlet\" shape functions.  This decomposition is useful because u^mathrmd can be directly computed from the Dirichlet Boundary condition. We refer to u^mathrmd as the \"Dirichlet field\". It is computed by building the coefficients alpha^mathrmd_i=sigma^mathrmd_i(g) as the application of the linear operators for the Dirichlet DOFs on function g. In other words, u^mathrmd is built as the interpolation of the Dirichlet function g onto the space V^mathrmd, u^mathrmd=Pi^mathrmd g. The interpolation to the spaces V^mathrmf and V^mathrmd of a given function f is defined as we did for V, but only taking the corresponding shape functions:\n\n(Pi^star f)(x) = sum_j=1^N^star sigma^star_j(f) s^star_j(x) text for  starin(mathrmfmathrmd)\n\nLet us build the Dirichlet field with code. First, we need to build an analytical field representing the Dirichlet function. We take p=3 for example.\n\ng = GT.analytical_field(Ω) do x\n    sum(x)^3\nend\nnothing # hide\n\nThen, we interpolate this field, but only on the Dirichlet DOFs, yielding the Dirichlet field\n\nu_d = GT.interpolate_dirichlet(g,V)\n\nNote that it is a function that (by definition) is possibly non-zero near the Dirichlet boundary.\n\nfig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u_d,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_diri.png\"),Makie.current_figure()) # hide\n\n(Image: )\n\nUsing the Dirichlet field, we can create function u^mathrmfem only from coefficients that are associated with free DOFs. These are going to be computed later by solving a system of linear equations, but we can create a mock version of them with randomly generated values. We generate a vector of length N^mathrmf because it should contain only \"free\" coefficients.\n\nRandom.seed!(2)\nα_f = rand(N_f)\nu_fem = GT.solution_field(u_d,α_f)\nnothing # hide\n\nIn the following figure, one can see that u^mathrmfem generated in this way has random values in the interior of Omega, while matching the Dirichlet boundary condition on partialOmega.\n\nfig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u_fem,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_fem_2.png\"),Makie.current_figure()) # hide\n\n(Image: )","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#The-weighted-residual-method","page":"Introduction to the FEM","title":"The weighted residual method","text":"To solve the problem now, we need to find the coefficients alpha^mathrmf_i associated with the free DOFs. The number of such coefficients is N^mathrmf. Hence, we have N^mathrmf unknowns, which suggests that we needs to consider N^mathrmf equations. These equations will follow from the PDE above.\n\nLet us introduce the residual of the PDE, namely r(v) = Delta v + f for a given function v. The operator r is such that r(u)=0 for the exact solution of the PDE. The residual provides an estimation of how good a function approximates the solution of the PDE. If r(v) is \"small\", then v is a good approximation of u as long as v also fulfills the Dirichlet boundary condition v=g on partialOmega. Our goal is to find the coefficients alpha^mathrmf_i for which the resulting function u^mathrmfem has a \"small\" residual r(u^mathrmfem). This approach however requires some caution. First, we need to define what \"small\" is. The second problem is that we cannot evaluate r(u^mathrmfem) as this value it is not well defined for all points xinOmega. Function u^mathrmfem is continuous, but its gradient is not continuous at the boundaries of the mesh cells. As a consequence the Laplace operator and the residual r it is not well defined on the cell boundaries.\n\nLet us visualize one of the components of the gradient of u^mathrmfem to confirm that it is discontinuous. First, let us define the nabla operator.\n\n∇ = ForwardDiff.gradient\nnothing # hide\n\nThen, we visualize the first component of the gradient as follows:\n\nfig = Makie.Figure()\ngrad1 = x->∇(u_fem,x)[1]\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=grad1,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_grad.png\"),Makie.current_figure()) # hide\n\n(Image: )\n\nIt is indeed discontinuous at the mesh cell boundaries.\n\nThe FEM solves this problem by considering to so-called \"weighted residual method\". First, the method provides a formal definition for what a \"small\" residual is. The method looks for a function u^mathrmfem such that\n\nint_Omega r(u^mathrmfem) s^mathrmf_i  dOmega = 0 text for  i=1ldotsN^mathrmf\n\nThat is, we want the integral of the residual times a free shape function s^mathrmf_i to be zero. Each free shape function provides an equation. Thus, the number of total equations that we build with this expression is N^mathrmf, which coincides with the number of unknowns. Perfect!\n\nNow, we need to address the second problem: we need to avoid computing Delta u^mathrmfem as this quantity is not well defined for function u^mathrmfem on cell boundaries. Let us expand the integral above, by in-lining the definition of r:\n\nint_Omega ( (Delta u^mathrmfem) s^mathrmf_i + f s^mathrmf_i ) dOmega = 0\n\nWe can get rid of the Laplace operator by using this identity\n\nnablacdot(nabla u^mathrmfem s^mathrmf_i) = (Delta u^mathrmfem) s^mathrmf_i + nabla u^mathrmfem cdot nabla s^mathrmf_i\n\nor equivalently\n\n (Delta u^mathrmfem) s^mathrmf_i = nablacdot(nabla u^mathrmfem s^mathrmf_i) - nabla u^mathrmfem cdot nabla s^mathrmf_i\n\nThis identity is analogous to the well known rule for the derivative of a product, but when the functions are multivariate functions. The quantity nabla v is the gradient of the scalar function v, which is a vector defined as nabla v_k = partial vpartial x_k. The value nablacdot w is the divergence of a vector function w, which is defined as nablacdot w = sum_k^d partial w_kpartial x_k.\n\nSubstituting for (Delta u^mathrmfem) s^mathrmf_i in the integral above, we get:\n\nint_Omega (nablacdot(nabla u^mathrmfem s^mathrmf_i) - nabla u^mathrmfem cdot nabla s^mathrmf_i + f s^mathrmf_i) dOmega = 0\n\nWe still have a second order derivative in the first term inside the integral. We can take rid of this one using the Gauss divergence theorem:\n\nint_Omega nablacdot(nabla u^mathrmfem s^mathrmf_i)  dOmega = int_partialOmega ncdot(nabla u^mathrmfem s^mathrmf_i) dpartialOmega\n\nwhere n is the unit normal vector on the boundary partialOmega pointing outwards to Omega. Note that the right hand side is an integral on the boundary and we classified the shape functions so that all s^mathrmf_i are zero at the boundary. Using s^mathrmf_i(x)=0 for any xinpartialOmega, we get:\n\nint_partialOmega ncdot(nabla u^mathrmfem s^mathrmf_i) dpartialOmega = 0\n\nUsing this result and rearranging terms, we get this new formulation of our equations:\n\n int_Omega nabla u^mathrmfem cdot nabla s^mathrmf_i  dOmega = int_Omega f s^mathrmf_i  dOmega text for  i=1ldotsN^mathrmf\n\nNote that this new formulation does not require computing second order derivatives. Thus, it is well suited for the numerical approximation u^mathrmfem. This equation is called the \"weak form\" of the PDE, since it puts weaker regularity requirements to the numerical approximation u^mathrmfem. In contrast, the original PDE formulation is called the \"strong form\". There are different types of weak forms. Each one is designed for a type of numerical approximation and PDE. This one is for the Poisson equation and continuous approximations with discontinuous gradients. Other weak forms exist for this PDE. For instance, \"discontinuous Galerkin\" methods build the numerical approximation such as it is discontinuous across cell boundaries. One needs to consider another weak form for this case, since we cannot even compute the gradient on cell boundaries.","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#System-of-linear-algebraic-equations","page":"Introduction to the FEM","title":"System of linear algebraic equations","text":"Let us rewrite the weak equation as a(u^mathrmfems^mathrmf_i) = ell(s^mathrmf_i) with\n\na(u^mathrmfems^mathrmf_i) =  int_Omega nabla u^mathrmfem cdot nabla s^mathrmf_i  dOmega\n\nand\n\nell(s^mathrmf_i)= int_Omega f s^mathrmf_i  dOmega\n\nIf we substitute\n\nu^mathrmfem = sum_j=1^N^mathrmfalpha^mathrmf_j s^mathrmf_j +sum_j=1^N^mathrmdalpha^mathrmd_j s^mathrmd_j\n\nwe get\n\nsum_j=1^N^mathrmfa(s^mathrmf_js^mathrmf_i)alpha^mathrmf_j = ell(s^mathrmf_i) - sum_i=1^N^mathrmda(s^mathrmd_js^mathrmf_i)alpha^mathrmd_j text for  i=1ldotsN^mathrmf\n\nWe have used the fact that a is linear in each one of its arguments to move it inside the sums. If we look closer, this can be written in matrix form as\n\nA^mathrmfalpha^mathrmf = b - A^mathrmdalpha^mathrmd\n\nwhere alpha^mathrmf and alpha^mathrmd are two vectors containing the coefficients alpha^mathrmf_i and alpha^mathrmd_i respectively. Values A^mathrmf and A^mathrmd are matrices, and b is a vector. They are defined as\n\nA^mathrmf_ij = a(s^mathrmf_js^mathrmf_i)\n\nA^mathrmd_ij = a(s^mathrmd_js^mathrmf_i)\n\nand\n\nb_i = ell(s^mathrmf_i)\n\nSolving for alpha^mathrmf, we find the unknown coefficients in u^mathrmfem.\n\nIn code, we can build these two matrices and vector using a high-level API. First, we define a measure object that allows us to do the integrals over Omega. This object uses a numerical quadrature internally. So, we need to specify the polynomial degree that we want to integrate exactly. Two times the degree of the interpolation space is a good rule of thumb.\n\nintegration_degree = 2*degree\ndΩ = GT.measure(Ω,integration_degree)\nnothing # hide\n\nThen, we need to define the field representing function f\n\nf = GT.analytical_field(Ω) do x\n    p=3\n    -2*p*(p-1)*sum(x)^(p-2)\nend\nnothing # hide\n\nand functions representing a and ell.\n\na = (u,v) -> GT.∫(x->∇(u,x)⋅∇(v,x), dΩ)\nℓ = v -> GT.∫(x->f(x)*v(x), dΩ)\nnothing # hide\n\nNow, we can create the matrix and the vector for free DOFs\n\nK_f = GT.assemble_matrix(a,Float64,V,V)\nb = GT.assemble_vector(ℓ,Float64,V)\nnothing # hide\n\nWe can also assembly the matrix for the Dirichlet DOFs using an optional argument. Here, we are asking for \"free\" rows and \"Dirichlet\" columns.\n\nfree_or_dirichlet = (GT.FREE,GT.DIRICHLET)\nK_d = GT.assemble_matrix(a,Float64,V,V;free_or_dirichlet)\nnothing # hide\n\nNote that to build the final right-hand-side of the system, we compute b-K^mathrmdalpha^mathrmd and we need the Dirichlet coefficients alpha^mathrmd. They can be taken from the Dirichlet field that we created before.\n\nα_d = GT.dirichlet_values(u_d)\nnothing # hide\n\nNow, we have all ingredients to build and solve the algebraic system:\n\nα_f = K_f\\(b-K_d*α_d)\nnothing # hide\n\nWe can finally create the function u^mathrmfem from the computed coefficients.\n\nu_fem = GT.solution_field(u_d,α_f)\nnothing # hide\n\nThere is a more compact (and efficient) way of building and solving the system. This one generates matrices K^mathrmf and K^mathrmd in a single loop internally. We create a linear problem object, we solve it, and we extract the solution field from it. This approach automatically handles the Dirichlet boundary conditions.\n\np = GT.PartitionedSolvers_linear_problem(u_d,a,ℓ)\ns = PS.solve(p)\nu_fem = GT.solution_field(u_d,s)\nnothing # hide\n\nFinally, we visualize the computed FEM solution.\n\nfig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u_fem,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_fem_3.png\"),Makie.current_figure()) # hide\n\n(Image: )\n\nLet us also define the manufactured solution u\n\nu = GT.analytical_field(Ω) do x\n    sum(x)^3\nend\nnothing # hide\n\nand visualize it\n\nfig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=u,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_sol.png\"),Makie.current_figure()) # hide\n\n(Image: )\n\nThey look very similar. It seems that we solved the PDE correctly (but we still need to conform it mathematically).","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#FE-error","page":"Introduction to the FEM","title":"FE error","text":"Lets us introduce the error field, i.e., the difference between the exact and numerical solution, e^mathrmfem(x) = u(x)- u^mathrmfem(x).\n\ne_fem = x -> u(x) - u_fem(x)\nnothing # hide\n\nVisualize it.\n\nfig = Makie.Figure()\n_,scene = GT.makie_surfaces(fig[1,1],Ω;color=e_fem,refinement=5,kwargs...)\nGT.makie_edges!(fig[1,1],Ω,color=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_error.png\"),Makie.current_figure()) # hide\n\n(Image: )\n\nNote that the error is not zero! Functions u and u^mathrmfem are not the same, the last one is just an approximation. The result looks promising, but how do we know for sure that this is the expected approximation? This is what we will learn in the next lecture!","category":"section"},{"location":"src_md/tutorial_intro_to_fem/#Conclusion","page":"Introduction to the FEM","title":"Conclusion","text":"We learned the key ingredients to solve a PDE with the FEM. This requires to define a discrete space, and look for a solution in this space that makes the residual of the PDE \"small\". To properly define what a \"small\" residual is, we used the weighted residual method. This also allowed us to rewrite the PDE into a new form called the weak form. This weak form is needed, because only the residual of the weak form makes sense for functions in the discrete space. We also learned that part of the coefficients of the numerical approximation are unknown. A subset of them can be computed directly by interpolating the Dirichlet boundary condition. We used the method of manufactured solutions to build a PDE with known solution so that we can compare it with the computed approximation.  We also learned how to represent all these concepts using GalerkinToolkit. In the next lecture, we will learn how to confirm that our computed approximation is mathematically correct.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"src_md/manual_visualization/#Visualization","page":"Visualization","title":"Visualization","text":"\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"src_md/example_hello_world_lm/#Lagrange-multipliers","page":"Lagrange multipliers","title":"Lagrange multipliers","text":"(Image: )","category":"section"},{"location":"src_md/example_hello_world_lm/#Problem-statement","page":"Lagrange multipliers","title":"Problem statement","text":"We solve the same PDE as in the Hello, World! example, but this time using an auxiliary field of Lagrange Multipliers to impose the Dirichlet boundary conditions.","category":"section"},{"location":"src_md/example_hello_world_lm/#Implementation","page":"Lagrange multipliers","title":"Implementation","text":"import FileIO # hide\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport ForwardDiff\nimport GLMakie as Makie\nimport LinearSolve\n\n#Geometry\ndomain = (0,1,0,1,0,1)\ncells = (4,4,4)\nmesh = GT.cartesian_mesh(domain,cells)\nD = GT.num_dims(mesh)\nn = GT.unit_normal(mesh,D-1)\nΩ = GT.interior(mesh)\nΓd = GT.boundary(mesh)\n\n#Functions\n∇ = ForwardDiff.gradient\ng = GT.analytical_field(sum,Ω)\nf = GT.analytical_field(x->0,Ω)\n\n#Interpolation\ninterpolation_degree = 1\nV = GT.lagrange_space(Ω,interpolation_degree)\nQ = GT.lagrange_space(Γd,interpolation_degree-1;continuous=false)\nVxQ = V × Q\n\n#Integration\nintegration_degree = 2*interpolation_degree\ndΩ = GT.measure(Ω,integration_degree)\ndΓd = GT.measure(Γd,integration_degree)\n\n#Weak form\na = ((u,p),(v,q)) -> begin\n    GT.∫(dΩ) do x\n        ∇(u,x)⋅∇(v,x)\n    end +\n    GT.∫(dΓd) do x\n        (u(x)+p(x))*(v(x)+q(x)) -\n        u(x)*v(x) -p(x)*q(x)\n    end\nend\nl = ((v,q),) -> begin\n    GT.∫(dΩ) do x\n        v(x)*f(x)\n    end +\n    GT.∫(dΓd) do x\n        g(x)*q(x)\n    end\nend\n\n#Assemble problem\n#and solve it.\np = GT.SciMLBase_LinearProblem(Float64,VxQ,a,l)\nsol = LinearSolve.solve(p)\nuh,qh = GT.solution_field(VxQ,sol)\n\n#Error check\neh = x -> uh(x) - g(x)\nel2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt\n@assert el2 < 1.0e-9\n\n#Visualization\n#of the multipliers\nfig = Makie.Figure()\nax = Makie.Axis3(fig[1,1],aspect=:data)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Γd;color=qh)\nFileIO.save(joinpath(@__DIR__,\"fig_hello_world_lm_1.png\"),Makie.current_figure()) # hide\nnothing # hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"src_md/example_linear_elasticity/#Linear-elasticity","page":"Linear elasticity","title":"Linear elasticity","text":"(Image: )","category":"section"},{"location":"src_md/example_linear_elasticity/#Problem-statement","page":"Linear elasticity","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_linear_elasticity/#Implementation","page":"Linear elasticity","title":"Implementation","text":"import FileIO # hide\nusing LinearAlgebra\nusing StaticArrays\nimport GalerkinToolkit as GT\nimport Tensors\nimport LinearSolve\nimport ForwardDiff\nimport GLMakie as Makie\n\n#Read the mesh file\nassets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"solid.msh\")\nmesh = GT.mesh_from_msh(msh_file)\n\n#Computational domains\nmaterial_1 = \"material_1\"\nmaterial_2 = \"material_2\"\nsurface_1 = \"surface_1\"\nsurface_2 = \"surface_2\"\nΩ = GT.interior(mesh;group_names=[material_1,material_2])\nΓ = GT.boundary(mesh;group_names=[surface_1,surface_2])\n\n#Vector-valued mask telling which components\n#of the solution on Γ are enforced\n#with Dirichlet conditions\npiecewise = Val(true)\nmask = GT.analytical_field(Γ;piecewise) do x,name\n    if name === surface_1\n        SVector(true,true,false)\n    elseif name === surface_2\n        SVector(true,true,true)\n    end\nend\n\n#Create interpolation space\norder = 2\ntensor_size = Val((3,))\ndirichlet_boundary = mask\nV = GT.lagrange_space(Ω,order;tensor_size,dirichlet_boundary)\n\n#Dirichlet displacements\n#NB. The third component on surface_1\n#will be ignored according to the mask above\nud = GT.analytical_field(Γ;piecewise) do x,name\n    if name === surface_1\n        δ = 0.005\n        SVector(δ,0.,0.)\n    elseif name === surface_2\n        SVector(0.,0.,0.)\n    end\nend\n\n#Interpolate Dirichlet function\nuhd = GT.interpolate_dirichlet(ud,V)\n\n#Material dependent parameters\nparams = GT.analytical_field(Ω;piecewise) do x,name\n    if name === material_1\n        E=70.0e9\n        ν=0.33\n    elseif name === material_2\n        E=200.0e9\n        ν=0.33\n    end\n    λ = (E*ν)/((1+ν)*(1-2*ν))\n    μ = E/(2*(1+ν))\n    (λ,μ)\nend\n\n#Definition of strain\nfunction ε(∇u)\n    Tensors.symmetric(Tensors.Tensor{2,3}(∇u))\nend\n\n#Definition of stress from strain\nfunction σ(ε,params)\n    λ = params[1]\n    μ = params[2]\n    λ*tr(ε)*one(ε) + 2*μ*ε\nend\n\n#von-Misses stress for visualization\nfunction σv(σ)\n    J2 = (1/2)*tr(σ⋅σ) - (1/6)*tr(σ)^2\n    sqrt(3*J2)\nend\n\n#Weak form\ndegree = 2*order\ndΩ = GT.quadrature(Ω,degree)\na = (u,v) -> begin\n    GT.∫(dΩ) do x\n        ∇_v = GT.jacobian(v,x)\n        ∇_u = GT.jacobian(u,x)\n        ε_v = GT.external(ε,∇_v)\n        ε_u = GT.external(ε,∇_u)\n        σ_u = GT.external(σ,ε_u,params(x))\n        GT.external(Tensors.dcontract,σ_u,ε_v)\n    end\nend\nl = 0\n\n#Solver phase\nproblem = GT.SciMLBase_LinearProblem(uhd,a,l)\nsolution = LinearSolve.solve(problem)\nuh = GT.solution_field(uhd,solution)\n\n#Prepare figure\nfig = Makie.Figure()\nelevation = 0.4π\nazimuth = -0.5π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\n\n#Visualze the domain warp by the displacement\n#and color by von Misses stress\nwarp_by_vector = uh\nwarp_scale = 30\ncolor = x-> begin\n    ∇_uh = GT.jacobian(uh,x)\n    ε_uh = GT.external(ε,∇_uh)\n    σ_uh = GT.external(σ,ε_uh,params(x))\n    GT.external(σv,σ_uh)\nend\ncolorrange = (0.0,5e8)\nGT.makie_surfaces!(ax,Ω;color,colorrange,warp_by_vector,warp_scale)\n\nFileIO.save(joinpath(@__DIR__,\"fig_linear_elasticity_1.png\"),Makie.current_figure()) # hide\nnothing # hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"src_md/manual_meshes/#Meshes","page":"Meshes","title":"Meshes","text":"A mesh object in GalerkinToolkit contains all geometrical information needed in a finite element (FE) computation. This includes the discretization of computational domains as well as data to impose different types of boundary conditions. It is worth noting that GalerkinToolkit is not a mesh generation library. The mesh API is designed to provide the rich geometrical information needed in FE methods, rather than mesh generation. Meshes are often generated with external tools and then transformed into GalerkinToolkit objects with helper functions such as mesh_from_gmsh.","category":"section"},{"location":"src_md/manual_meshes/#Definitions","page":"Meshes","title":"Definitions","text":"","category":"section"},{"location":"src_md/manual_meshes/#Geometry","page":"Meshes","title":"Geometry","text":"Mesh and physical faces: A mesh M in GalerkinToolkit is formally defined as set of physical faces embedded in the Euclidean space mathbbR^D, with D often being D=123.  A physical face Fin M is defined as the image phi(hat F) of a reference face hat F via a map phi mathbbR^d rightarrow mathbbR^D. The reference face hat F associated with a physical face Fin M is denoted as hat F =textttreference_face(F).\n\nNumber of dimensions, ambient dimensions and co-dimensions: The value D=textttnum_ambiend_dims(M) in the paragraph above is called the number of ambient dimensions of mesh M. We call d = textttnum_dims(F) the number of dimensions  of F. Note that the number of dimensions d and the number of ambient dimensions D might be different, namely dleq D. The number of co-dimensions is the number of ambient dimensions minus the number of dimensions. In GalerkinToolkit, a mesh might contain faces of different number of dimensions. Thus, we define the number of dimensions of a mesh as the maximum number of dimensions of their faces, textttnum_dims(M) = max_Fin M textttnum_dims(F). Note however, that the number of ambient dimensions is the same for all physical faces in a mesh.\n\nVertices, edges, surfaces, volumes, and d-faces:  We call d-face a face of d dimensions. We call vertices, edges, surfaces, and volumes to faces of 0, 1, 2, and 3 dimensions respectively.","category":"section"},{"location":"src_md/manual_meshes/#Example","page":"Meshes","title":"Example","text":"We show a mesh, where the number of ambient dimensions is 3 and the number of dimensions is 2. This mesh contains vertices, edges, and surfaces. We shrink the mesh faces for visualization purposes. Otherwise faces of hider dimensions would hide faces of lower dimensions.\n\nmodule Mesh04 # hide\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport FileIO # hide\n\ncells = (4,40)\nmesh = GT.moebius_strip(cells;width=0.6)\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nshrink = 0.8\nshading = Makie.NoShading\nGT.makie_surfaces!(mesh;shrink,shading,dim=2)\nGT.makie_edges!(mesh;shrink,dim=1)\nGT.makie_vertices!(mesh;shrink,dim=0)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_defs_1.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )\n\nChain: We call  chain to a mesh M that contains faces all of the same dimension. We denote with textttchain(Md)subset M the subset of M containing all d-faces of M.\n\nReference face: A reference d-face hat F is a d-dimensional polytope embedded in the Euclidian space mathbbR^d. In particular, hat F is a segment, polygon, and a polyhedron for d=123 respectively. For d=0, we define a reference face hat F=v as a set containing the only point  vinmathbbR^0. For d0. We define the boundary partialhat F of a reference d-face hat F as the union partialhat F = U_fin hat M_d-1 bar f, where hat M_d-1 is a set of faces of dimension (d-1) and bar f is the closure of a face fin hat M_d-1. E.g., the boundary of a square is defined as the union of four segments and the boundary of a cube is defined as the union of four squares. Assuming that partialhat F is closed, we define the reference face hat F as the open bounded subset of mathbbR^d with boundary partialhat F. We denote with textttchain(hat Fd-1) the set of faces hat M_d-1 defining the boundary of hat F. Note that our definition of mesh has a recursive structure. A physical d-face is defined with a reference d-face, whose boundary is defined with a set of physical (d-1)-faces in embedded in space mathbbR^d. Each (d-1)-face is defined with a reference (d-1)-face, whose boundary is defined with a set of physical (d-2)-faces embedded in mathbbR^d-1. The recursion continues until one reaches reference 0-faces, which are not defined by their boundary. For a reference face hat F, the number of dimensions d coincides with the number of ambient dimensions, namely d=textttnum_dims(hat F)=textttnum_ambient_dims(hat F).","category":"section"},{"location":"src_md/manual_meshes/#Example-2","page":"Meshes","title":"Example","text":"We show the 3-faces of a mesh M (top, left). We also show the reference 3-face of this mesh and the 2-faces defining its boundary (top,right). Then, we repeat this for the reference 2-face (bottom,left), and for the reference 1-face (bottom,right).\n\nmodule Meshes05 # hide\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport FileIO # hide\n\ndomain = (0,2,0,1,0,2)\ncells = (4,2,4)\nM = GT.cartesian_mesh(domain,cells)\nV3ref = first(GT.reference_spaces(M,3))\nM3ref = GT.mesh(V3ref)\nV2ref = first(GT.reference_spaces(M3ref,2))\nM2ref = GT.mesh(V2ref)\nV1ref = first(GT.reference_spaces(M2ref,1))\nM1ref = GT.mesh(V1ref)\nfig = Makie.Figure()\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nshrink = 0.8\nGT.makie_surfaces!(ax,M;dim=3,shrink)\nax = Makie.Axis3(fig[1,2];aspect)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(ax,M3ref;dim=3,shrink)\nGT.makie_surfaces!(ax,M3ref;dim=2,shrink)\naspect = Makie.DataAspect()\naxis = (;aspect)\nax, = GT.makie_surfaces(fig[1,3],M2ref;dim=2,shrink,axis)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_edges!(M2ref;dim=1,shrink)\nax = Makie.Axis(fig[1,4])\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_edges!(ax,M1ref;dim=1,shrink)\nGT.makie_vertices!(ax,M1ref;dim=0,shrink)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_defs_2.png\"),fig) # hide\nend # hide\nnothing # hide\n\n(Image: )\n\nPhysical map: The map phi that transforms a reference face hat F into a physical one F is called the physical map. It is defined by means of a scalar-valued Lagrangian interpolation space hat V defined on the reference face hat F, which we denote as hat V = textttreference_space(F). The vector of shape functions and node coordinates of space hat V are denoted as textttshape_functions(hat V) and textttnode_coordinates(hat V) respectively. The length of these vectors is textttnum_nodes(hat V). See the Interpolation section for the formal definition of the Lagrangian spaces, as well for the shape functions and node coordinates. The physical map phi for physical face F is then defined using a vector of physical node coordinates, namely textttnode_coordinates(F). These physical node coordinates are the prescribed images of the reference node coordinates in textttnode_coordinates(hat V). The physical map is defined as follows:\n\nphi(hat x) = sum_n=1^N x^F_n s^hat V_n(hat x)\n\nwith x^F_n = textttnode_coordinates(F)_n being the coordinate vector of node n in face F, s^hat V_n = textttshape_functions(hat V)_n the shape function of node n in space hat V, and N=textttnum_nodes(hat V). The notation a_i denotes the i-th element of vector a.","category":"section"},{"location":"src_md/manual_meshes/#Integer-identifiers-(ids)","page":"Meshes","title":"Integer identifiers (ids)","text":"Face ids: For a given d, let textttnum_faces(Md) be the number of faces of dimension d in a mesh M. We assign a unique integer in textttfaces(Md)=1ldotstextttnum_faces(Md) to each d-face in M. The integer textttid(F) assigned to a d-face Fin M is called the face id of F. Note that face ids are assigned per dimension (two faces of different dimension might have the same id). A face is uniquely identified by its face id textttid(F) and its dimension textttnum_dims(F). The face ids are arbitrary as long as they are consecutive integers starting by one.\n\nNode ids: The face-local id of a node in face F is defined as the position of the coordinate of this node  in the vector textttnode_coordinates(F).  That is, the node with face-local id n in face F has coordinates textttnode_coordinates(F)_n.  These coordinates are defined my means of a vector of node coordinates textttnode_coordinates(M) for the entire mesh M  and a vector of integers textttnodes(F) for face Fin M, namely  textttnode_coordinates(F)_n = textttnode_coordinates(M)_m with  m=textttnodes(F)_n.  The global id of a node in mesh M is the position of the coordinate of this node in vector textttnode_coordinates(M). The  vector textttnodes(F) contains the global ids for the nodes in this face, and is indexed by face-local node ids. This is often called  the local-to-global (index) map of face F or the connectivity of face F. We call them the global node ids (or simply the nodes) of face F  since there several types of local-to-global integer maps in GalerkinToolkit.  For a given d, we collect the node ids of all d-faces in a mesh M in a vector called textttface_nodes(Md) such that  textttface_nodes(Md)_i = textttnodes(F) for a d-face Fin M with i=textttid(F).  In addition, we define the global node ids of mesh M as  textttnodes(M)=1ldotstextttnum_nodes(M) with textttnum_nodes(M) being the number of nodes in mesh M. i.e., the length  of the vector textttnode_coordinates(M).\n\nReference ids:  For a given d, let us consider a vector (or a tuple) textttreference_spaces(Md)  containing all the unique reference space for the d-faces of a mesh M. The reference id   of a d-face Fin M, namely textttreference_id(F), is defined as the integer r such that  textttreference_space(F) = textttreference_spaces(Md)_r. That is,  r is the position of the reference space of face F in textttreference_spaces(Md).  The reference ids of all d-faces are collected in vector textttface_reference_id(Md),  such that textttface_reference_id(Md)_i = textttreference_id(F) for a d-face  Fin M  with i=textttid(F).  The notion of reference id is introduced since different face  typologies such as simplixes and hyper-cubes might be contained in the same mesh object.  Note also that often all d-faces are topologically equivalent. In this case, there is only one reference  space for all d-faces and their reference id is one.","category":"section"},{"location":"src_md/manual_meshes/#Mesh-meta-data","page":"Meshes","title":"Mesh meta-data","text":"Face groups: For a given d, we call a face group to a subset Gsubset textttfaces(Md) of the face ids of dimension d. A mesh is typically endowed with several of these groups to identify particular faces of the mesh for modeling purposes, e.g., to impose boundary conditions, or define position-dependent material properties. Each group is given a group name, which identifies the group. We call textttgroup_names(Md) the set of group names available in mesh M for faces of dimension d. We call textttgroup_faces(Md) to an associative collection (a Julia Dict in practice), that maps group names to the corresponding subset of face ids Gsubset textttfaces(Md). That is textttgroup_faces(Md)_n is the set of face ids in the group with name nintextttgroup_names(Md). Here, a_n denotes the value of the associative collection a at key n. Face groups are defined per dimension and it is accepted to have the same group name in two or more dimensions. That is, textttgroup_names(Md_1)captextttgroup_names(Md_2) might be non-empty for two dimensions d_1neq d_2. It is also possible to add new groups to the collection, textttgroup_faces(Md)_n = G, as long as the group name n is not already an existing key.","category":"section"},{"location":"src_md/manual_meshes/#The-AbstractMesh-interface","page":"Meshes","title":"The AbstractMesh interface","text":"A mesh M as defined above is represented in GalerkinToolkit with a mesh object M, whose type is a subtype of AbstractMesh.","category":"section"},{"location":"src_md/manual_meshes/#Core-API","page":"Meshes","title":"Core API","text":"The core API for mesh objects M::AbstractMesh is given below. The definition of these functions is analogous as the definition of the mathematical functions above.\n\nnum_dims(M)\nnum_ambient_dims(M)\nnum_codims(M)\nnum_nodes(M)\nnodes(M)\nnode_coordinates(M)\nfaces(M,d)\nnum_faces(M,d)\nface_nodes(M,d)\nface_reference_id(M,d)\nreference_spaces(M,d)\ngroup_faces(M,d)\ngroup_names(M,d)\nnormals(M)","category":"section"},{"location":"src_md/manual_meshes/#Face-iteration","page":"Meshes","title":"Face iteration","text":"Given M::AbstractMesh, function GT.each_face(M,d) creates an iterator object used to traverse all d-faces in mesh M. Using this iterator, face objects can be accessed with the Julia loop syntax.\n\nfor F in GT.each_face(M,d)\n   # Use F\nend\n\nVariable F represents a d-face in mesh M. One case use the following API on the F object. Most these functions coincide with the mathematical functions presented above. Otherwise, their definition can be found in the corresponding doc-strings.\n\nnum_dims(F)\nnum_ambient_dims(F)\nnum_codims(F)\nnodes(F)\nnum_nodes(F)\nnode_coordinates(F)\ndiameter(F)\nid(F)\nreference_id(F)\nreference_face(F)\nreference_space(F)","category":"section"},{"location":"src_md/manual_meshes/#Specializing-AbstractMesh","page":"Meshes","title":"Specializing AbstractMesh","text":"A type that specializes AbstractMesh needs to implement the following methods for an instance M of the new type. The entire AbstractMesh API can be then used in instances of these types.\n\nnode_coordinates(M)\nface_nodes(M)\nface_reference_id(M)\nreference_spaces(M)\ngroup_faces(M)\nnormals(M)","category":"section"},{"location":"src_md/manual_meshes/#The-Mesh-type","page":"Meshes","title":"The Mesh type","text":"The default specialization of AbstractMesh is the type Mesh. It is a data structure able to hold general unstructured meshes.","category":"section"},{"location":"src_md/manual_meshes/#Creating-a-general-mesh","page":"Meshes","title":"Creating a general mesh","text":"The general way of creating an instance of the type Mesh is with function create_mesh. This is the lowest-level way of creating a mesh. Other more user-friendly ways of building a mesh are discussed in the Mesh generation section.","category":"section"},{"location":"src_md/manual_meshes/#Example-3","page":"Meshes","title":"Example","text":"In the following example, we generate and visualize a mesh of three first order triangles. Only faces of dimension 2 are present in this example. The arrays for vertices and edges are empty.\n\nmodule Meshes01 # hide\n#Import dependencies\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport StaticArrays\nimport FileIO # hide\n\n#Node coordinates\nT = StaticArrays.SVector{2,Float64}\nnode_coordinates = T[(0,0),(1,0),(0,1),(1,1),(2,0)]\n\n#Face nodes\nface_nodes_0 = Vector{Int}[]\nface_nodes_1 = Vector{Int}[]\nface_nodes_2 = [[1,2,3],[2,3,4],[2,4,5]]\nface_nodes = [\n    face_nodes_0,\n    face_nodes_1,\n    face_nodes_2]\n\n#Reference spaces\nreference_spaces_0 = ()\nreference_spaces_1 = ()\norder = 1\ntriangle = GT.unit_simplex(Val(2))\ntriangle3 = GT.lagrange_space(triangle,order)\nreference_spaces_2 = (triangle3,)\nreference_spaces = (\n    reference_spaces_0,\n    reference_spaces_1,\n    reference_spaces_2)\n\n#Create mesh\nmesh = GT.create_mesh(;\n    node_coordinates,\n    face_nodes,\n    reference_spaces)\n\n#Visualize\naxis = (;aspect=Makie.DataAspect())\nshading = Makie.NoShading\nGT.makie_surfaces(mesh;axis,shading)\nGT.makie_edges!(mesh;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_1.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"src_md/manual_meshes/#Example-4","page":"Meshes","title":"Example","text":"In this other slightly more complex example, we define a mesh including faces of different dimensions: surfaces, edges and vertices. To be able to see all faces in the visualization, we need to \"shrink\" them. Otherwise, the surfaces would hide the edges and vertices.\n\nmodule Meshes02 # hide\n#Import dependencies\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport StaticArrays\nimport FileIO # hide\n\n#Node coordinates\nT = StaticArrays.SVector{2,Float64}\nnode_coordinates = T[(0,0),(1,0),(0,1),(1,1),(2,0)]\n\n#Face nodes\nface_nodes_0 = [[1],[3]]\nface_nodes_1 = [[1,2],[2,5],[5,4]]\nface_nodes_2 = [[1,2,3],[2,3,4],[2,4,5]]\nface_nodes = [\n    face_nodes_0,\n    face_nodes_1,\n    face_nodes_2]\n\n#Reference spaces\norder = 1\nvertex = GT.unit_simplex(Val(0))\nvertex1 = GT.lagrange_space(vertex,order)\nsegment = GT.unit_simplex(Val(1))\nsegment2 = GT.lagrange_space(segment,order)\ntriangle = GT.unit_simplex(Val(2))\ntriangle3 = GT.lagrange_space(triangle,order)\nreference_spaces_0 = (vertex1,)\nreference_spaces_1 = (segment2,)\nreference_spaces_2 = (triangle3,)\nreference_spaces = (\n    reference_spaces_0,\n    reference_spaces_1,\n    reference_spaces_2)\n\n#Create mesh\nmesh = GT.create_mesh(;\n    node_coordinates,\n    face_nodes,\n    reference_spaces)\n\n#Visualize\naxis = (;aspect=Makie.DataAspect())\nshrink = 0.8\nshading = Makie.NoShading\nGT.makie_surfaces(mesh;axis,shading,shrink)\nGT.makie_edges!(mesh;dim=1,shrink)\nGT.makie_vertices!(mesh;dim=0)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_2.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"src_md/manual_meshes/#Creating-a-general-chain","page":"Meshes","title":"Creating a general chain","text":"Using function create_mesh might be tedious if all faces are of the same dimension. In this case, we can use the slightly simpler constructor create_chain. It works like create_mesh, but we pass data only for one face dimension.","category":"section"},{"location":"src_md/manual_meshes/#Example-5","page":"Meshes","title":"Example","text":"We create the mesh of the first example, but using create_chain.\n\nmodule Meshes03 # hide\n#Import dependencies\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport StaticArrays\nimport FileIO # hide\n\n#Node coordinates\nT = StaticArrays.SVector{2,Float64}\nnode_coordinates = T[(0,0),(1,0),(0,1),(1,1),(2,0)]\n\n#Face nodes\nface_nodes = [[1,2,3],[2,3,4],[2,4,5]]\n\n#Reference spaces\norder = 1\ntriangle = GT.unit_simplex(Val(2))\ntriangle3 = GT.lagrange_space(triangle,order)\nreference_spaces = (triangle3,)\n\n#Create mesh\nchain = GT.create_chain(;\n    node_coordinates,\n    face_nodes,\n    reference_spaces)\n\n#Visualize\naxis = (;aspect=Makie.DataAspect())\nshading = Makie.NoShading\nGT.makie_surfaces(chain;axis,shading)\nGT.makie_edges!(chain;color=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_1a.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"src_md/example_laplace_beltrami/#Laplace-Beltrami","page":"Laplace-Beltrami","title":"Laplace-Beltrami","text":"(Image: )","category":"section"},{"location":"src_md/example_laplace_beltrami/#Problem-statement","page":"Laplace-Beltrami","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_laplace_beltrami/#Implementation","page":"Laplace-Beltrami","title":"Implementation","text":"import FileIO # hide\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport ForwardDiff\nusing LinearAlgebra\nimport LinearSolve\n\n\ncells = (4,40)\nmesh = GT.moebius_strip(cells;width=0.6)\nΩ = GT.interior(mesh)\nΓ = GT.boundary(mesh)\nV = GT.lagrange_space(Ω,2;dirichlet_boundary=Γ)\n∇ = ForwardDiff.gradient\nf = GT.analytical_field(x->1,Ω)\ndΩ = GT.measure(Ω,4)\n\na = (u,v) -> begin\n    GT.∫(dΩ) do x\n        ∇(u,x)⋅∇(v,x)\n    end\nend\nl = (v) -> begin\n    GT.∫(dΩ) do x\n        v(x)*f(x)\n    end\nend\n\nuhd = GT.zero_field(Float64,V)\np = GT.SciMLBase_LinearProblem(uhd,a,l)\nsol = LinearSolve.solve(p)\nuh = GT.solution_field(uhd,sol)\n\n\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nshading=Makie.NoShading\nGT.makie_surfaces!(Ω;color=uh,shading,refinement=2)\nFileIO.save(joinpath(@__DIR__,\"fig_laplace_beltrami_1.png\"),Makie.current_figure()) # hide\nnothing # hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"reference/#API","page":"API","title":"API","text":"","category":"section"},{"location":"reference/#GalerkinToolkit.AbstractDomain","page":"API","title":"GalerkinToolkit.AbstractDomain","text":"abstract type AbstractDomain <: AbstractType end\n\nAbstract type representing a subset of mathbbR^d, typically din0123. Domains are defined using an underlying computational mesh. See also AbstractMesh.\n\nLevel\n\nBeginner\n\nBasic constructors\n\nunit_simplex\nunit_n_cube\ndomain\ninterior\nboundary\nskeleton\n\nBasic queries\n\nnum_dims\nnum_ambient_dims\nnum_codims\nis_axis_aligned\nis_simplex\nis_n_cube\nis_unit_n_cube\nis_unit_simplex\nis_unitary\nbounding_box\nvertex_permutations\nmesh\nfaces\ninverse_faces\noptions\nis_boundary\nface_around\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceDomain","page":"API","title":"GalerkinToolkit.AbstractFaceDomain","text":"abstract type AbstractFaceDomain <: AbstractDomain end\n\nA domain defined on a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\nBasic constructors\n\nunit_simplex\nunit_n_cube\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceSpace","page":"API","title":"GalerkinToolkit.AbstractFaceSpace","text":"abstract type AbstractFaceSpace <: AbstractSpace end\n\nLike AbstractSpace, but for a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceTopology","page":"API","title":"GalerkinToolkit.AbstractFaceTopology","text":"abstract type AbstractFaceTopology <: AbstractTopology end\n\nLike AbstractTopology, but for a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractMesh","page":"API","title":"GalerkinToolkit.AbstractMesh","text":"abstract type AbstractMesh <: AbstractType end\n\nAbstract type representing a computational mesh.\n\nLevel\n\nBeginner\n\nConstructors\n\ncreate_mesh\nmesh_from_msh\nmesh_from_gmsh\ncartesian_mesh\nmoebius_strip\ncomplexify\nsimplexify\n\nIteration\n\neach_face\n\nData retrival\n\nnum_dims\nnum_ambient_dims\nnum_codims\nnum_faces\nnum_nodes\nnode_coordinates\nface_nodes\nface_reference_id\nreference_spaces\ngroup_faces\ngroup_names\nis_face_complex\nnormals\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractMeshDomain","page":"API","title":"GalerkinToolkit.AbstractMeshDomain","text":"abstract type AbstractMeshDomain <: AbstractDomain end\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractQuadrature","page":"API","title":"GalerkinToolkit.AbstractQuadrature","text":"abstract type AbstractQuadrature\n\nBasic queries\n\ndomain\ncoordinates\nweights\nnum_points\nface_reference_id\nreference_quadratures\n\nBasic constructors\n\nquadrature\nduffy_quadrature\ntensor_product_quadrature\nnode_quadrature\n\nSupertype hierarchy\n\nAbstractQuadrature <: GT.AbstractType\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractSpace","page":"API","title":"GalerkinToolkit.AbstractSpace","text":"abstract type AbstractSpace <: AbstractType end\n\nAbstract type representing a finite element space.\n\nLevel\n\nBasic\n\nBasic constructors\n\nlagrange_space raviart_thomas_space\n\nBasic queries\n\ndomain\nnum_dofs\nface_dofs\nface_nodes\nface_reference_id\nreference_spaces\ngeometry_own_dofs\ngeometry_own_dofs_permutations\n\nAdditional queries\n\nFor spaces, used as reference spaces in AbstractMesh specializations.\n\nnum_nodes\ninterior_nodes\ninterior_nodes_permutations\ngeometry_interior_nodes\ngeometry_interior_nodes_permutations\ngeometry_nodes\ngeometry_nodes_permutations\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractTopology","page":"API","title":"GalerkinToolkit.AbstractTopology","text":"abstract type AbstractTopology\n\nAbstract type representing the incidence relations in a face complex.\n\nLevel\n\nIntermediate\n\nConstructors\n\ntopology\n\nQueries\n\nface_incidence\nface_reference_id\nface_permutation_ids\nreference_topologies\nvertex_permutations\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractType","page":"API","title":"GalerkinToolkit.AbstractType","text":"abstract type AbstractType end\n\nParent of all types defined in GalerkinToolkit.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.Mesh","page":"API","title":"GalerkinToolkit.Mesh","text":"\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.Options","page":"API","title":"GalerkinToolkit.Options","text":"struct Options{...} <: AbstractType\n\nType of the objects returned by function options. All properties and type parameters are private.\n\nBasic queries\n\nreference_int_type\nint_type\nglobal_int_type\nreal_type\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.UnitNCube","page":"API","title":"GalerkinToolkit.UnitNCube","text":"struct UnitNCube{...} <: AbstractFaceDomain\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.UnitSimplex","page":"API","title":"GalerkinToolkit.UnitSimplex","text":"struct UnitSimplex{...} <: AbstractFaceDomain\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.ast_hoist!-Tuple{Any}","page":"API","title":"GalerkinToolkit.ast_hoist!","text":"ast_hoist!(ast)\n\nHoist loop invariant definitions in ast. The new AST is overwritten in ast.\n\nHypotheses:\n\nThe root of the AST is a code block.\nThe code block contains only for-loops, function calls, array indexing, definitions, and increments. No while loops, if statements, lambdas, etc.\nFunctions that appear in a rhs of a definition are pure functions.\nRHSs contain a function call at most.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.ast_lhs_indices-Tuple{Any}","page":"API","title":"GalerkinToolkit.ast_lhs_indices","text":"ast_lhs_indices(ast)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.boundary","page":"API","title":"GalerkinToolkit.boundary","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.bounding_box","page":"API","title":"GalerkinToolkit.bounding_box","text":"p0,p1 = bounding_box(x)\n\nReturn a tuple of two vectors, where the vectors p0 and p1 define the span of the bounding box of x.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.cartesian_mesh-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.cartesian_mesh","text":"cartesian_mesh(domain,cells_per_dir)\n\nCreate a multi-dimensional Cartesian mesh. The dimension of the mesh is defined by the length of cells_per_dir. The number of cells in direction i is given by cells_per_dir[i]. The extends of the Cartesian mesh are given in domain. The range in direction i covered by the mesh is given by domain[2*i-1,2*i].\n\nKeyword arguments\n\nboundary=true [optional]: Include faces on the boundary and generate face groups identifying which faces are  on which face of  bounding box of the mesh. The groups are named $d-face-$i for the face i of dimension d of the bounding box.\ncomplexify=true [optional]: Generate all low dimensional faces so that the mesh is  a face complex.\nsimplexify=false [optional]: Generate a mesh of simplex faces instead of hyper-cubes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.complexify","page":"API","title":"GalerkinToolkit.complexify","text":"complexify(x)\n\nConvert x into a mesh representing a face complex.\n\nSee also is_face_complex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.coordinates","page":"API","title":"GalerkinToolkit.coordinates","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.create_chain-Tuple{}","page":"API","title":"GalerkinToolkit.create_chain","text":"create_chain(;kwargs...)\n\nBuild an arbitrary mesh object, containing all faces of the same dimension. This function is similar to create_mesh but it only receives face arrays of one dimension.\n\nSee also create_mesh.\n\nLevel\n\nIntermediate\n\nKeyword arguments\n\nnode_coordinates: Like for create_mesh.\nface_nodes: A nested vector containing the node ids for each face in the mesh. node_coordinates[n] with n=face_nodes[i][k] is the global node coordinate vector for local node number k in face i. \nreference_spaces: A tuple containing the reference spaces for faces. reference_spaces[i] is the reference space number i.\nface_reference_id [optional]: A vector containing which reference space is assigned to each face. reference_sapces[r] with r=face_reference_id[i] is the reference space associated with face number i. By default, all faces are assigned to the first reference space in its dimension.\ngroup_faces [optional]: A Dictionary containing labeled groups of faces. group_faces[group_name] is a vector of integers containing the ids  of the faces in the group named group_name. These groups might overlap. By default, no faces groups are created.\nnormals=nothing [optinal]: Like for create_mesh.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.create_mesh","page":"API","title":"GalerkinToolkit.create_mesh","text":"create_mesh(;kwargs...)\n\nBuild an arbitrary mesh object.\n\nSee also cartesian_mesh, mesh_from_msh, and mesh_from_gmsh.\n\nLevel\n\nIntermediate\n\nKeyword arguments\n\nnode_coordinates: The vector containing the coordinates of all mesh nodes. node_coordinates[i] is the coordinate vector for global node number i.\nface_nodes: A highly-nested vector containing the node ids for each face in the mesh. node_coordinates[n] with n=face_nodes[d+1][i][k] is the global node coordinate vector for local node number k in face i of dimension d. The object face_nodes[d+1] is a long vector of small vectors of integers. It is often represented using a JaggedArray object that uses continuous linear memory for performance.\nreference_spaces: A nested tuple containing the reference spaces for faces. reference_spaces[d+1][i] is the reference space number i in dimension d. Reference interpolation spaces are defined with functions like lagrange_space.\nface_reference_id [optional]: A nested vector containing which reference space is assigned to each face. reference_sapces[d+1][r] with r=face_reference_id[d+1][i] is the reference space associated with face number i of dimension d. By default, all faces are assigned to the first reference space in its dimension.\ngroup_faces [optional]: A vector of dictionaries containing labeled groups of faces. group_faces[d+1][group_name] is a vector of integers containing the ids  of the faces of dimension d in the group named group_name. These groups might overlap. By default, no faces groups are created.\nis_face_complex=Val(false) [optional]: Val(true) if the input data represents a face complex, Val(false) otherwise.\nnormals=nothing [optinal]: Vector containing the normal vectors for the faces of maximum dimension of the mesh. This is relevant for meshes of dimension d embedded in d+1 dimensions as there is no way to tell which should be the orientation of the normals from the other quantities in the mesh.  normals[f] gives the normal vector of face number f of dimension d=length(face_nodes)-1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.diameter-Tuple{GalerkinToolkit.MeshFace}","page":"API","title":"GalerkinToolkit.diameter","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.domain","page":"API","title":"GalerkinToolkit.domain","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.domain-Tuple{GalerkinToolkit.AbstractMesh, Any}","page":"API","title":"GalerkinToolkit.domain","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.duffy_quadrature-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.duffy_quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.each_face","page":"API","title":"GalerkinToolkit.each_face","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_around","page":"API","title":"GalerkinToolkit.face_around","text":"face_around(x)\n\nReturn an integer that allows to break ties when faces in x need to point to faces around of one dimension higher. Return nothing if x does not break such ties.\n\nNote: This function will eventually return a vector of integers.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_dofs","page":"API","title":"GalerkinToolkit.face_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_incidence","page":"API","title":"GalerkinToolkit.face_incidence","text":"face_incidence(x,d)\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_nodes","page":"API","title":"GalerkinToolkit.face_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_permutation_ids","page":"API","title":"GalerkinToolkit.face_permutation_ids","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_reference_id","page":"API","title":"GalerkinToolkit.face_reference_id","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.faces","page":"API","title":"GalerkinToolkit.faces","text":"faces(x)\n\nReturn the subset of face ids in mesh(x) of dimension num_dims(x) defining the domain x. This is effectively the map from domain face id to mesh face id.\n\nSee also inverse_faces.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometries","page":"API","title":"GalerkinToolkit.geometries","text":"geometries(x,d)\ngeometries(x,Val(d))\n\nReturn a vector of domains representing the geometrical entities of x of dimension d. The returned domains and x are defined on the same mesh. That is, faces(geometries(x,1)[2]) are the face ids in mesh(x) representing the second edge of x.\n\nNotation\n\ngeometries(x,Val(0)) are referred to as the vertices of x. geometries(x,Val(1)) are referred to as the edges of x. geometries(x,Val(d)) are referred to as the d-faces of x.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_interior_nodes","page":"API","title":"GalerkinToolkit.geometry_interior_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_interior_nodes_permutations","page":"API","title":"GalerkinToolkit.geometry_interior_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_nodes","page":"API","title":"GalerkinToolkit.geometry_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_nodes_permutations","page":"API","title":"GalerkinToolkit.geometry_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_own_dofs","page":"API","title":"GalerkinToolkit.geometry_own_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_own_dofs_permutations","page":"API","title":"GalerkinToolkit.geometry_own_dofs_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.global_int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.global_int_type","text":"global_int_type(options::Options)\n\nReturn the type of the integers used to enumerate global quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.group_boundary_faces!","page":"API","title":"GalerkinToolkit.group_boundary_faces!","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.group_faces","page":"API","title":"GalerkinToolkit.group_faces","text":"group_faces(mesh)\ngroup_faces(mesh,d)\n\nReturn the dictionary containing the faces in each group in dimension d. If d is omitted, it returns the dictionaries for all dimensions in a vector. I.e., calling group_faces(mesh,d) is equivalent to group_faces(mesh)[d+1].\n\nThe faces of dimension d in group group are group_faces(mesh,d)[group_name], where group_name is a string with the group name. One can create new groups by adding new keys to these dictionaries as long as the key is not already present. Calling group_faces(mesh,d)[new_group_name] = faces_in_newgroup will add a new group to dimension d with name equal to the string new_group_name with faces in vector faces_in_newgroup.\n\nSee also group_names.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.group_faces_in_dim!","page":"API","title":"GalerkinToolkit.group_faces_in_dim!","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.group_interior_faces!","page":"API","title":"GalerkinToolkit.group_interior_faces!","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.group_names","page":"API","title":"GalerkinToolkit.group_names","text":"group_names(mesh)\ngroup_names(mesh,d)\n\nReturn the names of the groups in dimension d. Calling group_names(mesh,d) is equivalent to group_names(mesh)[d+1].\n\nSee also group_faces.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.int_type","text":"int_type(options::Options)\n\nReturn the default integer type used in the computation except for reference and global quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.interior","page":"API","title":"GalerkinToolkit.interior","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.interior_node_permutations-Tuple{GalerkinToolkit.LagrangeFaceSpace}","page":"API","title":"GalerkinToolkit.interior_node_permutations","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.interior_nodes","page":"API","title":"GalerkinToolkit.interior_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.interior_nodes_permutations","page":"API","title":"GalerkinToolkit.interior_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.inverse_faces","page":"API","title":"GalerkinToolkit.inverse_faces","text":"inverse_faces(x)\n\nReturn the inverse integer mas of faces(x). This is effectively the map from mesh face id to domain face id. Mesh faces not present in the domain, receive an invalid index id.\n\nSee also faces.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_axis_aligned","page":"API","title":"GalerkinToolkit.is_axis_aligned","text":"is_axis_aligned(x)\n\nTrue if x is a unit simplex or a unit cube.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_boundary","page":"API","title":"GalerkinToolkit.is_boundary","text":"is_boundary(x)\n\nTrue if x represent an (internal) boundary. Faces in an internal boundary \"point\" to only of the two faces around of a dimension higher.\n\nSee also face_around.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_face_complex","page":"API","title":"GalerkinToolkit.is_face_complex","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_n_cube","page":"API","title":"GalerkinToolkit.is_n_cube","text":"is_n_cube(x)\n\nTrue if x is a n-cube (hypercube).\n\nSee also is_simplex, is_unit_simplex, is_unit_n_cube.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_simplex","page":"API","title":"GalerkinToolkit.is_simplex","text":"is_simplex(x)\n\nTrue if x is a simplex.\n\nSee also is_n_cube, is_unit_simplex, is_unit_n_cube.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unit_n_cube","page":"API","title":"GalerkinToolkit.is_unit_n_cube","text":"is_unit_n_cube(x)\n\nTrue if x is a unit n-cube.\n\nSee also is_n_cube, is_unit_simplex, is_simplex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unit_simplex","page":"API","title":"GalerkinToolkit.is_unit_simplex","text":"is_unit_simplex(x)\n\nTrue if x is a unit simplex.\n\nSee also is_n_cube, is_unit_n_cube, is_simplex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unitary","page":"API","title":"GalerkinToolkit.is_unitary","text":"is_unitary(x)\n\nTrue bounding_box(x) coincides with a unit n-cube.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.lagrange_space","page":"API","title":"GalerkinToolkit.lagrange_space","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.mesh-Tuple{GalerkinToolkit.Chain}","page":"API","title":"GalerkinToolkit.mesh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_gmsh-Tuple{Module}","page":"API","title":"GalerkinToolkit.mesh_from_gmsh","text":"mesh_from_gmsh(gmsh::Module;complexify=true)\n\nCreate a mesh objects from the current state of the gmsh module. If complexify==true, the mesh will be completed with all low dimensional faces into a face complex.\n\nSee also mesh_from_msh and with_gmsh.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_msh-Tuple{Any}","page":"API","title":"GalerkinToolkit.mesh_from_msh","text":"mesh_from_msh(msh_file;kwargs...)\n\nCreate a mesh object from a .msh file found in path msh_file.\n\nSee also mesh_from_gmsh and with_gmsh.\n\nKeyword arguments\n\ncomplexify=true [optional]: If complexify==true, the mesh will be completed with all low dimensional faces into a face complex.\nrenumber=true [optional]: If renumber==true, then gmsh.model.mesh.renumberNodes() and gmsh.model.mesh.renumberElements() will be called.\nAny other keyword argument will be passed to function with_gmsh.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_space","page":"API","title":"GalerkinToolkit.mesh_from_space","text":"mesh_from_space(space)\n\nReturn the mesh induced by space. For instance, a (high order) Lagrange space can be interpreted as a mesh using this function.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.moebius_strip-Tuple{Any}","page":"API","title":"GalerkinToolkit.moebius_strip","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.node_coordinates","page":"API","title":"GalerkinToolkit.node_coordinates","text":"node_coordinates(x)\n\nReturn the vector of node coordinates associated with `x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.node_permutations-Tuple{GalerkinToolkit.LagrangeFaceSpace}","page":"API","title":"GalerkinToolkit.node_permutations","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.node_quadrature","page":"API","title":"GalerkinToolkit.node_quadrature","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.nodes","page":"API","title":"GalerkinToolkit.nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.normals","page":"API","title":"GalerkinToolkit.normals","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_ambient_dims","page":"API","title":"GalerkinToolkit.num_ambient_dims","text":"num_ambient_dims(x)\n\nReturn the ambient dimension where object x lives.\n\nSee also num_codims, num_dims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_codims","page":"API","title":"GalerkinToolkit.num_codims","text":"num_codims(x)\n\nReturn num_ambient_dims(x)-num_dims(x).\n\nSee also num_ambient_dims, num_dims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_dims","page":"API","title":"GalerkinToolkit.num_dims","text":"num_dims(x)\n\nReturn the parametric dimension of x.\n\nSee also num_ambient_dims, num_codims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_dofs","page":"API","title":"GalerkinToolkit.num_dofs","text":"num_dofs(x)\n\nReturn the number of degrees of freedom of x.\n\nSee also num_nodes.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_faces","page":"API","title":"GalerkinToolkit.num_faces","text":"num_faces(x)\nnum_faces(x,d)\n\nReturn the number of faces  of dimension d in mesh(x). If d is omitted, return a vector with the number of faces in each dimension, starting from dimension 0 up to num_dims(x).\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_nodes","page":"API","title":"GalerkinToolkit.num_nodes","text":"num_nodes(x)\n\nReturn the number of nodes of x.\n\nSee also num_dofs.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_points","page":"API","title":"GalerkinToolkit.num_points","text":"num_points(x)\n\nReturn the number of integration points in x.\n\nSee also num_nodes.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.options-Tuple{}","page":"API","title":"GalerkinToolkit.options","text":"options(;kwargs...) -> Options\n\nCreate an object representing the default options for the current simulation. This object can be used as an optional argument in several object constructors in GalerkinToolkit, such as the mesh constructors cartesian_mesh and mesh_from_msh. In this case, the computations using the generated mesh, will use the given options by default.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.periodic_nodes","page":"API","title":"GalerkinToolkit.periodic_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.push","page":"API","title":"GalerkinToolkit.push","text":"push(a,ai)\n\nLike push!, but creates a new object to store the result.  This function is used to push to immutable collections such as tuples.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.quadrature-Tuple{GalerkinToolkit.AbstractFaceDomain, Any}","page":"API","title":"GalerkinToolkit.quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.raviart_thomas_space","page":"API","title":"GalerkinToolkit.raviart_thomas_space","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.real_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.real_type","text":"real_type(options::Options)\n\nReturn the default real type used in the computation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.reference_int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.reference_int_type","text":"reference_int_type(options::Options)\n\nReturn the type of the integers used to enumerate reference quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.reference_quadratures","page":"API","title":"GalerkinToolkit.reference_quadratures","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_spaces","page":"API","title":"GalerkinToolkit.reference_spaces","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_topologies","page":"API","title":"GalerkinToolkit.reference_topologies","text":"reference_topologies(topo)\nreference_topologies(topo,d)\nreference_topologies(topo,Val(d))\n\nReturn the list (a vector or a tuple) of reference topologies in topo of dimension d. If the second argument is omitted, then the function returns a collection such that reference_topologies(topo)[d+1] is equivalent to reference_topologies(topo,Val(d)).\n\nThe face reference topology of face f of dimension d, is accessed as reference_topologies(topo,d)[r] with r=face_reference_id(topo,d)[f].\n\nSee also face_reference_id.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.shape_functions-Tuple{GalerkinToolkit.AbstractSpace}","page":"API","title":"GalerkinToolkit.shape_functions","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.simplexify","page":"API","title":"GalerkinToolkit.simplexify","text":"simplexify(x)\n\nConvert x into a mesh made of simplex cells.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.skeleton","page":"API","title":"GalerkinToolkit.skeleton","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.tabulator-Tuple{GalerkinToolkit.AbstractSpace}","page":"API","title":"GalerkinToolkit.tabulator","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.tensor_product_quadrature-Tuple{GalerkinToolkit.AbstractFaceDomain, Any}","page":"API","title":"GalerkinToolkit.tensor_product_quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.topology-Tuple{GalerkinToolkit.AbstractMesh}","page":"API","title":"GalerkinToolkit.topology","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.unit_n_cube-Tuple{Any}","page":"API","title":"GalerkinToolkit.unit_n_cube","text":"unit_n_cube(d)\nunit_n_cube(Val(d))\n\nReturn an object representing a unit d-cube.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.unit_simplex-Tuple{Any}","page":"API","title":"GalerkinToolkit.unit_simplex","text":"unit_simplex(d)\nunit_simplex(Val(d))\n\nReturn an object representing a unit simplex of dimension d.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.val_parameter-Tuple{Any}","page":"API","title":"GalerkinToolkit.val_parameter","text":"val_parameter(a)\n\nFor a::Val{A} it returns A. Otherwise, it returns a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.vertex_permutations","page":"API","title":"GalerkinToolkit.vertex_permutations","text":"vertex_permutations(x)\n\nReturn a list of permutations representing the admissible re-labelings of the vertices of x.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.weights","page":"API","title":"GalerkinToolkit.weights","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.with_gmsh-Tuple{Any}","page":"API","title":"GalerkinToolkit.with_gmsh","text":"with_gmsh(f[;options])\n\nA safe way of initialize and finalize the gmsh module. The given function is called f(gmsh) on the gmsh module after is has been initialized. The module is finalized automatically when the function returns.\n\nThe optional keyword argument options is a vector for pairs k=>v containing gmesh options. Each of these options are set with gmsh.option.setNumber(k,v) just after gmsh has been initialized.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.with_mesh_partitioner","page":"API","title":"GalerkinToolkit.with_mesh_partitioner","text":"with_mesh_partitioner(mesher[,partitioner];[parts])\n\nGenerate a mesh calling mesher() partition it, and distribute it over the part ids in parts.\n\nArguments\n\nFunction mesher() should have no arguments and returns a sequential mesh object. This function is called only on one process.\npartitioner [optional]: A function that takes a graph encoded as a sparse matrix, and returns a vector containing the part id of each node in the graph. Defaults to Metis.partition.\n\nKeyword arguments\n\nparts [optional]: A vector containing the part indices 1:P where P is the number of parts in the data distribution. By default, P is the number of MPI ranks and 1:P is distributed one item per rank.\n\n\n\n\n\n","category":"function"},{"location":"src_md/manual_mesh_geometry/#Mesh-geometry","page":"Mesh geometry","title":"Mesh geometry","text":"A mesh object in GalerkinToolkit contains all geometrical information needed in a finite element (FE) computation. This includes the discretization of computational domains as well as data to impose different types of boundary conditions. Meshes are often generated with external tools and then transformed into GalerkinToolkit objects with helper functions such as mesh_from_gmsh, see the Page about Mesh generation for more details. In this page, we assume that we have already created a mesh object and will discuss its geometrical representation and in particular:\n\nour math definition of a mesh,\nreference domains and spaces,\nphysical faces and coordinate maps,\nface, node, and reference ids, and\nface groups.","category":"section"},{"location":"src_md/manual_mesh_geometry/#Definition","page":"Mesh geometry","title":"Definition","text":"A mesh M in GalerkinToolkit is defined as set of physical faces embedded in the Euclidean space mathbbR^D, with D often being D=123. A physical face is defined in terms of a reference domain and a reference space as detailed later below. In the API, a mesh M is represented with a mesh object M, whose type is a subtype of AbstractMesh. Even though our math notation defines a mesh M as a set, a mesh object M::AbstractMesh has not the API of a set, but an API providing the information encoding the set of faces M. There is a one-to-one relation between the mathematical mesh M and the API mesh M and we often refer to them simply as \"a mesh\". The same is true for other math definitions and their corresponding API.\n\nA face Fin M in a mesh is represented in the code with an object F::AbstractMeshFace. Given M::AbstractMesh, function GT.each_face(M,d) creates an iterator used to traverse all faces of dimensions d in mesh M. Using this iterator, faces can be accessed with the Julia loop syntax.\n\nfor F in GT.each_face(M,d)\n    # F isa AbstractMeshFace\nend","category":"section"},{"location":"src_md/manual_mesh_geometry/#Dimensions","page":"Mesh geometry","title":"Dimensions","text":"A face Fin M in a mesh is an open d-dimensional manifold embedded in the Euclidean space mathbbR^D. We call D the number of ambient dimensions of the mesh M  and of faces Fin M, and d is the number of dimensions of face F, which might be d=0ldotsD. We use d(X) and D(X) to denote the number of dimensions and ambient dimensions of an object X and define the number of co-dimensions of X as D(X)-d(X). Since a mesh might contain faces of different dimensions, we define the number of dimensions of a mesh M as the maximum number of dimensions of their faces, d(M)=max_Fin M d(F). In the API, the number of dimensions, ambient dimensions, and co-dimensions are obtained with num_dims(X), num_ambient_dims(X), and num_codims(X) respectively for an instance X::AbstractMeshFace or X::AbstractMesh.\n\nThis is some extra notation that we often use in the library. We call a d-face to a face of d dimensions. We call vertices, edges, surfaces, and volumes to faces of 0, 1, 2, and 3 dimensions respectively. We call chain to a mesh, whose faces are all of the same dimension. The next figure shows a two-dimensional mesh embedded in a three-dimensional space. This mesh contains vertices, edges, and surfaces, but not volumes. This mesh is not a chain, but a face complex (see section Mesh topology).\n\n(Image: )\n\nFigure: Visualization of the faces in the mesh of a Möbius strip. We shrink the mesh faces to illustrate that faces are open sets. Otherwise faces of hider dimensions would hide faces of lower dimensions in the figure.\n\nmodule MeshGeo1 # hide\n#Code used to generate the figure\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport FileIO # hide\ncells = (4,40)\nmesh = GT.moebius_strip(cells;width=0.6)\nfig = Makie.Figure()\nelevation = 0.24π\nazimuth = -0.55π\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect,elevation,azimuth)\nshrink = 0.8\nshading = Makie.NoShading\nGT.makie_surfaces!(mesh;shrink,shading,dim=2)\nGT.makie_edges!(mesh;shrink,dim=1)\nGT.makie_vertices!(mesh;shrink,dim=0)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_defs_1.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide","category":"section"},{"location":"src_md/manual_mesh_geometry/#Face-ids","page":"Mesh geometry","title":"Face ids","text":"We assign a unique integer, called the face id textid(F), to each face Fin M of a given dimension d . Face ids are assigned per dimension (two faces of different dimension might have the same id). Thus, a face is uniquely identified by its face id and its dimension d. The face ids are arbitrary as long as they are consecutive integers starting by one. In the API, num_faces(M,d) returns the number of d-faces and faces(M,d) is the range 1:num_faces(M,d) containing all face ids in dimension d. There is a one-to-one relation between face objects and face ids. For a face object F::AbstractMeshFace, F_id=id(F) is the face id of F and F=each_face(M,d)[F_id] is the face F for a face id F_id::Integer. We often refer to face objects F and face ids F_id simply as \"a face\" since they are equivalent. In the API, the same operation can be done often in two different ways, one using face ids (integers) and another using face objects.","category":"section"},{"location":"src_md/manual_mesh_geometry/#Node-ids","page":"Mesh geometry","title":"Node ids","text":"Like in many other FE codes, the node coordinates of a face Fin M are encoded using a vector of node coordinates x(M) for the mesh  M and the node ids n(F) of the face F. In this setup, the node coordinates of a face x(F) are computed as x(F)_l = x(M)_ginmathbbR^D with g = n(F)_l for l=1ldotsn(F). The vector n(F) is often called  the local-to-global (index) map or the face connectivity. We call them the face node ids.  The value g is called the global node id  associated with the face-local (or simply local) node id l in face F.\n\nIn the API, the vector of node coordinates of a mesh is accessed with node_coordinates(M) for M::AbstractMesh. The length of this vector is num_nodes(M) and nodes(M) is the range 1:num_nodes(M) containing all possible node ids. For a given d, we collect the node ids of all d-faces in a mesh M in the vector returned by face_nodes(M,d). The node ids of a face with id F_id::Integer and dimension d are accessed with face_nodes(M,d)[F_id].  The coordinates of the local node l in face F_id are then computed by indexing the mesh coordinates  with the global node id g,  node_coordinates(M)[g] with g = face_nodes(M,d)[F_id][l].  The vector face_nodes(M,d) is a long vector of small vectors of integers with possibly different lengths.  It is often represented using a PartitionedArrays.JaggedArray object that uses continuous linear memory for performance.\n\nIt is also possible to access  node ids and node coordinates from a face object F::AbstractMeshFace as nodes(F)  and node_coordinates(F) respectively. Note that  nodes(F) and face_nodes(M,num_dims(F))[id(F)] are equivalent.","category":"section"},{"location":"src_md/manual_mesh_geometry/#Reference-ids","page":"Mesh geometry","title":"Reference ids","text":"Each physical face Fin M in a mesh is defined by means of a reference FE space hat V(F). Several faces often share the same reference space and often all faces of the same dimensions share the same reference space. For each dimension d, we collect the unique reference spaces of faces of dimension d in a tuple. This tuple is returned by reference_spaces(M,d) for a mesh object M::AbstractMesh.\n\nThe reference space assigned to a face is then obtained as reference_spaces(M,d)[r], where r is called the reference id of the face. The reference id is obtained from a face id F_id::Integer, by indexing the vector face_reference_id(M,d), namely r = face_reference_id(M,d)[F_id]. It can also be obtained from a face object F::AbstractMeshFace with r=reference_id(F), and the corresponding reference space with reference_space(F). Note that reference_id(F) and face_reference_id(M,num_dims(F))[id(F)] are equivalent.\n\nThe notion of reference id is introduced since different face  typologies such as simplices and hyper-cubes might be in the same mesh.  If all d-faces are topologically equivalent (which is often the case),  there is only one reference  space for all d-faces and their reference id is one.","category":"section"},{"location":"src_md/manual_mesh_geometry/#Reference-spaces","page":"Mesh geometry","title":"Reference spaces","text":"The reference space hat V(F) of a face Fin M is  is a scalar-valued (possibly high-order) Lagrange FE space  defined on the reference domain hat Omega(F). From this space, one can obtain  a vector of (high-order) node coordinates x(hat V(F)) and a vector of  shape functions s(hat V(F)).\n\nIn the code, the reference spaces in reference_spaces(M,d) are of a types that specializes the AbstractSpace interface. The AbstractSpace interface is detailed in section Interpolation. In this page, we only need to consider the vector of node coordinates node_coordinates(Vref) and the vector of scalar shape functions, shape_functions(Vref) for an object Vref::AbstractSpace. Each function in shape_functions(Vref) is evaluated at a point x::AbstractVector (often x::SVector), and returns a scalar value s::Real.\n\nOne can get a reference spaces from a mesh object as shown above or created from scratch with function lagrange_space. E.g., Vref = lagrange_space(Ωref,order) creates a reference space of order order on the reference domain Ωref.","category":"section"},{"location":"src_md/manual_mesh_geometry/#Reference-domains","page":"Mesh geometry","title":"Reference domains","text":"A reference domain hat Omega is a d-dimensional polytope embedded in the Euclidian space mathbbR^d. In particular, hat Omega is a segment, polygon, and a polyhedron for d=123 respectively. For d=0, we define a reference domain hat Omega=v as a set containing the only point  vinmathbbR^0. For d0. We define the boundary partialhat Omega of a reference domain hat Omega as the union partialhat Omega = U_Fin C bar F, where C is a chain of faces of dimension d-1 and bar F is the closure of a face F. E.g., the boundary of a segment is the union of two vertices. The boundary of a square is the union of four segments, and the boundary of a cube is the union of four squares. Assuming that partialhat Omega is closed, we define the reference domain hat Omega as the open bounded subset of mathbbR^d with boundary partialhat Omega. i.e., hat Omega is the space \"inside\" partialhat Omega. In the API, reference domains are often built as Ωref = unit_n_cube(Val(d)) or Ωref = unit_simplex(Val(d)) that create a unit hypercube or a unit simplex of d dimensions respectively.\n\nGiven a physical face Fin M, we call hatOmega(F) the reference domain associated with it, and C(hat Omega) the chain used to define hat Omega. In the API, one can get the reference domain from a face object F::AbstractMeshFace as Ωref=reference_domain(F) or from a reference space Ωref = domain(Vref) with Vref::AbstractSpace. The reference domain is also obtained from a face with id F_id::Integer and dimension d, by getting the reference space Vref=reference_spaces(M,d)[r] with r=face_reference_id(M,d)[F_id] and then calling Ωref = domain(Vref).","category":"section"},{"location":"src_md/manual_mesh_geometry/#Physical-faces","page":"Mesh geometry","title":"Physical faces","text":"A physical face Fin M is defined as the image phi^F(hat Omega(F)) of its reference domain hat Omega(F) via a map phi^F mathbbR^d rightarrow mathbbR^D, where d is the dimension of F and D is the ambient dimension of the mesh, see next Figure. This map is called the coordinate map and it is defined using the reference space hat V(F) and the node coordinates x(F) of the face F.\n\nThe coordinate map for a face F is defined as follows:\n\nphi^F(hat x) = sum_n=1^N^F x^F_n s^hat V_n(hat x)\n\nwhere N^F=s(hat V(F)) is the number of nodes of F and x^F_n=x(F)_n, and s^hat V _n=s(hat V(F)). This map transforms the node coordinates in the reference space x(hat V(F)) into the physical node coordinates of a face x(F) (see the orange dots in next figure). The map also transforms any other point in the reference domain, leading to potentially curved faces in the physical face.\n\nFrom a physical face F::AbstractMeshFace, we can obtain its coordinate map and additional geometrical information such as is barycenter and its diameter, namely coordinate_map(F), barycenter(F) and dimameter(F).\n\n(Image: )\n\nFigure: Effect of mapping a reference cube with a third order coordinate map. Orange dots illustrate the nodes before and after the map.\n\nmodule MeshGeo3 # hide\n#Code used to generate the figure\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport StaticArrays\nimport FileIO # hide\norder = 3\nΩref = GT.unit_n_cube(Val(3))\nMref = GT.mesh(Ωref)\nVref = GT.lagrange_space(Ωref,order)\nxref = GT.node_coordinates(Vref)\nT = StaticArrays.SVector{3,Float64}\nx = map(y->y + 0.1*(rand(T) .- 0.5) ,xref)\nnode_coordinates = x\nN = GT.num_nodes(Vref)\nface_nodes = [collect(1:N)]\nreference_spaces = (Vref,)\nM = GT.create_chain(;\n    node_coordinates,\n    face_nodes,\n    reference_spaces,\n   )\nF = GT.domain(M,3)\nfig = Makie.Figure()\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect)\nGT.makie_surfaces!(ax,Mref)\nMakie.scatter!(xref;color=Makie.Cycled(2))\nax = Makie.Axis3(fig[1,2];aspect)\nrefinement = 30\nGT.makie_surfaces!(ax,F;refinement)\nMakie.scatter!(x;color=Makie.Cycled(2))\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_defs_3.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide","category":"section"},{"location":"src_md/manual_mesh_geometry/#Face-groups","page":"Mesh geometry","title":"Face groups","text":"For a given d, we call a face group to a subset Gsubset M of the d-faces in a mesh M. A mesh is typically endowed with several of these groups to identify particular faces for modeling purposes, e.g., to impose boundary conditions, or define position-dependent material properties. Each group is given a group name, which identifies the group.\n\nIn the API, group_faces(M,d) provides access to the face groups for faces of dimension d. It is a Julia Dict. The keys are String objects for the group names, and the value group_faces(M,d)[group] is a vector of integers containing the face ids for faces inside the group with name name. The keys of this dictionary can also be accessed as group_names(M,d). Face groups are defined per dimension and it is accepted to have the same group name in two or more dimensions. It is also possible to add new groups by adding new key-value pairs to this dictionary.","category":"section"},{"location":"src_md/manual_mesh_geometry/#Example","page":"Mesh geometry","title":"Example","text":"We illustrate how a new face group is added to an existing mesh. We create a new group with all 2-faces whose center is inside the ball centered at the origin and radius 1. The example uses part of the API described above to find the faces to be added in the group. We color code faces inside the group with value 1, and outside with value 0.\n\nmodule MeshGeo4 # hide\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nusing LinearAlgebra\nimport FileIO # hide\n\n#Create a Cartesian mesh mesh\ndomain = (0,1,-1,1,0,1)\ncells = (10,20,10)\nmesh = GT.cartesian_mesh(domain,cells)\n\n#Find faces in new group\nd = 3\nmesh_faces = GT.each_face(mesh,d)\nnew_group_faces = findall(mesh_faces) do F\n    x = GT.barycenter(F)\n    norm(x) < 1\nend\n\n#Add new group to mesh\nGT.group_faces(mesh,d)[\"foo\"] = new_group_faces\n\n#Visualize\ncolor = GT.FaceColor(\"foo\")\nfig = Makie.Figure()\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect)\nsurfs = GT.makie_surfaces!(ax,mesh;dim=d,color)\nGT.makie_edges!(ax,mesh;color=:black)\nMakie.Colorbar(fig[1,2],surfs)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_defs_4.png\"),Makie.current_figure()) # hide\nend # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"src_md/manual_mesh_geometry/#Summary","page":"Mesh geometry","title":"Summary","text":"We discussed how computational meshes are defined in GalerkinToolkit and the core API of the AbstractMesh interface. The following table provides an overview of the math notation and corresponding API introduced in this page.\n\nConcept Notation API\nMesh M M::AbstractMesh\nPhysical face F F::AbstractMeshFace\nFace iteration Fin M each_face(M)\nDimensions d(x) num_dims(x)\nAmbient dimensions D(x) num_ambient_dims(x)\nCo-dimensions D(x)-d(x) num_codims(x)\nFace id textid(F) id(F)\nNode coordinates x(A) node_coordinates(A)\nNode ids n(A) nodes(A)\nNumber of nodes $ |n(A)| $ num_nodes(A)\nReference id  r=reference_id(F)\nReference space hat V(F) Vref=reference_space(F)\nShape functions s(V) shape_functions(Vref)\nReference domain hat Omega(F) reference_domain(F)\nChain C(hatOmega) \nFace groups  group_faces(M,d)\nGroup names  group_names(M,d)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"refindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"src_md/example_transient_heat_eq/#Transient-heat-equation","page":"Transient heat equation","title":"Transient heat equation","text":"(Image: )","category":"section"},{"location":"src_md/example_transient_heat_eq/#Problem-statement","page":"Transient heat equation","title":"Problem statement","text":"warning: Warning\nTODO","category":"section"},{"location":"src_md/example_transient_heat_eq/#Numerical-scheme","page":"Transient heat equation","title":"Numerical scheme","text":"warning: Warning\nTODO","category":"section"},{"location":"src_md/example_transient_heat_eq/#Implementation","page":"Transient heat equation","title":"Implementation","text":"using LinearAlgebra\nimport GalerkinToolkit as GT\nimport DifferentialEquations\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide\n\n#Parameters\nmesh_size=0.02\nR=0.15\nT=2\nN=100\n\n#Generate mesh with GMSH Julia API\nmesh = GT.with_gmsh() do gmsh\n    R = 0.15\n    dim = 2\n    gmsh.option.set_number(\"General.Verbosity\", 2)\n    rect_tag = gmsh.model.occ.add_rectangle(0,0,0,1,1)\n    circle_tag = gmsh.model.occ.add_circle(0.5,0.5,0,R)\n    circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])\n    circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])\n    gmsh.model.occ.cut([(dim,rect_tag)],[(dim,circle_surf_tag)]);\n    gmsh.model.occ.synchronize()\n    domain_tags = [1]\n    outer_tags = [6,7,8,9]\n    inner_tags = [5]\n    gmsh.model.model.add_physical_group(dim,domain_tags,-1,\"domain\")\n    gmsh.model.model.add_physical_group(dim-1,outer_tags,-1,\"outer\")\n    gmsh.model.model.add_physical_group(dim-1,inner_tags,-1,\"inner\")\n    gmsh.option.set_number(\"Mesh.MeshSizeMax\",mesh_size)\n    gmsh.model.mesh.generate(dim)\n    GT.mesh_from_gmsh(gmsh)\nend\n\n#Domains\nΩ = GT.interior(mesh;group_names=[\"domain\"])\nΓ = GT.boundary(mesh;group_names=[\"outer\",\"inner\"])\n\n#Interpolation\nk = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γ)\nuh = GT.undef_field(Float64,V)\n\n#Integration\ndegree = 2*GT.order(V)\ndΩ = GT.measure(Ω,degree)\n\n#Initial condition\nu0 = GT.analytical_field(x->0.0,Ω)\nGT.interpolate_free!(u0,uh)\n\n#Time-dependent Dirichlet function\nα = t -> sin(3*pi*t)\nfunction dirichlet_dynamics!(t,uh,duh=nothing)\n    if uh !== nothing\n        g = GT.analytical_field(Γ;piecewise=true) do x,name\n            if name == \"inner\"\n                α(t)\n            else\n                0.0\n            end\n        end\n        GT.interpolate_dirichlet!(g,uh)\n    end\n    if duh !== nothing\n        g = GT.analytical_field(Γ;piecewise=true) do x,name\n            if name == \"inner\"\n                ForwardDiff.derivative(α,t)\n            else\n                0.0\n            end\n        end\n        GT.interpolate_dirichlet!(g,duh)\n    end\nend\n\n#Definition of the ODE problem\nC = 10\n∇ = ForwardDiff.gradient\nm = (u,v) -> GT.∫(x->C*v(x)*u(x),dΩ)\na = (u,v) -> -1*GT.∫(x->∇(u,x)⋅∇(v,x), dΩ)\nr = (uh,t) -> v -> a(uh,v)\nj = (uh,t) -> a\ntspan = (0.0,T)\nproblem = GT.SciMLBase_ODEProblem(tspan,uh,m,r,j;dirichlet_dynamics!)\n\n#Selection and setup of the ODE solver\ndt = T/N\nsolver = DifferentialEquations.QNDF(autodiff=false);\ninitializealg=DifferentialEquations.NoInit()\nadaptive=false\nsave_on=false\nintegrator = DifferentialEquations.init(\n    problem,solver;initializealg,dt,adaptive,save_on)\n\n#Setup Makie scene\naxis = (aspect = Makie.DataAspect(),)\nfig = Makie.Figure()\ncolorrange = (-1,1)\nax,sc = GT.makie_surfaces(fig[1,1],Ω;color=uh,axis,colorrange)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\n\n#Record Makie scene while solving\nfn = \"fig_transient_heat_equation_1.gif\"\nfile = joinpath(@__DIR__,fn)\nMakie.record(fig,file,integrator) do integrator\n    sc.color = GT.solution_field(integrator)\nend\nnothing # hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"(Image: ) (Image: ) (Image: )\nHello, World! Interior penalty Lagrange multipliers\n(Image: ) (Image: ) (Image: )\nPoisson equation p-Laplacian Linear elasticity\n(Image: ) (Image: ) (Image: )\nStokes lid-driven cavity Transient heat equation Laplace-Beltrami","category":"section"},{"location":"src_md/manual_mesh_topology/#Mesh-topology","page":"Mesh topology","title":"Mesh topology","text":"In this page, we discuss how to \"glue\" faces in a face complex. A face complex is a mesh with some additional properties (see definition below) that allow us to formalize the meaning of \"gluing\" faces. This information is needed in many finite element (FE) methods, e.g., to build (high-order) conforming FE spaces, or to integrate at face interfaces.","category":"section"},{"location":"src_md/manual_mesh_topology/#Local-faces","page":"Mesh topology","title":"Local faces","text":"In order to define what a face complex is, first, we need to introduce the concept of local faces. To this end, let Fin M be a physical face in mesh M, where hatOmega=hatOmega(F) is its reference domain. Let us also consider the chain hat C=C(hat Omega) used to define the geometry of the reference domain hat Omega and let d be the dimension of hat Omega. See Section Mesh geometry for the definition of these concepts. Let us also define the interface Gamma(mathcalF) of a set of faces mathcalFsubset M as the open set such that its closure is the intersection of the closures of the faces in mathcalF, namely overlineGamma(mathcalF) = cap_Fin mathcalF bar F.\n\nWith these notations, we define the set of local faces of the reference domain hat Omega as the mesh L(hat Omega) containing:\n\nthe reference domain hat Omega,\nthe faces in the chain hat C,\nand the interfaces Gamma(F_1F_2) of any pair of faces F_1F_2inhat C.\n\nThe set L(hat Omega) contains all faces in the boundary of the polytope hat Omega. E.g., for a reference edge, it contains the edge and the two end vertices. For a reference square, it contains the square, four edges, and the four vertices at the intersection of the edges. For a reference cube, it contains the cube, six surfaces, twelve edges, and eight vertices (see the next figure).\n\nIn the code, one can access the mesh of local faces from a reference domain Ωref::AbstractDomain with Mref = mesh(Ωref). The mesh Mref::AbstractMesh is like any other mesh used in the code and, e.g., it can be visualized as any other mesh shown in next Figure.\n\n(Image: )\n\nFigure: Visualization of the local faces of a reference cube, square, and segment. Faces are shrunk in the visualization to illustrate that they are open sets.\n\nmodule Meshes05 # hide\n#Code used to generate the figure\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport FileIO # hide\ndomain = (0,2,0,1,0,2)\ncells = (4,2,4)\nF3 = GT.unit_n_cube(Val(3))\nF2 = GT.unit_n_cube(Val(2))\nF1 = GT.unit_n_cube(Val(1))\nM3 = GT.mesh(F3)\nM2 = GT.mesh(F2)\nM1 = GT.mesh(F1)\nfig = Makie.Figure()\naspect = :data\nax = Makie.Axis3(fig[1,1];aspect)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nshrink = 0.8\nGT.makie_surfaces!(ax,M3;dim=2,shrink)\nGT.makie_surfaces!(ax,M3;dim=3,shrink)\nGT.makie_edges!(ax,M3;dim=1,shrink)\nGT.makie_vertices!(ax,M3;dim=0,shrink)\naspect = Makie.DataAspect()\naxis = (;aspect)\nax, = GT.makie_surfaces(fig[1,2],M2;dim=2,shrink,axis)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_edges!(M2;dim=1,shrink)\nGT.makie_vertices!(M2;dim=0,shrink)\nax = Makie.Axis(fig[1,3])\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_edges!(ax,M1;dim=1,shrink)\nGT.makie_vertices!(ax,M1;dim=0,shrink)\nFileIO.save(joinpath(@__DIR__,\"fig_meshes_defs_5.png\"),fig) # hide\nend # hide\nnothing # hide","category":"section"},{"location":"src_md/manual_mesh_topology/#Conforming-meshes","page":"Mesh topology","title":"Conforming meshes","text":"A mesh M is conforming if for any pair of faces F_1F_2in M with non-empty interface Gamma_12=Gamma(F_1F_2)neqempty exists a local face f_1in L(hatOmega(F_1)) and a local face  f_2in L(hatOmega(F_2)) such that\n\ntheir images via the coordinate map coincide with the interface, Gamma_12=phi^F_1(f_1)=phi^F_2(f_2), and\nthey share global node ids, n(F_1f_1)=Pn(F_2f_2).\n\nIn this definition, P is a permutation matrix and n(Ff) is a vector containing the node ids of F restricted to the local face fin L(hatOmega(F)), namely n(Ff)_r=n(F)_l with l=n(f)_r. Both local faces have the same global ids but these ids are allowed to be order differently in each local face. This is why we include the permutation matrix P. If these local faces exist, we say that face F_1 is conforming to face F_2 at the interface Gamma_12, via the local face f_1 (idem for F_2). We also say that the local faces f_1 and f_2, and the interface Gamma_12 are equivalent.","category":"section"},{"location":"src_md/manual_mesh_topology/#Face-complexes","page":"Mesh topology","title":"Face complexes","text":"With these notations we introduce the concept of face complex as follows. A mesh M is a face complex (or a polyhedral complex) if\n\nit is conforming, and\nit contains the images of all local faces, namely phi^F(f)in M for all fin L(hatOmega(F)) and all Fin M.\n\nGiven a mesh M that is conforming, but not a face complex, it is always possible to add additional faces to make it a face complex (see next figure). In the API, this is done with function M2 = complexify(M) from a mesh object M::AbstractMesh. The result M2::AbstractMesh is a face complex. With function is_face_complex(M) one checks if M is a face complex. It returns true form meshes created with function complexify. Note that the chain hat C used to define the local faces L(hat Omega) above is conforming, the set of local faces L(hat Omega) is a face complex. In the code, we create the local faces using function complexify and the chain hat C. Many functions in the  Mesh generation page return face complexes by default.\n\n(Image: )\n\nFigure: Visualization of two conforming meshes. The mesh on the left, has vertices, edges, and surfaces, but it is not a face complex. The mesh on the right is the face complex obtained by calling complexify on the mesh of the left. I.e., we add the missing faces to make the mesh a face complex.\n\nmodule MeshTopology2 # hide\n#Code used to generate the figure\nimport GalerkinToolkit as GT\nimport GLMakie as Makie\nimport FileIO # hide\ndomain = (0,1,0,1)\ncells = (4,4)\nmesh = GT.cartesian_mesh(domain,cells;complexify=false)\nfig = Makie.Figure()\naxis = (;aspect=Makie.DataAspect())\nshading = Makie.NoShading\nshrink = 0.8\nax, = GT.makie_surfaces(fig[1,1],mesh;axis,shading,shrink)\nGT.makie_edges!(fig[1,1],mesh;shrink,dim=1)\nGT.makie_vertices!(fig[1,1],mesh,dim=0)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nmesh2 = GT.complexify(mesh)\n@assert GT.is_face_complex(mesh2)\nax, = GT.makie_surfaces(fig[1,2],mesh2;axis,shading,shrink)\nGT.makie_edges!(fig[1,2],mesh2;shrink,dim=1)\nGT.makie_vertices!(fig[1,2],mesh2,dim=0)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nFileIO.save(joinpath(@__DIR__,\"fig_mesh_topo_2.png\"),fig) # hide\nend # hide\nnothing # hide","category":"section"},{"location":"src_md/manual_mesh_topology/#Gluing-faces","page":"Mesh topology","title":"Gluing faces","text":"Let us consider a face complex M, a face Fin M, and the set of faces mathcalA(F) such that their interface Gamma(mathcalA(F))=F  coincides with face F. If these face exist, we call mathcalA(F) the faces around F. We refer to gluing faces mathcalA(F) at the their interface F as solving the following two-step problem for each face around AinmathcalA(F):\n\nFind the local face ain L(hatOmega(A)) and the permutation matrix P such that n(F)=P n(Aa).\nBuild a map varphi such that phi^A(phi^a(varphi(x)))=phi^F(x) for all xin hatOmega(F).\n\nFor this problem to have a solution, the mesh M needs to be conforming. This is what allows us to find the local face a, the permutation matrix P, and the map varphi. In addition, mesh M needs to be a face complex so that the interface Gamma(mathcalA(F))in M is also a face in the mesh, i.e., face F. In this case, it makes sense to talk about the node ids of the interface n(F), its coordinate map phi^F, and its reference domain hatOmega(F).\n\nnote: Note\nTODO: The code is currently working with the inverse of the permutation matrix P, namely P n(F)= n(Aa). In the future we will use the definition of P as in n(F)=P n(Aa).\n\nBy solving this problem, we are building a common parametrization of the interface seen from each face around. This is the key ingredient needed to compute integrals at the interface of quantities defined on the faces around. and to build interpolations defined on the faces around that are conforming at the interface.\n\nOnce the step 1. of the problem is solved and we have the local face a and the permutation matrix P, the map varphi solution of step 2. is readily computed as\n\nvarphi(xi) = sum_n=1^hat N Phat x_n hat s_n(xi)\n\nwhere hat x=x(hat V(a)), hat s=s(hat V(a)), and hat N is the length of hat x and hat s. Thus, the only remaining  part of the face-gluing problem is step 1. In the code, the solution of this step is encoded for all possible interfaces in the object returned by T=topology(M) for a mesh object M::AbstractMesh.  The returned object T is an instance of a type  that implements the AbstractTopology interface.  We detail now the main methods in this interface.","category":"section"},{"location":"src_md/manual_mesh_topology/#Face-incidence","page":"Mesh topology","title":"Face incidence","text":"We define the topology of M as the graph T, where the vertices of T are the faces in M and its edges are refined as follows: The edges (F_1F_2) and (F_2F_1) connecting two faces F_1F_2in M exists in the graph T if\n\nthe two faces are the same, F_1 = F_2, or\nthe two faces are of different dimensions and have a non-empty interface, d(F_1)neq d(F_2) and Gamma(F_1F_2) neq empty.\n\nIf two faces are connected by an edge in the graph T, we say that the faces are incident, or  adjacent. Note that this graph is symmetric.\n\nIn the API,  The graph is encoded using adjacency lists  organized according to face dimensions.  The adjacency list containing the edges starting at faces of dimension m and ending at a faces of dimension n is returned by function  face_incidence(T,m,n). One recovers all edges in the graph T by calling this function for all possible pairs (m,n) with m in 0:D and n in 0:D, being D=num_dims(M).  The result of face_incidence(T,m,n) is a long vector of small vectors of integers encoded via a JaggedArray object, since the inner vectors often have different lengths.\n\nThe vector As=face_incidence(T,m,n)[F] has the following interpretation for a face F with face id F::Integer. For m<n, the ids in As are the ids of the faces around mathcalA(F), which are arbitrarily sorted in vector As. For m>n, the vector As contains the ids of the n-faces on the boundary of F. In this case, the ids in As are sorted according to the id of the local faces of F, namely A=As[f] means that the local n-face  f of F  with id f::Integer is equivalent to the n-face Ain M with id A. For m==n, the vector As is equal to [F] by definition (a vector with a single integer).\n\nFrom the mesh topology T, we can get, for a given face Fin M, the set of faces around mathcalA(F)subset M, and  the local face ain L(hatOmega(A)) that is equivalent to F for each face around AinmathcalA(F). Consider a topology object T::AbstractTopology and let F be the m-face in mesh M with id F::Integer. We get the ids of the n-faces around F as As=face_incidence(T,m,n)[F]. For each A in As, we get the id a of the local face  of A equivalent to F as follows. We get all m-faces at the boundary of A with Bs=face_incidence(T,n,m)[A], and we find in which position in Bs the id F is located, namely a=findfirst(B->B==F,Bs).\n\nIt is also possible to access to the same information using face objects rather than face ids. Given a face object F::AbstractMeshFace one iterates over all faces around of dimension m, and gets the local face equivalent to F:\n\nfor A in each_face_around(F,n)\n    # A is an AbstractMeshFace\n    a = local_face(A,F)\n    # a is an AbstractSpace,\n    # but in the mesh of local faces of A.\nend","category":"section"},{"location":"src_md/manual_mesh_topology/#Node-permutations","page":"Mesh topology","title":"Node permutations","text":"To be able to glue faces mathcalA(F)subset M at the interfce F, we still need a way of obtaining the permutation matrix P such that Pn(Aa)=n(F) for each face around AinmathcalA(F) and its local face a equivalent to F. This information is encoded in the API as follows. All possible permutations for a local face a are contained in the vector k_P = node_permutations(Vref) where Vref::AbstractSpace is the object representing the reference space of a. The vector k_P at an index k, is a permutation vectorP. The permutation vector is equivalent to a permutation matrix P. Applying the permutation matrix P to a vector v, Pv is equivalent to indexing the vector object v with the permutation vector P, namely v[P].\n\nFrom all possible permutations in vector k_P, we obtain the permutation for local face a as follows. Let A::Integer and a::Integer be the ids of a n-face around AinmathcalA(F) and of its local m-face a equivalent to F. Then, we get the permutation P=k_P[k] for this local face by indexing k_P at the index k obtained as follows k=face_permutation_ids(T,n,m)[A][a]. Note that the function face_permutation_ids(T,n,m) has a similar structure than function face_incidence(T,n,m), both are vectors of vectors of integers, but the former contains the indices used to get the permutation vectors instead of face ids. The permutation vector P is more conveniently accessed given a face object F::AbstractMeshFace as follows:\n\nfor A in each_face_around(F,n)\n    a = local_face(A,F)\n    P = node_permutation(A,a)\nend","category":"section"},{"location":"src_md/manual_mesh_topology/#Example","page":"Mesh topology","title":"Example","text":"To wrap up, we show how to glue faces using the following example. For each face Fin M in a mesh, we show how to  find the local face a and permutation P for each face around AinmathcalA(F). In the example, n is the dimension of F and a and m is the dimension of A. We check that n(F)=P n(Aa).\n\nIn this first version of the example, we use face objects. The variables F, A, and a are  AbstractMeshFace objects representing faces  F, A, and a respectively.\n\nmodule MeshTopology3 # hide\nimport GalerkinToolkit as GT\ndomain = (0,1,0,1,0,1)\ncells = (5,5,5)\nM = GT.cartesian_mesh(domain,cells)\nm = 2\nn = 3\nfor F in GT.each_face(M,m)\n    for A in GT.each_face_around(F,n)\n        a = GT.local_face(A,F)\n        P = GT.node_permutation(A,a)\n        @assert GT.nodes(F) == GT.nodes(A)[ GT.nodes(a)[P]]\n    end\nend\nend # hide\n\nThis other version uses face ids instead of face objects and explicitly uses the mesh topology. Here, F, A, and a are the Integer ids of faces F, A, and a respectively.\n\nmodule MeshTopology4 # hide\nimport GalerkinToolkit as GT\nimport StaticArrays as SA\ndomain = (0,1,0,1,0,1)\ncells = (5,5,5)\nM = GT.cartesian_mesh(domain,cells)\nT = GT.topology(M)\nm = 2\nn = 3\nF_As = GT.face_incidence(T,m,n)\nA_Bs = GT.face_incidence(T,n,m)\nA_a_k = GT.face_permutation_ids(T,n,m)\nA_rA = GT.face_reference_id(M,n)\nrA_VA = GT.reference_spaces(M,n)\nF_nodes = GT.face_nodes(M,m)\nA_nodes = GT.face_nodes(M,n)\nfor F in 1:GT.num_faces(M,m)\n    As = F_As[F]\n    for A in As\n        Bs = A_Bs[A]\n        a = findfirst(B->B==F,Bs)\n        k = A_a_k[A][a]\n        rA = A_rA[A]\n        VA = rA_VA[rA]\n        ΩA = GT.domain(VA)\n        LA = GT.mesh(ΩA)\n        a_nodes = GT.face_nodes(LA,m)\n        a_ra = GT.face_reference_id(LA,m)\n        ra_Va = GT.reference_spaces(LA,m)\n        ra = a_ra[a]\n        Va = ra_Va[ra]\n        Ps = GT.node_permutations(Va)\n        P = Ps[k]\n        @assert F_nodes[F] == A_nodes[A][a_nodes[a][P]]\n    end\nend\nend # hide","category":"section"},{"location":"src_md/manual_mesh_topology/#Summary","page":"Mesh topology","title":"Summary","text":"We discussed the strategy to glue faces in GalerkinToolkit. It required to introduce concepts including local faces, the faces a round a face, face complex, and the mesh topology. The following table summarizes the key definitions in this page with its corresponding code API.\n\nConcept Notation API\nInterface Gamma(mathcalF) \nMesh topology T T::AbstractTopology\nTopology from mesh  T = topology(M)\nAdjacency list  face_incidence(T,m,n)\nCreate a face complex  complexify(M)\nCheck if face complex  is_face_complex(M)\nFaces around AinmathcalA(F) A in each_face_around(F,n)\nLocal faces L(hat Omega(A)) L=mesh(Ωref) with Ωref=reference_domain(A)\nLocal face of A equivalent to F  a=local_face(A,F)\nPermutation matrix/vector P P=node_permutation(A,a)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"src_md/manual_interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#Home","page":"Home","title":"Home","text":"Welcome to the documentation page of GalerkinToolkit!","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Home – This page.\nManual – The user and developer guide. It gives the detailed explanations on how to use and extend the library.\nExamples – They provide a quick overview of the main functionality of the library.\nTutorials – Learning material to get familiar with the building blocks of the library and the basics of the FEM. They are useful even if you are FEM expert as they walk you through the library step by step.\nAPI – All the docstrings are here.\n\nNB. This documentation is organized based on the Diátaxis model.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#What","page":"Home","title":"What","text":"GalerkinToolkit is a high-performance finite element (FE) toolbox fully implemented in the Julia programming language. It provides modular building blocks to easily implement custom finite element codes to solve partial differential equations (PDEs), using a variety of numerical schemes, and across diverse computing environments.  GalerkinToolkit integrates seamlessly with the broader Julia ecosystem. It supports external solvers such as PartitionedSolvers.jl, PetscCall.jl, LinearSolve.jl, NonLinearSolve.jl, and DifferentialEquations.jl to handle the algebraic systems resulting from PDE discretizations. For visualization, the toolkit provides plotting recipes for Makie.jl and utilities for exporting results in VTK format using WriteVTK.jl.","category":"section"},{"location":"#Why","page":"Home","title":"Why","text":"GalerkinToolkit is definitively not the first FEM software project out there, but it has some unique features. This includes a unified API with high- and low-level abstractions, a deep integration with the Julia package ecosystem, a new form compiler, and  a redesign of the core ideas behind Gridap.\n\nFind more information about GalerkinToolkit's features and novelties in the Introduction of the manual.","category":"section"},{"location":"#Code-examples","page":"Home","title":"Code examples","text":"(Image: ) (Image: ) (Image: )\nHello, World! Interior penalty Lagrange multipliers\n(Image: ) (Image: ) (Image: )\nPoisson equation p-Laplacian Linear elasticity\n(Image: ) (Image: ) (Image: )\nStokes lid-driven cavity Transient heat equation Laplace-Beltrami","category":"section"},{"location":"#How-to-start","page":"Home","title":"How to start","text":"In the Manual, you will find explanations about the software design and guides for users and developers.  Look into the Examples section for an overview of how to solve different types of PDEs with GalerkinToolkit. Learn how to use the library (and the basics of FEM) with the tutorials in the Tutorials section.","category":"section"},{"location":"#Pre-requisites","page":"Home","title":"Pre-requisites","text":"You need to be fluent in Julia before using GalerkinToolkit. You can learn Julia using the learning materials in julialang.org or the lecture notes in https://www.francescverdugo.com/XM_40017/dev/.\n\nIt is also required to be familiar with the basics of FE methods. The basics are explained in the Tutorials section. For more in depth introduction, you can use the following books:\n\nC. Johnson [1]\nJ. Whiteley [2]\nS.C. Brenner and L. R. Scott [3]","category":"section"},{"location":"#Help-and-discussion","page":"Home","title":"Help and discussion","text":"You can open a new discussion to ask questions here.\nIf you have found a bug, open an issue here. Do not forget to include a (minimal) reproducer.","category":"section"},{"location":"#How-to-cite","page":"Home","title":"How to cite","text":"See the CITATION.cff file.","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"This package is under active development and there are several ways to contribute:\n\nby enhancing the documentation (e.g., fixing typos, enhancing doc strings, adding examples).\nby addressing one of the issues waiting for help.\nby adding more tests to increase the code coverage.\nby extending the current functionality. In this case, open a discussion here to coordinate with the package maintainers before proposing significant changes.\n\nDiscuss with the package authors before working on any non-trivial contribution.","category":"section"},{"location":"#License","page":"Home","title":"License","text":"GalerkinToolkit is released under an MIT licence, except the this documentation webpage and all contents of the /docs/src folder), which are available under a CC BY 4.0 license.","category":"section"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"Since July 2024, this package is being developed with support from the Netherlands eScience Center under grant ID NLESC.SS.2023.008.","category":"section"},{"location":"#Affiliations","page":"Home","title":"Affiliations","text":"This project is maintained at the Computer Science department of Vrije Universiteit Amsterdam.","category":"section"},{"location":"src_md/example_hello_world_dg/#Interior-penalty","page":"Interior penalty","title":"Interior penalty","text":"(Image: )","category":"section"},{"location":"src_md/example_hello_world_dg/#Problem-statement","page":"Interior penalty","title":"Problem statement","text":"We solve the same PDE as in the Hello, World! example, but this time using a discontinuous Galerkin scheme.","category":"section"},{"location":"src_md/example_hello_world_dg/#Numerical-scheme","page":"Interior penalty","title":"Numerical scheme","text":"We consider the symmetric interior penalty method [4].","category":"section"},{"location":"src_md/example_hello_world_dg/#Implementation","page":"Interior penalty","title":"Implementation","text":"We solve the problem and visualize the solution. In this case, we draw the average of solution field  on the interior 2-faces of the computational mesh. There faces are where the interior penalty is enforced.","category":"section"},{"location":"src_md/example_hello_world_dg/#Implementation-2","page":"Interior penalty","title":"Implementation","text":"import FileIO # hide\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport ForwardDiff\nimport GLMakie as Makie\nimport LinearSolve\n\n#Geometry\ndomain = (0,1,0,1,0,1)\ncells = (4,4,4)\nmesh = GT.cartesian_mesh(domain,cells)\nD = GT.num_dims(mesh)\nn = GT.unit_normal(mesh,D-1)\nΩ = GT.interior(mesh)\nΓd = GT.boundary(mesh)\nΛ = GT.skeleton(mesh)\nh_Λ = GT.face_diameter_field(Λ)\nh_Γd = GT.face_diameter_field(Γd)\n\n#Functions\nconst ∇ = ForwardDiff.gradient\nconst g = GT.analytical_field(sum,Ω)\nconst f = GT.analytical_field(x->0,Ω)\nmean(f,u,x) = 0.5*(f(u[1],x)+f(u[2],x))\njump(u,n,x) = u[2](x)*n[2](x) + u[1](x)*n[1](x)\n\n#Interpolation\nk = 1\nconst γ0 = k*(k+1)/10\nγ = GT.uniform_quantity(γ0)\nV = GT.lagrange_space(Ω,k;continuous=false)\n\n#Integration\ndegree = 2*k\ndΩ = GT.quadrature(Ω,degree)\ndΛ = GT.quadrature(Λ,degree)\ndΓd = GT.quadrature(Γd,degree)\n\n#Weak form\na = (u,v) -> begin\n    #Laplace operator\n    GT.∫(dΩ) do x\n        ∇(u,x)⋅∇(v,x)\n    end +\n    #Interior penalty\n    GT.∫(dΛ) do x\n        (γ/h_Λ(x))*jump(v,n,x)⋅jump(u,n,x)-\n        jump(v,n,x)⋅mean(∇,u,x)-\n        mean(∇,v,x)⋅jump(u,n,x)\n    end +\n    #Nitsche term\n    GT.∫(dΓd) do x\n        (γ/h_Γd(x))*v(x)*u(x)-\n        v(x)*n(x)⋅∇(u,x)-\n        n(x)⋅∇(v,x)*u(x)\n    end\nend\nl = v -> begin\n    #RHS\n    GT.∫(dΩ) do x\n         v(x)*f(x)\n    end +\n    #Nietche term\n    GT.∫(dΓd) do x\n        (γ/h_Γd(x))*v(x)*g(x)-\n        n(x)⋅∇(v,x)*g(x)\n    end\nend\n\n#Linear problem\np = GT.SciMLBase_LinearProblem(Float64,V,a,l)\nsol = LinearSolve.solve(p)\nuh = GT.solution_field(V,sol)\n\n#Error check\neh = x -> uh(x) - g(x)\nel2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt\n@assert el2 < 1.0e-9\n\n#Visualization\nfig = Makie.Figure()\nax = Makie.Axis3(fig[1,1],aspect=:data)\nMakie.hidespines!(ax)\nMakie.hidedecorations!(ax)\nGT.makie_surfaces!(Λ;color=x->mean(GT.value,uh,x))\nFileIO.save(joinpath(@__DIR__,\"fig_hello_world_dg_1.png\"),Makie.current_figure()) # hide\nnothing # hide","category":"section"},{"location":"src_md/example_hello_world_dg/#Explicit-integration-loops","page":"Interior penalty","title":"Explicit integration loops","text":"This other code version implements the integration loops manually instead of relying on the underlying automatic code generation.\n\nfunction assemble_Ω!(A_alloc,b_alloc,V,dΩ)\n\n    #Temporaries\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Loop over bulk faces\n    tabulate = (∇,GT.value)\n    compute=(GT.coordinate,)\n    for V_face in GT.each_face(V,dΩ;tabulate,compute)\n        dofs = GT.dofs(V_face)\n        ndofs = length(dofs)\n        fill!(Auu,zero(T))\n        fill!(bu,zero(T))\n        for V_point in GT.each_point(V_face)\n            dV = GT.weight(V_point)\n            dof_∇s = GT.shape_functions(∇,V_point)\n            dof_s = GT.shape_functions(GT.value,V_point)\n            x = GT.coordinate(V_point)\n            fx = f.definition(x)\n            for i in 1:ndofs\n                v = dof_s[i]\n                bu[i] += v*fx*dV\n            end\n            for j in 1:ndofs\n                ∇u = dof_∇s[j]\n                for i in 1:ndofs\n                    ∇v = dof_∇s[i]\n                    Auu[i,j] += ∇v⋅∇u*dV\n                end\n            end\n        end\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n        GT.contribute!(b_alloc,bu,dofs)\n    end\n\nend\n\nfunction assemble_Λ!(A_alloc,V,dΛ)\n\n    #Temporaries\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n\n    #Loop over skeleton faces\n    tabulate = (∇,GT.value)\n    compute=(GT.unit_normal,)\n    V_dfaces = GT.each_face(V,dΛ;tabulate,compute)\n    dΛ_dfaces = GT.each_face(dΛ)\n    for (dΛ_dface,V_dface) in zip(dΛ_dfaces,V_dfaces)\n        h = GT.diameter(dΛ_dface)\n        dΛ_points = GT.each_point(dΛ_dface)\n        for V_Dface_i in GT.each_face_around(V_dface)\n            dofs_i = GT.dofs(V_Dface_i)\n            ndofs_i = length(dofs_i)\n            V_points_i = GT.each_point(V_Dface_i)\n            for V_Dface_j in GT.each_face_around(V_dface)\n                V_points_j = GT.each_point(V_Dface_j)\n                dofs_j = GT.dofs(V_Dface_j)\n                ndofs_j = length(dofs_j)\n                fill!(Auu,zero(T))\n                for (dΛ_point,V_point_i,V_point_j) in zip(dΛ_points,V_points_i,V_points_j)\n                    dS = GT.weight(dΛ_point)\n                    s_i = GT.shape_functions(GT.value,V_point_i)\n                    s_j = GT.shape_functions(GT.value,V_point_j)\n                    ∇s_i = GT.shape_functions(∇,V_point_i)\n                    ∇s_j = GT.shape_functions(∇,V_point_j)\n                    n_i = GT.unit_normal(V_point_i)\n                    n_j = GT.unit_normal(V_point_j)\n                    for j in 1:ndofs_j\n                        for i in 1:ndofs_i\n                            jump_jump = (γ0/h)*(s_i[i]*n_i)⋅(s_j[j]*n_j)\n                            jump_mean = (s_i[i]*n_i)⋅(0.5*∇s_j[j])\n                            mean_jump = (0.5*∇s_i[i])⋅(s_j[j]*n_j)\n                            Auu[i,j] += (jump_jump - jump_mean - mean_jump)*dS\n                        end\n                    end\n                end\n                GT.contribute!(A_alloc,Auu,dofs_i,dofs_j)\n            end\n        end\n    end\n\nend\n\nfunction assemble_Γd!(A_alloc,b_alloc,V,dΓd)\n\n    #Temporaries\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Loop over Dirichlet boundary\n    dΓd_dfaces = GT.each_face(dΓd)\n    tabulate = (∇,GT.value)\n    compute=(GT.unit_normal,)\n    V_dfaces = GT.each_face(V,dΓd;tabulate,compute)\n    for (V_dface,dΓd_dface) in zip(V_dfaces,dΓd_dfaces)\n        dofs = GT.dofs(V_dface)\n        ndofs = length(dofs)\n        V_points = GT.each_point(V_dface)\n        h = GT.diameter(dΓd_dface)\n        dΓd_points = GT.each_point(dΓd_dface)\n        fill!(Auu,zero(T))\n        fill!(bu,zero(T))\n        for (V_point,dΓd_point) in zip(V_points,dΓd_points)\n            dS = GT.weight(dΓd_point)\n            x = GT.coordinate(dΓd_point)\n            dof_s = GT.shape_functions(GT.value,V_point)\n            dof_∇s = GT.shape_functions(∇,V_point)\n            n = GT.unit_normal(V_point)\n            gx = g.definition(x)\n            for i in 1:ndofs\n                ∇v = dof_∇s[i]\n                v = dof_s[i]\n                bu[i] += ((γ0/h)*v*gx - n⋅∇v*gx)*dS\n            end\n            for j in 1:ndofs\n                ∇u = dof_∇s[j]\n                u = dof_s[j]\n                for i in 1:ndofs\n                    ∇v = dof_∇s[i]\n                    v = dof_s[i]\n                    Auu[i,j] += ((γ0/h)*v*u - v*n⋅∇u - n⋅∇v*u)*dS\n                end\n            end\n        end\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n        GT.contribute!(b_alloc,bu,dofs)\n    end\n\nend\n\nfunction integrate_l2_error(g,uh,dΩ)\n\n    #Iterators to the quantities on the\n    #integration points\n    tabulate = (GT.value,)\n    compute = (GT.coordinate,)\n    uh_faces = GT.each_face(uh,dΩ;tabulate,compute)\n\n    #Numerical integration loop\n    s = 0.0\n    for uh_face in uh_faces\n        for uh_point in GT.each_point(uh_face)\n\n            #Get quantities at current integration point\n            x = GT.coordinate(uh_point)\n            dV = GT.weight(uh_point)\n            uhx = GT.field(GT.value,uh_point)\n\n            #Add contribution\n            s += abs2(uhx-g.definition(x))*dV\n        end\n    end\n\n    #Compute the l2 norm\n    el2 = sqrt(s)\nend\n\n#Allocate matrix for free columns\nT = Float64\nA_alloc = GT.allocate_matrix(T,V,V,Ω,Λ,Γd)\nb_alloc = GT.allocate_vector(T,V,Ω,Γd)\n\n#Fill allocations with the function we wrote above\nassemble_Ω!(A_alloc,b_alloc,V,dΩ)\nassemble_Λ!(A_alloc,V,dΛ)\nassemble_Γd!(A_alloc,b_alloc,V,dΓd)\n\n#Compress matrix into the final format\nA = GT.compress(A_alloc)\nb = GT.compress(b_alloc)\n\n#Build the linear system\np = LinearSolve.LinearProblem(A,b)\n\n#Solve the problem\nsol = LinearSolve.solve(p)\nuh = GT.solution_field(V,sol)\n\n#Integrate the error l2 norm\n#with the function we wrote above\nel2 = integrate_l2_error(g,uh,dΩ)\n@assert el2 < 1.0e-9\nnothing # hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
