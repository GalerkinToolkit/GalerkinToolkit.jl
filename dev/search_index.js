var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Lectures","page":"Lectures","title":"Lectures","text":"","category":"section"},{"location":"tutorials/#Contents","page":"Lectures","title":"Contents","text":"","category":"section"},{"location":"tutorials/","page":"Lectures","title":"Lectures","text":"Introduction to the FEM","category":"page"},{"location":"manual/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"manual/getting_started/#Pre-requirements","page":"Getting started","title":"Pre-requirements","text":"","category":"section"},{"location":"manual/getting_started/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"EditURL = \"../src_jl/example_p_laplacian.jl\"","category":"page"},{"location":"src_md/example_p_laplacian/#p-Laplacian","page":"p-Laplacian","title":"p-Laplacian","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/#Problem-statement","page":"p-Laplacian","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Find the scalar-field u such that","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"leftlbrace\nbeginaligned\n-nabla cdot left( nabla u^p-2  nabla u right) = f textin Omega\nu = -1  texton  Gamma_0\nu = 1  texton  Gamma_1\nleft( nabla u^p-2 nabla u right)cdot n = 0  textelsewhere on  partialOmega\nendaligned\nright","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"with p2. The vector field n is the outwards unit normal vector to partialOmega. The computational domains are defined in the mesh file model.msh. The domain Omega is represented by the 3D faces in this mesh. The domain Gamma_0 is represented by the physical group named \"sides\" and Gamma_1 is the union of the physical groups named \"circle\", \"triangle\", and \"square\".  To solve this PDE, we use a conventional Galerkin finite element method with conforming Lagrangian FE spaces.","category":"page"},{"location":"src_md/example_p_laplacian/#Implementation","page":"p-Laplacian","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Import other dependencies.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Read and visualize the mesh.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"assets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"model.msh\")\nmesh = GT.mesh_from_msh(msh_file)\nnothing # hide\n\nMakie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_1.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define domains.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"dirichlet_0_names = [\"sides\"]\ndirichlet_1_names = [\"circle\", \"triangle\", \"square\"]\nΩ = GT.interior(mesh)\nΓ0 = GT.boundary(mesh;physical_names=dirichlet_0_names)\nΓ1 = GT.boundary(mesh;physical_names=dirichlet_1_names)\nΓd = GT.piecewise_domain(Γ0,Γ1)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define forcing data.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"g0 = GT.analytical_field(x->-1.0,Ω)\ng1 = GT.analytical_field(x->1.0,Ω)\ng = GT.piecewise_field(g0,g1)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define the interpolation space.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"k = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Interpolate Dirichlet values.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"T = Float64\nuh = GT.rand_field(T,V)\nGT.interpolate_dirichlet!(g,uh)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Visualize the Dirichlet field.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Makie.plot(Ω,color=uh,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define numerical integration.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"degree = 2*k\ndΩ = GT.measure(Ω,degree)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define weak form.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"const ∇ = ForwardDiff.gradient\nconst q = 3\nflux(∇u) = norm(∇u)^(q-2) * ∇u\ndflux(∇du,∇u) = (q-2)*norm(∇u)^(q-4)*(∇u⋅∇du)*∇u+norm(∇u)^(q-2)*∇du\nres = u -> v -> GT.∫( x-> ∇(v,x)⋅GT.call(flux,∇(u,x)), dΩ)\njac = u -> (du,v) -> GT.∫( x-> ∇(v,x)⋅GT.call(dflux,∇(du,x),∇(u,x)) , dΩ)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define non-linear problem using the automatic assembly loop generator.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"p = GT.nonlinear_problem(uh,res,jac)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define a nonlinear solver and solve the problem, and visualize the solution.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"s = PS.newton_raphson(p,verbose=true)\ns = PS.solve(s)\nuh = GT.solution_field(uh,s)\nMakie.plot(Ω;color=uh,strokecolor=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Now, solve while showing the intermediate results in the iteration process.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"uh = GT.rand_field(Float64,V)\nGT.interpolate_dirichlet!(g,uh)\np = GT.nonlinear_problem(uh,res,jac)\ns = PS.newton_raphson(p)\ncolor = Makie.Observable(uh)\nfig = Makie.plot(Ω;color,strokecolor=:black)\nfn = joinpath(@__DIR__,\"fig_p_laplacian.gif\")\nMakie.record(fig,fn,PS.history(s);framerate=2) do s\n    color[] = GT.solution_field(uh,s)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"EditURL = \"../src_jl/example_hello_world.jl\"","category":"page"},{"location":"src_md/example_hello_world/#Hello,-World!","page":"Hello, World!","title":"Hello, World!","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world/#Problem-statement","page":"Hello, World!","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"In this example, we show how to solve the \"Hello, world\" PDE example: the Poisson equation on the unit hyper-cube Omega  =01^d, din23, with Dirichlet boundary conditions.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"with f=0 and g(x)=textsum(x). In this case, we know that the solution is u=g which allows us to check that we solve the problem correctly, by integration an error norm.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"To solve this PDE, we use a conventional Galerkin finite element (FE) method with conforming Lagrangian FE spaces (see, e.g., [1] for specific details on this formulation).","category":"page"},{"location":"src_md/example_hello_world/#Implementation","page":"Hello, World!","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Import other dependencies","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Generate the computational mesh.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"domain = (0,1,0,1)\ncells = (10,10)\nmesh = GT.cartesian_mesh(domain,cells)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Visualize the mesh.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"axis = (aspect = Makie.DataAspect(),)\nMakie.plot(mesh;color=:pink,strokecolor=:blue,axis)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_1.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define the Dirichlet boundary.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"dirichlet_tag = \"dirichlet\"\nGT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Defile computational domains.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Ω = GT.interior(mesh)\nΓd = GT.boundary(mesh;physical_names=[dirichlet_tag])\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define differential operators","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"const ∇ = ForwardDiff.gradient\nΔ(f,x) = tr(ForwardDiff.jacobian(y->∇(f,y),x))","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define manufactured fields.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"g = GT.analytical_field(sum,Ω)\nf = GT.analytical_field(x->-Δ(g.definition,x),Ω)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define the interpolation space.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"k = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Interpolate Dirichlet values.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"T = Float64\nuhd = GT.zero_dirichlet_field(T,V)\nGT.interpolate_dirichlet!(g,uhd)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Visualize the Dirichlet field.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Makie.plot(Ω;color=uhd,strokecolor=:blue,axis)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define numerical integration.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"degree = 2*k\ndΩ = GT.measure(Ω,degree)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define weak form.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"a = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\nl = v -> GT.∫( x->v(x)*f(x), dΩ)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Assemble the problem using the automatic assembly loop generator","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"p = GT.linear_problem(uhd,a,l)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Solve the problem","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"s = PS.LinearAlgebra_lu(p)\ns = PS.solve(s)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Build the FE solution.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"uh = GT.solution_field(uhd,s)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Visualize the solution.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Makie.plot(Ω;color=uh,strokecolor=:black,axis)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Compute the L2 norm of the discretization error.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"eh = x -> uh(x) - g(x)\nel2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt","category":"page"},{"location":"src_md/example_hello_world/#Final-program","page":"Hello, World!","title":"Final program","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"module Program\n\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\n\nfunction main(;domain,cells)\n    mesh = GT.cartesian_mesh(domain,cells)\n    dirichlet_tag = \"dirichlet\"\n    GT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\n    Ω = GT.interior(mesh)\n    Γd = GT.boundary(mesh;physical_names=[dirichlet_tag])\n    ∇ = ForwardDiff.gradient\n    Δ(f,x) = tr(ForwardDiff.jacobian(y->∇(f,y),x))\n    g = GT.analytical_field(sum,Ω)\n    f = GT.analytical_field(x->-Δ(g.definition,x),Ω)\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n    T = Float64\n    uhd = GT.zero_dirichlet_field(T,V)\n    GT.interpolate_dirichlet!(g,uhd)\n    degree = 2*k\n    dΩ = GT.measure(Ω,degree)\n    a = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\n    l = v -> GT.∫( x->v(x)*f(x), dΩ)\n    p = GT.linear_problem(uhd,a,l)\n    s = PS.LinearAlgebra_lu(p)\n    s = PS.solve(s)\n    uh = GT.solution_field(uhd,s)\n    eh = x -> uh(x) - g(x)\n    el2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt\nend\n\nend # module","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Run it for a 2d case.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Program.main(domain=(0,1,0,1),cells=(10,10))","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Run it for a 3d case.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Program.main(domain=(0,1,0,1,0,1),cells=(10,10,10))","category":"page"},{"location":"src_md/example_hello_world/#References","page":"Hello, World!","title":"References","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"[1] C. Johnson. Numerical Solution of Partial Differential Equations by the Finite Element Method. Dover Publications, 2009.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"EditURL = \"../src_jl/example_poisson_equation.jl\"","category":"page"},{"location":"src_md/example_poisson_equation/#Poisson-equation","page":"Poisson equation","title":"Poisson equation","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/#Problem-statement","page":"Poisson equation","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Find the scalar field u such that","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton Gamma_rm D\nnabla ucdot n = h  texton  Gamma_rm N\nnabla ucdot n = 0  textelsewhere on  partial Omega\nendaligned\nright","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"being n the outwards unit normal vector to partialOmega. In this example, we chose f(x) = 1, g(x) = 2, and h(x)=3. The variable x is the position vector x=(x_1x_2x_3).  The computational domains are defined in the mesh file model.msh. The domain Omega is represented by the 3D faces in this mesh. The domain Gamma_rm D is represented by the physical group named \"sides\" and Gamma_rm N is the union of the physical groups named \"circle\", \"triangle\", and \"square\".  To solve this PDE, we use a conventional Galerkin finite element method with conforming Lagrangian FE spaces.","category":"page"},{"location":"src_md/example_poisson_equation/#Implementation","page":"Poisson equation","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Import other dependencies","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Read and visualize the mesh","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"assets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"model.msh\")\nmesh = GT.mesh_from_msh(msh_file)\nnothing # hide\n\nMakie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_0.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define domains and visualize them","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Ω = GT.interior(mesh)\nMakie.plot(Ω,color=:pink)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_1.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"dirichlet_names = [\"sides\"]\nΓd = GT.boundary(mesh;physical_names=dirichlet_names)\nMakie.plot(Γd,color=:pink)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"neumann_names = [\"circle\", \"triangle\", \"square\"]\nΓn = GT.boundary(mesh;physical_names=neumann_names)\nMakie.plot(Γn,color=:pink)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define forcing data","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"f = GT.analytical_field(x->1.0,Ω)\ng = GT.analytical_field(x->2.0,Ω)\nh = GT.analytical_field(x->3.0,Ω)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define the interpolation space.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"k = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Interpolate Dirichlet values.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"T = Float64\nuhd = GT.zero_dirichlet_field(T,V)\nGT.interpolate_dirichlet!(g,uhd)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Visualize the Dirichlet field.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Makie.plot(Ω,color=uhd,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_4.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define numerical integration.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"degree = 2*k\ndΩ = GT.measure(Ω,degree)\ndΓn = GT.measure(Γn,degree)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define weak form.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"const ∇ = ForwardDiff.gradient\na = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\nl = v -> GT.∫( x->v(x)*f(x), dΩ) + GT.∫( x->v(x)*h(x), dΓn)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Assemble the problem using the automatic assembly loop generator","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"p = GT.linear_problem(uhd,a,l)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Solve the problem","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"s = PS.LinearAlgebra_lu(p)\ns = PS.solve(s)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Build the FE solution.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"uh = GT.solution_field(uhd,s)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Visualize the solution.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Makie.plot(Ω;color=uh,strokecolor=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_5.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/for_developers/#For-developers","page":"For developers","title":"For developers","text":"","category":"section"},{"location":"manual/for_developers/#Building-the-documentation-locally","page":"For developers","title":"Building the documentation locally","text":"","category":"section"},{"location":"manual/for_developers/#Setup-the-docs-folder-environment","page":"For developers","title":"Setup the docs folder environment","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"We assume that your terminal is located in the root folder of the GalerkingToolkit.jl repo. Open Julia, pointing to the docs folder.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"$ julia --project=docs/","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"Develop your current copy of GalerkingToolkit.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> ]\n(docs) pkg> dev .","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"You will need to do this each time the dependencies of the documentation or of GalerkinToolkit change.","category":"page"},{"location":"manual/for_developers/#Standard-build","page":"For developers","title":"Standard build","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"After the setup, exit package mode and run","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/make.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"This will take a while. When it is done, you will have the html docs in the folder docs/build.","category":"page"},{"location":"manual/for_developers/#Visualizing-the-documentation","page":"For developers","title":"Visualizing the documentation","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The easiest way to visualize the documentation is using LiveServer as follows.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> using LiveServer\nserve(dir=\"docs/build/\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"After it, your docs will be served at the given url.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"If nor yet done, you can install LiveServer as follows. We recommend to install it in your global environment.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> ]\npkg> activate\npgk> add LiveServer","category":"page"},{"location":"manual/for_developers/#Quick-build","page":"For developers","title":"Quick build","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The standard build takes a long time since it runs several examples. This delay makes this approach impractical to write documentation, since one needs to build the docs often to check the final result.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"To avoid this, one can run all the files in docs/src/src_jl in advance using","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/make_media.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"and then one can quickly build the documentation with","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/make_with_media.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"This will work as long as you are not including new figures or animations that are generated by running the files in the docs/src/src_jl folder. Otherwise you will need to run the particular file with","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/src/src_jl/<file that generates the figure>.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"or running again","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/media.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The output documentation is not exactly the same as the generated with the standard build method, but it is good enough for development.","category":"page"},{"location":"manual/for_developers/#Performance-Benchmarks","page":"For developers","title":"Performance Benchmarks","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"There is a benchmark suite defined in GalerkinToolkitExamples/benchmarks. This uses BenchmarkTools.jl to perform the timings and github-action-benchmark to collect the results and store them in the benchmarks branch. Upon merging of a PR, and after the docs have built, the benchmark results are copied from the benchmarks branch into the gh-pages branch. This is required to prevent overwriting of the previous results by docs deployment etc.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"Graphs of performance changes over time (per commit hash) can then be viewed here: https://galerkintoolkit.github.io/GalerkinToolkit.jl/dev/bench/.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The github action can be configured (in .github/workflows/CI.yml, job benchmark) to fail if the performance change is beyond a given threshold. Look for the alert-threshold: and fail-on-alert: keys.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"More benchmarks can be added (or existing ones modified) in GalerkinToolkitExamples/benchmarks/run_benchmarks.jl.","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"EditURL = \"../src_jl/example_stokes.jl\"","category":"page"},{"location":"src_md/example_stokes/#Stokes-lid-driven-cavity","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"","category":"section"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"(Image: )","category":"page"},{"location":"src_md/example_stokes/#Problem-statement","page":"Stokes lid-driven cavity","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"We solve the lid-driven cavity for a stokes flow. We use an inf-sub stable high order formulation. The velocity is a continuous piecewise multi-linear polynomial of order order and the pressure is a discontinuous piecewise linear polinomyal of order order-1. We constraint the pressure to zero at an arbitrary point of the domain (the last pressure node) to end up with a problem with unique solution.","category":"page"},{"location":"src_md/example_stokes/#Implementation","page":"Stokes lid-driven cavity","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport GLMakie as Makie\nimport ForwardDiff\nimport StaticArrays\nimport Tensors\nusing LinearAlgebra\nimport FileIO # hide\ndomain = (0,1,0,1)\ncells = (20,20)\nD = length(cells)\nmesh = GT.cartesian_mesh(domain,cells)\nΩ = GT.interior(mesh)\nΓ1 = GT.boundary(mesh;physical_names=[\"1-face-2\"])\nΓ2 = GT.boundary(mesh;physical_names=[\"1-face-1\",\"1-face-3\",\"1-face-4\"])\ng1 = GT.analytical_field(x->StaticArrays.SVector(1,0),Ω)\ng2 = GT.analytical_field(x->StaticArrays.SVector(0,0),Ω)\ng = GT.piecewise_field(g1,g2)\nΓ = GT.piecewise_domain(Γ1,Γ2)\norder = 2\nV = GT.lagrange_space(Ω,order;space_type=:Q,tensor_size=Val((D,)),dirichlet_boundary=Γ)\nQ = GT.lagrange_space(Ω,order-1;space_type=:P,dirichlet_boundary=GT.last_dof())\nVxQ = V × Q\nu_field, p_field = 1,2\nuhph_dirichlet = GT.zero_dirichlet_field(Float64,VxQ)\nuhd = GT.field(uhph_dirichlet,u_field)\nGT.interpolate_dirichlet!(g,uhd)\ndΩ = GT.measure(Ω,2*order)\n∇ = ForwardDiff.jacobian\ndiv(u,x) = tr(∇(u,x))\na((u,p),(v,q)) = GT.∫( x-> ∇(v,x)⋅∇(u,x) - div(v,x)*p(x) + q(x)*div(u,x), dΩ)\nl((v,q)) = 0\np = GT.linear_problem(uhph_dirichlet,a,l)\ns = PS.LinearAlgebra_lu(p)\ns = PS.solve(s)\nuh,ph = GT.solution_field(uhph_dirichlet,s)\naxis = (aspect = Makie.DataAspect(),)\nMakie.plot(Ω;color=ph,axis)\nMakie.arrows!(uh;color=x->norm(uh(x)),lengthscale=0.1)\nFileIO.save(joinpath(@__DIR__,\"fig_stokes.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"(Image: )","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"EditURL = \"../src_jl/tutorial_intro_to_fem.jl\"","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Introduction-to-the-FEM","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"by Francesc Verdugo (VU Amsterdam)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"In this lecture, we will learn:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The gist of the finite element method (FEM).\nHow to solve a simple partial differential equation (PDE) with it.\nHow to express the key concepts in code using GalerkinToolkit.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"This lecture is useful even if you are a FEM expert if you want to learn GalerkinToolkit. It will walk you through the key parts of the library.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"This lecture is made available under a CC BY 4.0 license. The API documentation and source code of GalerkinToolkit is available under an MIT license.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Problem-statement","page":"Introduction to the FEM","title":"Problem statement","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We show how to solve a simple PDE with the FEM. To make this introduction really an introduction we consider the \"hello, world\" PDE: the Poisson equation.  Our goal is to solve it when adding Dirichlet boundary conditions. These are the inputs of the problem. A domain OmegasubsetmathbbR^d with d being the number of spatial dimensions (d=2 in this example), and two functions f, g such that fgOmegarightarrowmathbbR. The problem is formalized as finding the function uOmegarightarrowmathbbR such that","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"where Delta u = sum_i=1^d partial^2 u  partial x_i^2 is the Laplace operator and partialOmega is the boundary of Omega. We define Omega as a disk of radius one. This is a simple geometry, but yet more complex than a simple two-dimensional box. We this, we illustrate that FEM can be used to solve PDEs on complex geometries beyond simple \"boxes\".","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#The-method-of-manufactured-solutions","page":"Introduction to the FEM","title":"The method of manufactured solutions","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We are going to select f and g in such a way u is a known function. This will allow us to compare the numerical approximation computed with FEM against the theoretical exact solution u. This technique is known as the \"method of manufactured solutions\". Note that u is not known in practical applications.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us, \"manufacture\" f and g such that function u(x)=(sum_i=1^d x_i)^p is the solution of the PDE above. The scalar p is a given integer p0. It will be useful to see how the numerical solution will behave for different values of p.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"To manufacture function f and g, we applying the PDE operators to the expression for u. Function f is to be computed as f= -Delta ((sum_i=1^d x_i)^p) and g is simply g(x)=(sum_i=1^d x_i)^p. Applying the Laplace operator to (sum_i=1^d x_i)^p, we get the closed-form expression for f, namely f(x)= -d*p(p-1)(sum_i=1^d x_i)^(p-2).","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Numerical-approximation","page":"Introduction to the FEM","title":"Numerical approximation","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The FEM transforms a PDE into a system of linear algebraic equations of the form Ax=b, where A is a matrix and b is a vector. This reduces the problem of finding function u to finding vector x, which can be done on a computer using arrays and other numeric data structures. The FEM does not look for the exact function u, but for approximations of it that can be written as a linear combination of a finite number of basis functions,","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u^mathrmfem(x)=sum_j=1^N alpha_j s_j(x)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"where alpha_i are the coefficients of the linear combination and s_i are functions such that s_iOmegarightarrowmathbbR. The integer N is the number of terms in the linear combination. The basis functions s_i are also called \"shape functions\" or \"hat functions\". The goal of FEM is to find suitable values for alpha_i and s_i(x) such that u^mathrmfem is a good approximation of the exact solution u: u^mathrmfem(x)approx u(x) for points xinOmega. The more computational effort we put in building function u^mathrmfem the better will be the approximation.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Workflow","page":"Introduction to the FEM","title":"Workflow","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Function u^mathrmfem is built as follows. First, we define the auxiliary functions s_i(x). This step is referred to as the \"numerical discretization\" and entails defining a computational mesh and a finite element (FE) function space. The next step is building a system of linear algebraic equations Ax=b. This step is called the \"FEM assembly\" step. Then, one solves for the vector x in what is called the \"solver\" or \"solution\" step. At this points, the coefficients alpha_i can be computed using both vector x and the Dirichlet boundary conditions of the PDE. The final step is typically some post-process of function u^mathrmfem. For instance, visualize it, store it in a file, compute some quantity of interest, etc. In summary, these are the key phases in a FEM computation:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Discretization\nAssembly\nSolution\nPost-process","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Mesh-generation","page":"Introduction to the FEM","title":"Mesh generation","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The FEM starts by building a \"triangulation\" mathcalT of the domain Omega in which the PDE is defined. A triangulation mathcalT is a set of simpler domains T_ksubsetmathbbR^d, whose union is an approximation of Omega,  cup_k=1^M T_kapproxOmega. Each domain T_k is called an \"element\", a \"cell\" or a \"face\", and they are typically simple geometries such as triangles, tetrahedra, hexahedra, etc. The integer M denotes the number of elements. The triangulation is also called a computational \"mesh\" or a computational \"grid\".","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let's build a mesh for our domain Omega using code. First, let us load all packages that we will use in this lecture:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"using LinearAlgebra\nusing Random\nimport GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"A common practice in GalerkinToolkit is to load packages in the Julia standard library with using. Other packages are loaded with import. This makes clear from which package each function comes from, while assuming that developers already know functions in the standard library.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The following cell builds a triangulation (a mesh object) using the external mesh generation tool GMSH. The variable mesh_size controls how small are the cells in the mesh. We start with a coarse mesh to make visualization easier. We are not going to comment in detail all code lines. We will discuss only the parts relevant in this high-level introduction. You can refer to the API documentation and other tutorials when needed.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"mesh_size = 0.3\nR = 1 #Radius\nmesh = GT.with_gmsh() do gmsh\n    dim = 2\n    circle_tag = gmsh.model.occ.add_circle(0,0,0,R)\n    circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])\n    circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])\n    gmsh.model.occ.synchronize()\n    gmsh.model.model.add_physical_group(dim,[circle_surf_tag],-1,\"Omega\")\n    gmsh.option.setNumber(\"Mesh.MeshSizeMax\",mesh_size)\n    gmsh.model.mesh.generate(dim)\n    GT.mesh_from_gmsh(gmsh)\nend\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The mesh we just created can be visualized both with Paraview and Makie. We use Makie in this lecture.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"axis = (aspect = Makie.DataAspect(),)\nMakie.plot(mesh;color=:pink,strokecolor=:blue,axis)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_mesh.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Computational-domains","page":"Introduction to the FEM","title":"Computational domains","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that two domains appear in the definition of the PDE above, the domain Omega and its boundary partialOmega. We need to build data objects representing them to solve the PDE with GalerkinToolkit. They are built from the mesh objects as follows:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Ω = GT.interior(mesh)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"∂Ω = GT.boundary(mesh)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We can also visualize them using Makie.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Makie.plot(Ω;color=:pink,axis)\nMakie.plot!(∂Ω;color=:blue,linewidth=3)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_domains.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that Ω is indeed an approximation of the unit disk (visualized as a pink surface), and ∂Ω is its boundary (visualized with blue lines).","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#FE-space","page":"Introduction to the FEM","title":"FE space","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us now build the data structure representing the finite element function u^mathrmfem. We need two ingredients, the functions s_i and the coefficients α_i. Functions s_i are linearly independent and can be understood as the basis of a vector space V=mathrmspans_1ldotss_N. This space is called the FE space. There are many ways of defining FE spaces. Here, we will use the simplest one, which is based on Lagrange polynomials. To build it with GalerkinToolkit, we need the computational domain on which the functions of the space are defined and their polynomial degree, since these function are polynomials inside the cells of the mesh.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"degree = 2\nV = GT.lagrange_space(Ω,degree)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We will discus the mathematical derivation of this FE space in another lecture. For now, it is enough to understand that the object V has information about the basis functions s_i. For instance, you can get the number of basis functions with","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"N = GT.num_dofs(V)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The word \"dofs\" stands for degrees of freedom (DOFs). Each coefficent alpha_i can be understood as a degree of freedom, i.e., a quantity that can be tweaked to modify function u^mathrmfem.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The coefficients alpha_i are unknown at this point. We will compute them later. For the moment, we can build a mock u^mathrmfem using some random coefficients alpha_i just to see the connection between the coefficients  alpha_i and the resulting function u^mathrmfem. We create them as a random vector of length N.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Random.seed!(1)\nα = rand(N)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We create the function from these coefficients and the FE space as follows:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u_fem = GT.discrete_field(V,α)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"As suggested by the function name, the numerical approximation is called \"discrete field\" in GalerkinToolkit. The field is \"discrete\" since it is expressed in terms of a finite number of degrees of freedom.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let's us visualize it. We do this by plotting domain Omega, using the function value as the color code.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=u_fem,refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_rand_field.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"By looking into the figure it is clear that function u^mathrmfem(x) is indeed a function that can be evaluated at any point inside the domain Omega, i.e., a field.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Dual-operators","page":"Introduction to the FEM","title":"Dual operators","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The FEM also consider a basis for V^prime, the dual space of V. Basis functions in the dual space are linear operators sigma_iVrightarrowmathbbR that map functions in the original (primal) space V into real values. The particular definition of these operators is not important in this lecture. See them as black boxes, that fulfill  these properties: The operators sigma_i are linear, there is one operator sigma_i for each shape function s_i, and they  are related with this formula sigma(s_j)=delta_ij, where delta_ij is Kroneker's delta. Operator sigma_i maps the shape function s_i to one, sigma_i(s_i)=1, and maps the other shape functions to zero, sigma_i(s_j)=0 for ineq j. This property allows us to compute alpha_i as the application of operator sigma_i to the numerical approximation u^mathrmfem, namely alpha_i=sigma_i(u^mathrmfem). You can understand sigma_i(u^mathrmfem) as \"extract\" coefficient alpha_i from u^mathrmfem. You can easily prove this by taking sigma_i(u^mathrmfem) = sigma_i(sum_j=1^N alpha_j s_j) and considering that sigma_i is linear and sigma_i(s_j)=delta_ji.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#FE-interpolation","page":"Introduction to the FEM","title":"FE interpolation","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Using the dual operators, we can define an interpolation operator that builds a function in the FE space V from a given function fOmegarightarrowmathbbR :","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Pi^mathrmfem f)(x) = sum_j=1^N sigma_j(f) s_j(x)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us do this interpolation using code for a particular function. First, we need to define the function we want to interpolate","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"f = GT.analytical_field(Ω) do x\n    sin(4*pi*x[1])*cos(4*pi*x[2])\nend\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We have build an \"analytical field\", which is a field defined by an analytical function. Let us visualize it.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=f,refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_f.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We interpolate the field using code","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"f_fem = GT.interpolate(f,V)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and we visualize the result","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=f_fem,refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_f_fem.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that the interpolated field is an approximation of the original one. The \"noisier\" the original field, the worse will be the interpolation. Also the larger the number of DOFs in the space V the better will be the interpolation.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Free-and-Dirichlet-DOFs","page":"Introduction to the FEM","title":"Free and Dirichlet DOFs","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Remember that our goal is to find the coefficients α_i. Most of them are unknown, but not all. Note that the PDE states that u=g on the boundary partialOmega. With this information we can compute some of the coefficients alpha_i directly, without solving a linear system. To find out which coefficients are really unknown and which can be computed from the boundary condition, we classify the shape functions s_i into two groups: the s_i that are zero at any point of the boundary, s_i(x) = 0 for all xinpartialOmega, in one group, and the rest in the second group. We denote s^mathrmf_i the shape function number i in the first group, and s^mathrmd_i function number i in the second group. Letters \"f\" and \"d\" stand for \"free\" and \"Dirichlet\" as they will be associated with unknown (free) coefficients and coefficients computed from the Dirichlet condition respectively. Using this classification  of the shape functions, we can also classify the coefficients alpha_i, and the dual operators sigma_i. Consider starin(mathrmfmathrmd). The coefficient alpha^star_i is the one that multiplies s^star_i and sigma^star_i is its associated dual operator. We can also define the space V^star=mathrmspans^star_1ldotss^star_N^star as the subspace of V generated by the shape functions s^star_i. Finally,  we call N^star the number of shape functions s^star_i for starin(mathrmfmathrmd),  i.e, the number of free and Dirichlet DOFs.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The shape functions are classified in the code by creating a FE space that is aware of the Dirichlet boundary:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"V = GT.lagrange_space(Ω,degree;dirichlet_boundary=∂Ω)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Now the DOFs in this space are split on two groups: free and Dirichlet. We can get the number of free DOFs","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"N_f = GT.num_free_dofs(V)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and the number of Dirichlet DOFs.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"N_d = GT.num_dirichlet_dofs(V)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Dirichlet-Field","page":"Introduction to the FEM","title":"Dirichlet Field","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Using the classification of nodes, we can decompose function u^mathrmfem(x) as the sum of two functions,","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u^mathrmfem(x)=u^mathrmf(x)+u^mathrmd(x)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"with","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u^star(x)=sum_j=1^N^star alpha^star_j s^star_j(x) text for  starin(mathrmfmathrmd)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that u^mathrmfin V^mathrmf is a linear combination of the \"free\" shape functions, and u^mathrmdin V^mathrmd is a linear combination of the \"Dirichlet\" shape functions.  This decomposition is useful because u^mathrmd can be directly computed from the Dirichlet Boundary condition. We refer to u^mathrmd as the \"Dirichlet field\". It is computed by building the coefficients alpha^mathrmd_i=sigma^mathrmd_i(g) as the application of the linear operators for the Dirichlet DOFs on function g. In other words, u^mathrmd is built as the interpolation of the Dirichlet function g onto the space V^mathrmd, u^mathrmd=Pi^mathrmd g. The interpolation to the spaces V^mathrmf and V^mathrmd of a given funciton f is defined as we did for V, but only taking the corresponding shape functions:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Pi^star f)(x) = sum_j=1^N^star sigma^star_j(f) s^star_j(x) text for  starin(mathrmfmathrmd)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us build the Dirichlet field with code. First, we need to build an analytical field representing the Dirichlet function. We take p=3 for example.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"g = GT.analytical_field(Ω) do x\n    sum(x)^3\nend\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Then, we interpolate this field, but only on the Dirichlet DOFs, yielding the Dirichlet field","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u_d = GT.interpolate_dirichlet(g,V)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that it is a function that (by definition) is possibly non-zero near the Dirichlet boundary.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=u_d,refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_diri.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Using the Dirichlet field, we can create function u^mathrmfem only from coefficients that are associated with free DOFs. These are going to be computed later by solving a system of linear equations, but we can create a mock version of them with randomly generated values. We generate a vector of length N^mathrmf because it should contain only \"free\" coefficients.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Random.seed!(2)\nα_f = rand(N_f)\nu_fem = GT.solution_field(u_d,α_f)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"In the following figure, one can see that u^mathrmfem generated in this way has random values in the interior of Omega, while matching the Dirichlet boundary condition on partialOmega.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=u_fem,refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_fem_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#The-weighted-residual-method","page":"Introduction to the FEM","title":"The weighted residual method","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"To solve the problem now, we need to find the coefficients alpha^mathrmf_i associated with the free DOFs. The number of such coefficients is N^mathrmf. Hence, we have N^mathrmf unknowns, which suggests that we needs to consider N^mathrmf equations. These equations will follow from the PDE above.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us introduce the residual of the PDE, namely r(v) = Delta v + f for a given function v. The operator r is such that r(u)=0 for the exact solution of the PDE. The residual provides an estimation of how good a function approximates the solution of the PDE. If r(v) is \"small\", then v is a good approximation of u as long as v also fulfills the Dirichlet boundary condition v=g on partialOmega. Our goal is to find the coefficients alpha^mathrmf_i for which the resulting function u^mathrmfem has a \"small\" residual r(u^mathrmfem). This approach however requires some caution. First, we need to define what \"small\" is. The second problem is that we cannot evaluate r(u^mathrmfem) as this value it is not well defined for all points xinOmega. Function u^mathrmfem is continuous, but its gradient is not continuous at the boundaries of the mesh cells. As a consequence the Laplace operator and the residual r it is not well defined on the cell boundaries.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us visualize one of the components of the gradient of u^mathrmfem to confirm that it is discontinuous. First, let us define the nabla operator.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"∇ = ForwardDiff.gradient\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Then, we visualize the first component of the gradient as follows:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=x->∇(u_fem,x)[1],refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_grad.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"It is indeed discontinuous at the mesh cell boundaries.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"The FEM solves this problem by considering to so-called \"weighted residual method\". First, the method provides a formal definition for what a \"small\" residual is. The method looks for a function u^mathrmfem such that","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"int_Omega r(u^mathrmfem) s^mathrmf_i  dOmega = 0 text for  i=1ldotsN^mathrmf","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"That is, we want the integral of the residual times a free shape function s^mathrmf_i to be zero. Each free shape function provides an equation. Thus, the number of total equations that we build with this expression is N^mathrmf, which coincides with the number of unknowns. Perfect!","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Now, we need to address the second problem: we need to avoid computing Delta u^mathrmfem as this quantity is not well defined for function u^mathrmfem on cell boundaries. Let us expand the integral above, by in-lining the definition of r:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"int_Omega ( (Delta u^mathrmfem) s^mathrmf_i + f s^mathrmf_i ) dOmega = 0","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We can get rid of the Laplace operator by using this identity","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"nablacdot(nabla u^mathrmfem s^mathrmf_i) = (Delta u^mathrmfem) s^mathrmf_i + nabla u^mathrmfem cdot nabla s^mathrmf_i","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"or equivalently","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":" (Delta u^mathrmfem) s^mathrmf_i = nablacdot(nabla u^mathrmfem s^mathrmf_i) - nabla u^mathrmfem cdot nabla s^mathrmf_i","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"This identity is analogous to the well known rule for the derivative of a product, but when the functions are multivariate functions. The quantity nabla v is the gradient of the scalar function v, which is a vector defined as nabla v_k = partial vpartial x_k. The value nablacdot w is the divergence of a vector function w, which is defined as nablacdot w = sum_k^d partial w_kpartial x_k.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Substituting for (Delta u^mathrmfem) s^mathrmf_i in the integral above, we get:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"int_Omega (nablacdot(nabla u^mathrmfem s^mathrmf_i) - nabla u^mathrmfem cdot nabla s^mathrmf_i + f s^mathrmf_i) dOmega = 0","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We still have a second order derivative in the first term inside the integral. We can take rid of this one using the Gauss divergence theorem:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"int_Omega nablacdot(nabla u^mathrmfem s^mathrmf_i)  dOmega = int_partialOmega ncdot(nabla u^mathrmfem s^mathrmf_i) dpartialOmega","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"where n is the unit normal vector on the boundary partialOmega pointing outwards to Omega. Note that the right hand side is an integral on the boundary and we classified the shape functions so that all s^mathrmf_i are zero at the boundary. Using s^mathrmf_i(x)=0 for any xinpartialOmega, we get:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"int_partialOmega ncdot(nabla u^mathrmfem s^mathrmf_i) dpartialOmega = 0","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Using this result and rearranging terms, we get this new formulation of our equations:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":" int_Omega nabla u^mathrmfem cdot nabla s^mathrmf_i  dOmega = int_Omega f s^mathrmf_i  dOmega text for  i=1ldotsN^mathrmf","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that this new formulation does not require computing second order derivatives. Thus, it is well suited for the numerical approximation u^mathrmfem. This equation is called the \"weak form\" of the PDE, since it puts weaker regularity requirements to the numerical approximation u^mathrmfem. In contrast, the original PDE formulation is called the \"strong form\". There are different types of weak forms. Each one is designed for a type of numerical approximation and PDE. This one is for the Poisson equation and continuous approximations with discontinuous gradients. Other weak forms exist for this PDE. For instance, \"discontinuous Galerkin\" methods build the numerical approximation such as it is discontinuous across cell boundaries. One needs to to consider other another weak form for this case, since we cannot even compute the gradient on cell boundaries.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#System-of-linear-algebraic-equations","page":"Introduction to the FEM","title":"System of linear algebraic equations","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us rewrite the weak equation as a(u^mathrmfems^mathrmf_i) = ell(s^mathrmf_i) with","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"a(u^mathrmfems^mathrmf_i) =  int_Omega nabla u^mathrmfem cdot nabla s^mathrmf_i  dOmega","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"ell(s^mathrmf_i)= int_Omega f s^mathrmf_i  dOmega","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"If we substitute","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u^mathrmfem = sum_j=1^N^mathrmfalpha^mathrmf_j s^mathrmf_j +sum_j=1^N^mathrmdalpha^mathrmd_j s^mathrmd_j","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"we get","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"sum_j=1^N^mathrmfa(s^mathrmf_js^mathrmf_i)alpha^mathrmf_j = ell(s^mathrmf_i) - sum_i=1^N^mathrmda(s^mathrmd_js^mathrmf_i)alpha^mathrmd_j text for  i=1ldotsN^mathrmf","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We have used the face that a is linear in each one of its arguments to move it inside the sums. If we look closer, this can be written in matrix form as","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"A^mathrmfalpha^mathrmf = b - A^mathrmdalpha^mathrmd","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"where alpha^mathrmf and alpha^mathrmd are two vectors containing the coefficients alpha^mathrmf_i and alpha^mathrmd_i respectively. Values A^mathrmf and A^mathrmd are matrices, and b is a vector. They are defined as","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"A^mathrmf_ij = a(s^mathrmf_js^mathrmf_i)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"A^mathrmd_ij = a(s^mathrmd_js^mathrmf_i)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"b_i = ell(s^mathrmf_i)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Solving for alpha^mathrmf, we find the unknown coefficients in u^mathrmfem.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"In code, we can build these two matrices and vector using a high-level API. First, we define a measure object that allows us to do the integrals over Omega. This object uses a numerical quadrature internally. So, we need to specify the polynomial degree that we want to integrate exactly. Two times the degree of the interpolation space is a good rule of thumb.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"integration_degree = 2*degree\ndΩ = GT.measure(Ω,integration_degree)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Then, we need to define the field representing function f","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"f = GT.analytical_field(Ω) do x\n    p=3\n    -2*p*(p-1)*sum(x)^(p-2)\nend\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and functions representing a and ell.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"a = (u,v) -> GT.∫(x->∇(u,x)⋅∇(v,x), dΩ)\nℓ = v -> GT.∫(x->f(x)*v(x), dΩ)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Now, we can create the matrix and the vector for free DOFs","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"K_f = GT.assemble_matrix(a,Float64,V,V)\nb = GT.assemble_vector(ℓ,Float64,V)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We can also assembly the matrix for the Dirichlet DOFs using an optional argument. Here, we are asking for \"free\" rows and \"Dirichlet\" columns.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"free_or_dirichlet = (GT.FREE,GT.DIRICHLET)\nK_d = GT.assemble_matrix(a,Float64,V,V;free_or_dirichlet)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that to build the final right-hand-side of the system, we compute b-K^mathrmdalpha^mathrmd and we need the Dirichlet coefficients alpha^mathrmd. They can be taken from the Dirichlet field that we created before.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"α_d = GT.dirichlet_values(u_d)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Now, we have all ingredients to build and solve the algebraic system:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"α_f = K_f\\(b-K_d*α_d)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We can finally create the function u^mathrmfem from the computed coefficients.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u_fem = GT.solution_field(u_d,α_f)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"There is a more compact (and efficient) way of building and solving the system. This one generates matrices K^mathrmf and K^mathrmd in a single loop internally. We create a linear problem object, we solve it, and we extract the solution field from it. This approach automatically handles the Dirichlet boundary conditions.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"p = GT.linear_problem(u_d,a,ℓ)\ns = PS.solve(p)\nu_fem = GT.solution_field(u_d,s)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Finally, we visualize the computed FEM solution.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=u_fem,refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_fem_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Let us also define the manufactured solution u","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"u = GT.analytical_field(Ω) do x\n    sum(x)^3\nend\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"and visualize it","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=u,refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_sol.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"They look very similar. It seems that we solved the PDE correctly (but we still need to conform it mathematically).","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#FE-error","page":"Introduction to the FEM","title":"FE error","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Lets us introduce the error field, i.e., the difference between the exact and numerical solution, e^mathrmfem(x) = u(x)- u^mathrmfem(x).","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"e_fem = x -> u(x) - u_fem(x)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Visualize it.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=e_fem,refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_error.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"Note that the error is not zero! Functions u and u^mathrmfem are not the same, the last one is just an approximation. The result looks promising, but how do we know for sure that this is the expected approximation? This is what we will learn in the next lecture!","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Conclusion","page":"Introduction to the FEM","title":"Conclusion","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"We learned the key ingredients to solve a PDE with the FEM. This requires to define a discrete space, and look for a solution in this space that makes the residual of the PDE \"small\". To properly define what a \"small\" residual is, we used the weighted residual method. This also allowed us to rewrite the PDE into a new form called the weak form. This weak form is needed, because only the residual of the weak form makes sense for functions in the discrete space. We also learned that part of the coefficients of the numerical approximation are unknown. A subset of them can be computed directly by interpolating the Dirichlet boundary condition. We used the method of manufactured solutions to build a PDE with known solution so that we can compare it with the computed approximation.  We also learned how to represent all these concepts using GalerkinToolkit. In the next lecture, we will learn how to confirm that our computed approximation is mathematically correct.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to the FEM","title":"Introduction to the FEM","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"EditURL = \"../src_jl/example_hello_world_manual.jl\"","category":"page"},{"location":"src_md/example_hello_world_manual/#Hello,-World!-(manual-assembly)","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"","category":"section"},{"location":"src_md/example_hello_world_manual/#Problem-statement","page":"Hello, World! (manual assembly)","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"We solve the same problem as in the Hello, World! example, but in this case we explicitly write the numerical integration loops.","category":"page"},{"location":"src_md/example_hello_world_manual/#Implementation","page":"Hello, World! (manual assembly)","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Import other dependencies","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Setup the objects defining this example","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function setup_example(;domain,cells)\n    mesh = GT.cartesian_mesh(domain,cells)\n    dirichlet_tag = \"dirichlet\"\n    GT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\n    Ω = GT.interior(mesh)\n    Γd = GT.boundary(mesh;physical_names=[dirichlet_tag])\n    ∇ = ForwardDiff.gradient\n    Δ(f,x) = tr(ForwardDiff.jacobian(y->∇(f,y),x))\n    g = GT.analytical_field(sum,Ω)\n    f = GT.analytical_field(x->-Δ(g.definition,x),Ω)\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n    T = Float64\n    uhd = GT.zero_dirichlet_field(T,V)\n    GT.interpolate_dirichlet!(g,uhd)\n    degree = 2*k\n    dΩ = GT.measure(Ω,degree)\n    example = (;mesh,Ω,dΩ,V,uhd,f,g)\n    state = (;example)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Create accessor functions for low-level integration quantities.","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function setup_integration_accessors(state)\n    (;dΩ) = state.example\n    face_point_x = GT.coordinate_accessor(dΩ)\n    face_point_J = GT.jacobian_accessor(dΩ)\n    face_point_dV = GT.weight_accessor(dΩ)\n    face_npoints = GT.num_points_accessor(dΩ)\n    integration = (;\n        face_point_x,face_point_J, face_point_dV,face_npoints)\n    (;integration,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Create accessor functions for low-level interpolation quantities.","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function setup_interpolation_accessors(state)\n    (;dΩ,Ω,V,uhd) = state.example\n    face_dofs = GT.dofs_accessor(V,Ω)\n    face_point_dof_s = GT.shape_function_accessor(GT.value,V,dΩ)\n    face_point_dof_∇s = GT.shape_function_accessor(ForwardDiff.gradient,V,dΩ)\n    interpolation = (;\n        face_dofs,face_point_dof_s,face_point_dof_∇s)\n    (;interpolation,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Compute local matrix and vector","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function face_tensors!(Auu,bu,face,state)\n\n    (;example,integration,interpolation) = state\n    (;f) = example\n\n    #Get quantities at current face\n    npoints = integration.face_npoints(face)\n    point_x = integration.face_point_x(face)\n    point_J = integration.face_point_J(face)\n    point_dV = integration.face_point_dV(face)\n    point_dof_s = interpolation.face_point_dof_s(face)\n    point_dof_∇s = interpolation.face_point_dof_∇s(face)\n    dofs = interpolation.face_dofs(face)\n\n    #Reset face matrix and vector\n    fill!(Auu,zero(eltype(Auu)))\n    fill!(bu,zero(eltype(bu)))\n\n    #Loop over integration points\n    for point in 1:npoints\n\n        #Get quantities at current integration point\n        x = point_x(point)\n        J = point_J(point)\n        dV = point_dV(point,J)\n        dof_s = point_dof_s(point)\n        dof_∇s = point_dof_∇s(point,J)\n\n        #Fill in face matrix and vector\n        for (i,dofi) in enumerate(dofs)\n            v = dof_s(i)\n            ∇v = dof_∇s(i)\n            bu[i] += f.definition(x)*v*dV\n            for (j,dofj) in enumerate(dofs)\n                ∇u = dof_∇s(j)\n                Auu[i,j] += ∇v⋅∇u*dV\n            end\n        end\n    end\n\n    #Return dof ids for this face\n    dofs\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Assemble linear problem","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function assemble_problem(state)\n\n    (;example) = state\n    (;V,Ω,f,uhd) = example\n\n    #Allocate auxiliary face matrix and vector\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Allocate space for the global matrix and vector\n    b_alloc = GT.allocate_vector(T,V,Ω)\n    A_alloc = GT.allocate_matrix(T,V,V,Ω)\n    Ad_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet=(GT.FREE,GT.DIRICHLET))\n\n    #Loop over the faces of the domain\n    for face in 1:GT.num_faces(Ω)\n\n        #Compute face tensors\n        dofs = face_tensors!(Auu,bu,face,state)\n\n        #Add face contribution to global allocation\n        GT.contribute!(b_alloc,bu,dofs)\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n        GT.contribute!(Ad_alloc,Auu,dofs,dofs)\n    end\n\n    #Compress matrix and vector into the final format\n    b = GT.compress(b_alloc)\n    A = GT.compress(A_alloc)\n    Ad = GT.compress(Ad_alloc)\n\n    #Allocate space for the solution\n    sol = similar(b,axes(A,2))\n\n    #Apply Dirichlet to RHS\n    xd = GT.dirichlet_values(uhd)\n    mul!(b,Ad,xd,-1,1)\n\n    #Create linear problem object\n    problem = PS.linear_problem(sol,A,b)\n    (;problem,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Solve the solution problem and build the solution field","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function solve_problem(state)\n    (;problem,example) = state\n    (;uhd) = example\n    solver = PS.LinearAlgebra_lu(problem)\n    solver = PS.solve(solver)\n    uh = GT.solution_field(uhd,solver)\n    (;uh,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Setup accessor functions to integrate error norms","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function setup_postpro_accessors(state)\n    (;uh,example) = state\n    (;dΩ) = example\n    #TODO add also h1 norm\n    face_point_uhx = GT.discrete_field_accessor(GT.value,uh,dΩ)\n    postpro = (;face_point_uhx)\n    (;postpro,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Compute the error norms","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function integrate_error_norms(state)\n    (;postpro,example,integration) = state\n    (;Ω,dΩ,g) = example\n    #TODO add also h1 norm\n    T = Float64\n    el2 = zero(T)\n    for face in 1:GT.num_faces(Ω)\n        npoints = integration.face_npoints(face)\n        point_x = integration.face_point_x(face)\n        point_J = integration.face_point_J(face)\n        point_dV = integration.face_point_dV(face)\n        point_uhx = postpro.face_point_uhx(face)\n        for point in 1:npoints\n            x = point_x(point)\n            J = point_J(point)\n            dV = point_dV(point,J)\n            uhx = point_uhx(point,J)\n            el2 += abs2(uhx-g.definition(x))*dV\n        end\n    end\n    el2 = sqrt(el2)\n    norms = (;el2)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/#Final-Program","page":"Hello, World! (manual assembly)","title":"Final Program","text":"","category":"section"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function main(;kwargs...)\n    state1 = setup_example(;kwargs...)\n    state2 = setup_integration_accessors(state1)\n    state3 = setup_interpolation_accessors(state2)\n    state4 = assemble_problem(state3)\n    state5 = solve_problem(state4)\n    state6 = setup_postpro_accessors(state5)\n    norms = integrate_error_norms(state6)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Run it for a 2d case","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"main(domain=(0,1,0,1),cells=(10,10))","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Run it for a 3d case","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"main(domain=(0,1,0,1,0,1),cells=(10,10,10))","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"EditURL = \"../src_jl/example_p_laplacian_manual.jl\"","category":"page"},{"location":"src_md/example_p_laplacian_manual/#p-Laplacian-(manual-assembly)","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"","category":"section"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian_manual/#Problem-statement","page":"p-Laplacian (manual assembly)","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"We solve the same problem as in the p-Laplacian example, but in this case we explicitly write the numerical integration loops.","category":"page"},{"location":"src_md/example_p_laplacian_manual/#Implementation","page":"p-Laplacian (manual assembly)","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Import other dependencies","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Setup the objects defining this example","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function setup_example(;file)\n    assets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\n    msh_file = joinpath(assets_dir,\"model.msh\")\n    mesh = GT.mesh_from_msh(msh_file)\n    dirichlet_0_names = [\"sides\"]\n    dirichlet_1_names = [\"circle\", \"triangle\", \"square\"]\n    Ω = GT.interior(mesh)\n    Γ0 = GT.boundary(mesh;physical_names=dirichlet_0_names)\n    Γ1 = GT.boundary(mesh;physical_names=dirichlet_1_names)\n    Γd = GT.piecewise_domain(Γ0,Γ1)\n    g0 = GT.analytical_field(x->-1.0,Ω)\n    g1 = GT.analytical_field(x->1.0,Ω)\n    g = GT.piecewise_field(g0,g1)\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n    T = Float64\n    uh = GT.rand_field(T,V)\n    GT.interpolate_dirichlet!(g,uh)\n    degree = 2*k\n    dΩ = GT.measure(Ω,degree)\n    example = (;mesh,Ω,dΩ,V,uh,T,g,file)\n    state = (;example)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Create accessor functions for low-level integration quantities.","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function setup_integration_accessors(state)\n    (;dΩ) = state.example\n    face_point_x = GT.coordinate_accessor(dΩ)\n    face_point_J = GT.jacobian_accessor(dΩ)\n    face_point_dV = GT.weight_accessor(dΩ)\n    face_npoints = GT.num_points_accessor(dΩ)\n    integration = (;\n        face_point_x,face_point_J, face_point_dV,face_npoints)\n    (;integration,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Create accessor functions for low-level interpolation quantities.","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function setup_interpolation_accessors(state)\n    (;dΩ,Ω,V,uh) = state.example\n    face_dofs = GT.dofs_accessor(V,Ω)\n    face_point_dof_s = GT.shape_function_accessor(GT.value,V,dΩ)\n    face_point_dof_∇s = GT.shape_function_accessor(ForwardDiff.gradient,V,dΩ)\n    interpolation = (;face_dofs,face_point_dof_s,face_point_dof_∇s)\n    (;interpolation,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Define the algebraic non-linear problem object","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function setup_nonlinear_problem(state)\n\n    (;example) = state\n    (;V,Ω,dΩ,T,uh) = example\n\n    #Get initial guess\n    x = GT.free_values(uh)\n\n    #Create accessor for the field gradient\n    face_point_∇uh = GT.discrete_field_accessor(ForwardDiff.gradient,uh,dΩ)\n\n    #Allocate auxiliary face matrix and vector\n    n = GT.max_num_reference_dofs(V)\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Allocate space for the global matrix and vector\n    b_alloc = GT.allocate_vector(T,V,Ω)\n    A_alloc = GT.allocate_matrix(T,V,V,Ω)\n\n    #Fill in residual and jacobian according to the initial state\n    allocs = (;A_alloc,b_alloc,Auu,bu)\n    fill_residual_and_jacobian!(state,allocs,face_point_∇uh) # Defined later\n\n    #Compress matrix and vector into the final format\n    b,b_cache = GT.compress(b_alloc;reuse=Val(true))\n    A,A_cache = GT.compress(A_alloc;reuse=Val(true))\n\n    #Build the nonlinear problem object\n    workspace = (;state,face_point_∇uh,allocs,b,b_cache,A,A_cache)\n    problem = PS.nonlinear_problem(update_problem,x,b,A,workspace)\n\n    (;problem,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Non-linear problem update function. The input problem is in an inconsistent state: residual(problem) and jacobian(problem) are not synchronized with solution(problem). The goal of this function is to update the residual and jacobian for the current solution guess.","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function update_problem(problem)\n\n    #Unpack workspace\n    (;state,face_point_∇uh,allocs,b,b_cache,A,A_cache) = PS.workspace(problem)\n    (;A_alloc,b_alloc,Auu,bu) = allocs\n    (;example) = state\n    (;uh) = example\n\n    #Get the current solution vector\n    x = PS.solution(problem)\n\n    #Build the current solution field\n    uh = GT.solution_field(uh,x)\n\n    #Update the accessor\n    face_point_∇uh = GT.update(face_point_∇uh,discrete_field=uh)\n\n    #Fill in residual and Jacobian\n    fill_residual_and_jacobian!(state,allocs,face_point_∇uh)\n\n    #In-place compression of matrix and vector\n    GT.compress!(b_alloc,b,b_cache)\n    GT.compress!(A_alloc,A,A_cache)\n\n    #Update the nonlinear problem object\n    #Here, we computed the residual and Jacobian simultaneously,\n    #but this API also allows to compute them separately.\n    if PS.residual(problem) !== nothing\n        problem = PS.update(problem,residual=b)\n    end\n    if PS.jacobian(problem) !== nothing\n        problem = PS.update(problem,jacobian=A)\n    end\n\n    problem\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Assembly loop","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function fill_residual_and_jacobian!(state,allocs,face_point_∇uh)\n    (;A_alloc,b_alloc,Auu,bu) = allocs\n    (;example) = state\n    (;Ω,) = example\n\n    #Reset allocations\n    GT.reset!(b_alloc)\n    GT.reset!(A_alloc)\n\n    #Loop over the faces of the domain\n    for face in 1:GT.num_faces(Ω)\n\n        #Compute face tensors\n        dofs = face_tensors!(Auu,bu,face,state,face_point_∇uh) # Defined later\n\n        #Add face contribution to global allocation\n        GT.contribute!(b_alloc,bu,dofs)\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n    end\n\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Compute local Jacobian and residual","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function face_tensors!(Auu,bu,face,state,face_point_∇uh)\n\n    (;example,integration,interpolation) = state\n\n    #Define flux and its derivative\n    q = 3\n    flux(∇u) = norm(∇u)^(q-2) * ∇u\n    dflux(∇du,∇u) = (q-2)*norm(∇u)^(q-4)*(∇u⋅∇du)*∇u+norm(∇u)^(q-2)*∇du\n\n    #Get quantities at current face\n    npoints = integration.face_npoints(face)\n    point_J = integration.face_point_J(face)\n    point_dV = integration.face_point_dV(face)\n    point_dof_∇s = interpolation.face_point_dof_∇s(face)\n    point_∇uh = face_point_∇uh(face)\n    dofs = interpolation.face_dofs(face)\n\n    #Reset face matrix and vector\n    fill!(Auu,zero(eltype(Auu)))\n    fill!(bu,zero(eltype(bu)))\n\n    #Loop over integration points\n    for point in 1:npoints\n\n        #Get quantities at current integration point\n        J = point_J(point)\n        dV = point_dV(point,J)\n        dof_∇s = point_dof_∇s(point,J)\n        ∇uh = point_∇uh(point,J)\n\n        #Fill in face matrix and vector\n        for (i,dofi) in enumerate(dofs)\n            ∇v = dof_∇s(i)\n            bu[i] += flux(∇uh)⋅∇v*dV\n            for (j,dofj) in enumerate(dofs)\n                ∇du = dof_∇s(j)\n                Auu[i,j] += dflux(∇du,∇uh)⋅∇v*dV\n            end\n        end\n    end\n\n    #Return dof ids for this face\n    dofs\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Solve and visualize results","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function solve_and_visualize(state)\n    (;problem,example) = state\n    (;uh,file,Ω) = example\n\n    #Setup solver\n    solver = PS.newton_raphson(problem,verbose=true)\n\n    #Get the lazy solver history\n    solver_history = PS.history(solver)\n\n    #Visualize\n    color = Makie.Observable(uh)\n    fig = Makie.plot(Ω;color,strokecolor=:black)\n    fn = joinpath(@__DIR__,\"fig_pt_plaplacian.gif\")\n    Makie.record(fig,file,solver_history;framerate=2) do s\n        color[] = uh\n    end\nend","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Final program.","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function main(;kwargs...)\n    state1 = setup_example(;kwargs...)\n    state2 = setup_integration_accessors(state1)\n    state3 = setup_interpolation_accessors(state2)\n    state4 = setup_nonlinear_problem(state3)\n    solve_and_visualize(state4)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Run it for a 2d case","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"file = joinpath(@__DIR__,\"p_laplacian_manual.gif\")\nmain(;file)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#API","page":"API","title":"API","text":"","category":"section"},{"location":"reference/","page":"API","title":"API","text":"Modules = [GalerkinToolkit]","category":"page"},{"location":"reference/#GalerkinToolkit.AbstractDomain","page":"API","title":"GalerkinToolkit.AbstractDomain","text":"abstract type AbstractDomain{A} <: AbstractType end\n\nAbstract type representing a subset of mathbbR^d, typically din0123. Domains are defined using an underlying computational mesh. A is an (abstract) type indicating on which type of mesh this domain is defined.\n\nSee also AbstractMesh.\n\nLevel\n\nBeginner\n\nBasic constructors\n\nunit_simplex\nunit_n_cube\ndomain\ninterior\nboundary\nskeleton\n\nBasic queries\n\nnum_dims\nnum_ambient_dims\nnum_codims\nis_axis_aligned\nis_simplex\nis_n_cube\nis_unit_n_cube\nis_unit_simplex\nis_unitary\nbounding_box\nvertex_permutations\nmesh\nfaces\ninverse_faces\noptions\nis_boundary\nface_around\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceDomain","page":"API","title":"GalerkinToolkit.AbstractFaceDomain","text":"abstract type AbstractFaceDomain <: AbstractDomain{AbstractMesh} end\n\nA domain defined on a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\nBasic constructors\n\nunit_simplex\nunit_n_cube\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceSpace","page":"API","title":"GalerkinToolkit.AbstractFaceSpace","text":"abstract type AbstractFaceSpace <: AbstractSpace{AbstractMesh} end\n\nLike AbstractSpace, but for a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceTopology","page":"API","title":"GalerkinToolkit.AbstractFaceTopology","text":"abstract type AbstractFaceTopology <: AbstractTopology end\n\nLike AbstractTopology, but for a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractMesh","page":"API","title":"GalerkinToolkit.AbstractMesh","text":"abstract type AbstractMesh <: AbstractType end\n\nAbstract type representing a triangulation of a subset of mathbbR^d, typically din0123, plus metadata useful in finite element computations, such as physical groups for imposing boundary conditions.\n\nNotation\n\nEach of of the elements of the triangulation is referred to as a face. A mesh can contain faces of different dimensions. A mesh might or might not represent a cell complex (all possible low dimensional faces are present in the mesh), but it is often assumed that it represents a cell complex.\n\nLevel\n\nBeginner\n\nBasic constructors\n\nmesh\nchain\nmesh_from_msh\nmesh_from_space\ncartesian_mesh\ncomplexify\nsimplexify\n\nBasic queries\n\nnum_dims\nnum_ambient_dims\nnum_codims\nnum_faces\nnum_nodes\nnode_coordinates\nface_nodes\nface_reference_id\nreference_spaces\nperiodic_nodes\nphysical_faces\ngeometries\noutward_normals\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractPMesh","page":"API","title":"GalerkinToolkit.AbstractPMesh","text":"\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractQuadrature","page":"API","title":"GalerkinToolkit.AbstractQuadrature","text":"abstract type AbstractQuadrature\n\nBasic queries\n\ndomain\ncoordinates\nweights\nnum_points\nface_reference_id\nreference_quadratures\n\nBasic constructors\n\nquadrature\nduffy_quadrature\ntensor_product_quadrature\nnode_quadrature\n\nSupertype hierarchy\n\nAbstractQuadrature <: GT.AbstractType\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractSpace","page":"API","title":"GalerkinToolkit.AbstractSpace","text":"abstract type AbstractSpace{A} <: AbstractType end\n\nAbstract type representing a finite element space.  A is an (abstract) type  indicating on which type of mesh this domain is defined.\n\nLevel\n\nBasic\n\nBasic constructors\n\nlagrange_space raviart_thomas_space\n\nBasic queries\n\ndomain\nnum_dofs\nface_dofs\nface_nodes\nface_reference_id\nreference_spaces\ngeometry_own_dofs\ngeometry_own_dofs_permutations\n\nAdditional queries\n\nFor spaces, used as reference spaces in AbstractMesh specializations.\n\nnum_nodes\ninterior_nodes\ninterior_nodes_permutations\ngeometry_interior_nodes\ngeometry_interior_nodes_permutations\ngeometry_nodes\ngeometry_nodes_permutations\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractTopology","page":"API","title":"GalerkinToolkit.AbstractTopology","text":"abstract type AbstractTopology\n\nAbstract type representing the incidence relations in a cell complex.\n\nSee also AbstractFaceTopology.\n\nLevel\n\nIntermediate\n\nBasic constructors\n\ntopology\n\nBasic queries\n\nface_incidence\nface_reference_id\nface_permutation_ids\nreference_topologies\nvertex_permutations\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractType","page":"API","title":"GalerkinToolkit.AbstractType","text":"abstract type AbstractType end\n\nParent of all types defined in GalerkinToolkit.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.Options","page":"API","title":"GalerkinToolkit.Options","text":"struct Options{...} <: AbstractType\n\nType of the objects returned by function options. All properties and type parameters are private.\n\nBasic queries\n\nreference_int_type\nint_type\nglobal_int_type\nreal_type\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.boundary","page":"API","title":"GalerkinToolkit.boundary","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.bounding_box","page":"API","title":"GalerkinToolkit.bounding_box","text":"p0,p1 = bounding_box(x)\n\nReturn a tuple of two vectors, where the vectors p0 and p1 define the span of the bounding box of x.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.cartesian_mesh-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.cartesian_mesh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.chain-Tuple{}","page":"API","title":"GalerkinToolkit.chain","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.complexify","page":"API","title":"GalerkinToolkit.complexify","text":"complexify(x)\n\nConvert x into a mesh representing a cell complex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.coordinates","page":"API","title":"GalerkinToolkit.coordinates","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.domain","page":"API","title":"GalerkinToolkit.domain","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.duffy_quadrature-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.duffy_quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.face_around","page":"API","title":"GalerkinToolkit.face_around","text":"face_around(x)\n\nReturn an integer that allows to break ties when faces in x need to point to faces around of one dimension higher. Return nothing if x does not break such ties.\n\nNote: This function will eventually return a vector of integers.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_dofs","page":"API","title":"GalerkinToolkit.face_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_incidence","page":"API","title":"GalerkinToolkit.face_incidence","text":"face_incidence(x,d)\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_nodes","page":"API","title":"GalerkinToolkit.face_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_permutation_ids","page":"API","title":"GalerkinToolkit.face_permutation_ids","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_reference_id","page":"API","title":"GalerkinToolkit.face_reference_id","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.faces","page":"API","title":"GalerkinToolkit.faces","text":"faces(x)\n\nReturn the subset of face ids in mesh(x) of dimension num_dims(x) defining the domain x. This is effectively the map from domain face id to mesh face id.\n\nSee also inverse_faces.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometries","page":"API","title":"GalerkinToolkit.geometries","text":"geometries(x,d)\ngeometries(x,Val(d))\n\nReturn a vector of domains representing the geometrical entities of x of dimension d. The returned domains and x are defined on the same mesh. That is, faces(geometries(x,1)[2]) are the face ids in mesh(x) representing the second edge of x.\n\nNotation\n\ngeometries(x,Val(0)) are referred to as the vertices of x. geometries(x,Val(1)) are referred to as the edges of x. geometries(x,Val(d)) are referred to as the d-faces of x.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_interior_nodes","page":"API","title":"GalerkinToolkit.geometry_interior_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_interior_nodes_permutations","page":"API","title":"GalerkinToolkit.geometry_interior_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_nodes","page":"API","title":"GalerkinToolkit.geometry_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_nodes_permutations","page":"API","title":"GalerkinToolkit.geometry_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_own_dofs","page":"API","title":"GalerkinToolkit.geometry_own_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_own_dofs_permutations","page":"API","title":"GalerkinToolkit.geometry_own_dofs_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.global_int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.global_int_type","text":"global_int_type(options::Options)\n\nReturn the type of the integers used to enumerate global quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.int_type","text":"int_type(options::Options)\n\nReturn the default integer type used in the computation except for reference and global quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.interior","page":"API","title":"GalerkinToolkit.interior","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.interior_node_permutations-Tuple{GalerkinToolkit.LagrangeFaceSpace}","page":"API","title":"GalerkinToolkit.interior_node_permutations","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.interior_nodes","page":"API","title":"GalerkinToolkit.interior_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.interior_nodes_permutations","page":"API","title":"GalerkinToolkit.interior_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.inverse_faces","page":"API","title":"GalerkinToolkit.inverse_faces","text":"inverse_faces(x)\n\nReturn the inverse integer mas of faces(x). This is effectively the map from mesh face id to domain face id. Mesh faces not present in the domain, receive an invalid index id.\n\nSee also faces.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_axis_aligned","page":"API","title":"GalerkinToolkit.is_axis_aligned","text":"is_axis_aligned(x)\n\nTrue if x is a unit simplex or a unit cube.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_boundary","page":"API","title":"GalerkinToolkit.is_boundary","text":"is_boundary(x)\n\nTrue if x represent an (internal) boundary. Faces in an internal boundary \"point\" to only of the two faces around of a dimension higher.\n\nSee also face_around.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_n_cube","page":"API","title":"GalerkinToolkit.is_n_cube","text":"is_n_cube(x)\n\nTrue if x is a n-cube (hypercube).\n\nSee also is_simplex, is_unit_simplex, is_unit_n_cube.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_simplex","page":"API","title":"GalerkinToolkit.is_simplex","text":"is_simplex(x)\n\nTrue if x is a simplex.\n\nSee also is_n_cube, is_unit_simplex, is_unit_n_cube.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unit_n_cube","page":"API","title":"GalerkinToolkit.is_unit_n_cube","text":"is_unit_n_cube(x)\n\nTrue if x is a unit n-cube.\n\nSee also is_n_cube, is_unit_simplex, is_simplex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unit_simplex","page":"API","title":"GalerkinToolkit.is_unit_simplex","text":"is_unit_simplex(x)\n\nTrue if x is a unit simplex.\n\nSee also is_n_cube, is_unit_n_cube, is_simplex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unitary","page":"API","title":"GalerkinToolkit.is_unitary","text":"is_unitary(x)\n\nTrue bounding_box(x) coincides with a unit n-cube.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.lagrange_space","page":"API","title":"GalerkinToolkit.lagrange_space","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.mesh-Tuple{GalerkinToolkit.Chain}","page":"API","title":"GalerkinToolkit.mesh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_msh-Tuple{Any}","page":"API","title":"GalerkinToolkit.mesh_from_msh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_space","page":"API","title":"GalerkinToolkit.mesh_from_space","text":"mesh_from_space(space)\n\nReturn the mesh induced by space. For instance, a (high order) Lagrange space can be interpreted as a mesh using this function.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.node_coordinates","page":"API","title":"GalerkinToolkit.node_coordinates","text":"node_coordinates(x)\n\nReturn the vector of node coordinates associated with `x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.node_permutations-Tuple{GalerkinToolkit.LagrangeFaceSpace}","page":"API","title":"GalerkinToolkit.node_permutations","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.node_quadrature","page":"API","title":"GalerkinToolkit.node_quadrature","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_ambient_dims","page":"API","title":"GalerkinToolkit.num_ambient_dims","text":"num_ambient_dims(x)\n\nReturn the ambient dimension where object x lives.\n\nSee also num_codims, num_dims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_codims","page":"API","title":"GalerkinToolkit.num_codims","text":"num_codims(x)\n\nReturn num_ambient_dims(x)-num_dims(x).\n\nSee also num_ambient_dims, num_dims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_dims","page":"API","title":"GalerkinToolkit.num_dims","text":"num_dims(x)\n\nReturn the parametric dimension of x.\n\nSee also num_ambient_dims, num_codims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_dofs","page":"API","title":"GalerkinToolkit.num_dofs","text":"num_dofs(x)\n\nReturn the number of degrees of freedom of x.\n\nSee also num_nodes.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_faces","page":"API","title":"GalerkinToolkit.num_faces","text":"num_faces(x)\nnum_faces(x,d)\n\nReturn the number of faces  of dimension d in mesh(x). If d is omitted, return a vector with the number of faces in each dimension, starting from dimension 0 up to num_dims(x).\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_nodes","page":"API","title":"GalerkinToolkit.num_nodes","text":"num_nodes(x)\n\nReturn the number of nodes of x.\n\nSee also num_dofs.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_points","page":"API","title":"GalerkinToolkit.num_points","text":"num_points(x)\n\nReturn the number of integration points in x.\n\nSee also num_nodes.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.options-Tuple{}","page":"API","title":"GalerkinToolkit.options","text":"options(;kwargs...) -> Options\n\nCreate an object representing the default options for the current simulation. This object can be used as an optional argument in several object constructors in GalerkinToolkit, such as the mesh constructors cartesian_mesh and mesh_from_msh. In this case, the computations using the generated mesh, will use the given options by default.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.outward_normals","page":"API","title":"GalerkinToolkit.outward_normals","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.periodic_nodes","page":"API","title":"GalerkinToolkit.periodic_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.physical_faces","page":"API","title":"GalerkinToolkit.physical_faces","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.physical_names-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.physical_names","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.push","page":"API","title":"GalerkinToolkit.push","text":"push(a,ai)\n\nLike push!, but creates a new object to store the result.  This function is used to push to immutable collections such as tuples.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.quadrature-Tuple{GalerkinToolkit.AbstractFaceDomain, Any}","page":"API","title":"GalerkinToolkit.quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.raviart_thomas_space","page":"API","title":"GalerkinToolkit.raviart_thomas_space","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.real_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.real_type","text":"real_type(options::Options)\n\nReturn the default real type used in the computation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.reference_int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.reference_int_type","text":"reference_int_type(options::Options)\n\nReturn the type of the integers used to enumerate reference quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.reference_quadratures","page":"API","title":"GalerkinToolkit.reference_quadratures","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_spaces","page":"API","title":"GalerkinToolkit.reference_spaces","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_topologies","page":"API","title":"GalerkinToolkit.reference_topologies","text":"reference_topologies(x)\nreference_topologies(x,d)\nreference_topologies(x,Val(d))\n\nReturn the list (a vector or a tuple) of reference topologies in x of dimension d. If the second argument is omitted, return a tuple with the reference topologies in each dimension, starting from dimension 0 up to num_dims(x).\n\nSee also face_reference_id.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.shape_functions-Tuple{GalerkinToolkit.AbstractSpace}","page":"API","title":"GalerkinToolkit.shape_functions","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.simplexify","page":"API","title":"GalerkinToolkit.simplexify","text":"simplexify(x)\n\nConvert x into a mesh made of simplex cells.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.skeleton","page":"API","title":"GalerkinToolkit.skeleton","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.tabulator-Tuple{GalerkinToolkit.AbstractSpace}","page":"API","title":"GalerkinToolkit.tabulator","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.tensor_product_quadrature-Tuple{GalerkinToolkit.AbstractFaceDomain, Any}","page":"API","title":"GalerkinToolkit.tensor_product_quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.topology-Tuple{GalerkinToolkit.AbstractMesh}","page":"API","title":"GalerkinToolkit.topology","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.unit_n_cube-Tuple{Any}","page":"API","title":"GalerkinToolkit.unit_n_cube","text":"unit_n_cube(d)\nunit_n_cube(Val(d))\n\nReturn an object representing a unit d-cube.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.unit_simplex-Tuple{Any}","page":"API","title":"GalerkinToolkit.unit_simplex","text":"unit_simplex(d)\nunit_simplex(Val(d))\n\nReturn an object representing a unit simplex of dimension d.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.val_parameter-Tuple{Any}","page":"API","title":"GalerkinToolkit.val_parameter","text":"val_parameter(a)\n\nFor a::Val{A} it returns A. Otherwise, it returns a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.vertex_permutations","page":"API","title":"GalerkinToolkit.vertex_permutations","text":"vertex_permutations(x)\n\nReturn a list of permutations representing the admissible re-labelings of the vertices of x.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.weights","page":"API","title":"GalerkinToolkit.weights","text":"\n\n\n\n","category":"function"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"EditURL = \"../src_jl/example_transient_heat_eq_manual.jl\"","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/#Transient-heat-equation-(manual-assembly)","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"","category":"section"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"(Image: )","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/#Implementation","page":"Transient heat equation (manual assembly)","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Import other dependencies","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport WriteVTK\nimport FileIO # hide","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Main program. The individual functions are defined later.","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function main(;mesh_size=0.02,R=0.15,T=2,N=100)\n    params = (;mesh_size,R,T,N)\n    state0 = setup_mesh(params)\n    state1 = setup_example(state0)\n    state2 = setup_accessors(state1)\n    state3 = assemble_matrices(state2)\n    state4 = setup_time_steps(state3)\n    time_steps_makie(state4)\n    time_steps_vtk(state4)\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Setup the mesh with GMSH","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function setup_mesh(state)\n    (;mesh_size,R) = state\n    mesh = GT.with_gmsh() do gmsh\n        R = 0.15\n        dim = 2\n        rect_tag = gmsh.model.occ.add_rectangle(0,0,0,1,1)\n        circle_tag = gmsh.model.occ.add_circle(0.5,0.5,0,R)\n        circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])\n        circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])\n        gmsh.model.occ.cut([(dim,rect_tag)],[(dim,circle_surf_tag)]);\n        gmsh.model.occ.synchronize()\n        domain_tags = [1]\n        outer_tags = [6,7,8,9]\n        inner_tags = [5]\n        gmsh.model.model.add_physical_group(dim,domain_tags,-1,\"domain\")\n        gmsh.model.model.add_physical_group(dim-1,outer_tags,-1,\"outer\")\n        gmsh.model.model.add_physical_group(dim-1,inner_tags,-1,\"inner\")\n        gmsh.option.setNumber(\"Mesh.MeshSizeMax\",mesh_size)\n        gmsh.model.mesh.generate(dim)\n        GT.mesh_from_gmsh(gmsh)\n    end\n    (;mesh,state...)\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Setup the quantities for this example","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function setup_example(state)\n    (;mesh) = state\n    #Domains\n    Ω = GT.interior(mesh;physical_names=[\"domain\"])\n    Γ1 = GT.boundary(mesh;physical_names=[\"outer\"])\n    Γ2 = GT.boundary(mesh;physical_names=[\"inner\"])\n    Γ = GT.piecewise_domain(Γ1,Γ2)\n    #Space\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γ)\n    #Field\n    uh = GT.undef_field(Float64,V)\n    #Time dependent Dirichlet function\n    function dirichlet_dynamics!(t,uht)\n        α = sin(3*pi*t)\n        g1 = GT.analytical_field(x->0.0,Ω)\n        g2 = GT.analytical_field(x->1.0*α,Ω)\n        g = GT.piecewise_field(g1,g2)\n        GT.interpolate_dirichlet!(g,uht)\n    end\n    #Initial condition\n    u0 = GT.analytical_field(x->0.0,Ω)\n    (;Ω,V,uh,u0,dirichlet_dynamics!,state...)\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Create the accessor functions used later for integration","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function setup_accessors(state)\n    (;Ω,V) = state\n    degree = 2*GT.order(V)\n    dΩ = GT.measure(Ω,degree)\n    face_point_x = GT.coordinate_accessor(dΩ)\n    face_point_J = GT.jacobian_accessor(dΩ)\n    face_point_dV = GT.weight_accessor(dΩ)\n    face_npoints = GT.num_points_accessor(dΩ)\n    face_dofs = GT.dofs_accessor(V,Ω)\n    face_point_dof_s = GT.shape_function_accessor(GT.value,V,dΩ)\n    face_point_dof_∇s = GT.shape_function_accessor(ForwardDiff.gradient,V,dΩ)\n    accessors = (;face_point_x,face_point_J,face_point_dV,\n                 face_npoints,face_dofs,face_point_dof_s,face_point_dof_∇s)\n    (;accessors,state...)\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Assemble the problem matrices","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function assemble_matrices(state)\n    (;V,Ω,accessors) = state\n\n    #Allocate auxiliary face matrix and vector\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Ke = zeros(T,n,n)\n    Me = zeros(T,n,n)\n\n    #Allocate space for the global matrices\n    ff = (GT.FREE,GT.FREE)\n    fd = (GT.FREE,GT.DIRICHLET)\n    K_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet=ff)\n    M_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet=ff)\n    Kfd_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet=fd)\n    Mfd_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet=fd)\n\n    allocs = (;K_alloc,M_alloc,Kfd_alloc,Mfd_alloc,Ke,Me)\n\n    #Assembly loop (defined later)\n    assembly_loop!(state,allocs)\n\n    #Compress matrices\n    K = GT.compress(K_alloc)\n    Kfd = GT.compress(Kfd_alloc)\n    M = GT.compress(M_alloc)\n    Mfd = GT.compress(Mfd_alloc)\n\n    (;K,M,Kfd,Mfd,state...)\n\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Manual assembly loop","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function assembly_loop!(state,allocs)\n    (;Ω,accessors) = state\n    (;K_alloc,M_alloc,Kfd_alloc,Mfd_alloc,Ke,Me) = allocs\n\n    #Reset allocations\n    GT.reset!(K_alloc)\n    GT.reset!(Kfd_alloc)\n    GT.reset!(M_alloc)\n    GT.reset!(Mfd_alloc)\n\n    C = 10\n\n    #Loop over the faces of the domain\n    for face in 1:GT.num_faces(Ω)\n\n        #Reset element matrices\n        fill!(Ke,zero(eltype(Ke)))\n        fill!(Me,zero(eltype(Me)))\n\n        #Get quantities at current face\n        npoints = accessors.face_npoints(face)\n        point_x = accessors.face_point_x(face)\n        point_J = accessors.face_point_J(face)\n        point_dV = accessors.face_point_dV(face)\n        point_dof_s = accessors.face_point_dof_s(face)\n        point_dof_∇s = accessors.face_point_dof_∇s(face)\n        dofs = accessors.face_dofs(face)\n\n        #Loop over integration points\n        for point in 1:npoints\n\n            #Get quantities at current integration point\n            x = point_x(point)\n            J = point_J(point)\n            dV = point_dV(point,J)\n            dof_s = point_dof_s(point)\n            dof_∇s = point_dof_∇s(point,J)\n\n            #Fill in face matrix and vector\n            for (i,dofi) in enumerate(dofs)\n                v = dof_s(i)\n                ∇v = dof_∇s(i)\n                for (j,dofj) in enumerate(dofs)\n                    u = dof_s(j)\n                    ∇u = dof_∇s(j)\n                    Ke[i,j] += ∇v⋅∇u*dV\n                    Me[i,j] += C*v*u*dV\n                end\n            end\n        end\n\n        #Add face contribution to global allocations\n        GT.contribute!(K_alloc,Ke,dofs,dofs)\n        GT.contribute!(Kfd_alloc,Ke,dofs,dofs)\n        GT.contribute!(M_alloc,Me,dofs,dofs)\n        GT.contribute!(Mfd_alloc,Me,dofs,dofs)\n    end\n\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Perform operations that are shared between time steps.","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function setup_time_steps(state)\n    (;T,N,Ω,uh,K,M,Kfd,Mfd) = state\n    #Generate linear problem\n    dt = T/N\n    t = 0\n    A = M + dt * K\n    x = GT.free_values(uh)\n    b = similar(x)\n    p = PS.linear_problem(x,A,b)\n    #Generate solver object.\n    #This factorizes the matrix\n    s = PS.LinearAlgebra_lu(p)\n    (;s,p,b,dt,state...)\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Do the time steps and record the solution with Makie.","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function time_steps_makie(state)\n    (;Ω,uh,u0,s,p,b,N,dt,M,Mfd,Kfd,dirichlet_dynamics!) = state\n\n    #Initial condition\n    t0 = 0\n    GT.interpolate_free!(u0,uh)\n    dirichlet_dynamics!(t0,uh)\n    x = GT.free_values(uh)\n    xd = GT.dirichlet_values(uh)\n\n    #Setup Makie scene\n    axis = (aspect = Makie.DataAspect(),)\n    color = Makie.Observable(uh)\n    fig = Makie.Figure()\n    ax,sc = Makie.plot(fig[1,1],Ω;color,axis,colorrange=(-1,1))\n    Makie.Colorbar(fig[1,2],sc)\n\n    #Record Makie scene\n    fn = \"fig_transient_heat_equation_manual.gif\"\n    file = joinpath(@__DIR__,fn)\n    Makie.record(fig,file,1:N) do step\n        #Compute current time\n        t = dt*step + t0\n        #Setup rhs\n        mul!(b,M,x)\n        mul!(b,Mfd,xd,1,1)\n        dirichlet_dynamics!(t,uh)\n        xd = GT.dirichlet_values(uh)\n        mul!(b,Mfd,xd,-1,1)\n        mul!(b,Kfd,xd,-dt,1)\n        #Update solver with the new rhs and solve\n        #This is only a solver substitution,\n        #not a full factorization\n        s = PS.update(s,rhs=b)\n        s = PS.solve(s)\n        #Get solution at the end of the step\n        x = PS.solution(s)\n        #Update Makie scene\n        color[] = GT.solution_field(uh,x)\n    end\n\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Do the time steps and record the solution with VTK.","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function time_steps_vtk(state)\n    (;Ω,uh,u0,s,p,b,N,dt,M,Mfd,Kfd,dirichlet_dynamics!) = state\n\n    #Initial condition\n    t0 = 0\n    dirichlet_dynamics!(t0,uh)\n    GT.interpolate_free!(u0,uh)\n    x = GT.free_values(uh)\n    xd = GT.dirichlet_values(uh)\n\n    #Create the GT plot object\n    plt = GT.plot(Ω)\n\n    #Save Paraview collection\n    fn = \"vtk_transient_heat_equation_manual\"\n    file = joinpath(@__DIR__,fn)\n    WriteVTK.paraview_collection(file,plt) do pvd\n        for step in 1:N\n            t = dt*step + t0\n            mul!(b,M,x)\n            mul!(b,Mfd,xd,1,1)\n            dirichlet_dynamics!(t,uh)\n            xd = GT.dirichlet_values(uh)\n            mul!(b,Mfd,xd,-1,1)\n            mul!(b,Kfd,xd,-dt,1)\n            s = PS.update(s,rhs=b)\n            s = PS.solve(s)\n            x = PS.solution(s)\n            uh = GT.solution_field(uh,x)\n            #Save vtk file for this step\n            WriteVTK.vtk_grid(\"$(file)_$(step)\",plt) do plt\n                GT.plot!(plt,uh;label=\"uh\")\n                pvd[step] = plt\n            end\n        end\n    end\n\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Call the main function","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"main()","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"(Image: )","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"refindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"refindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"EditURL = \"../src_jl/example_transient_heat_eq.jl\"","category":"page"},{"location":"src_md/example_transient_heat_eq/#Transient-heat-equation-with-DifferentialEquations.jl","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"","category":"section"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"src_md/example_transient_heat_eq/#Implementation","page":"Transient heat equation with DifferentialEquations.jl","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"Import other dependencies","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"import GalerkinToolkit as GT\nimport DifferentialEquations\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"Main program.","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"function main(;mesh_size=0.02,R=0.15,T=2,N=100)\n\n    #Generate mesh\n    mesh = GT.with_gmsh() do gmsh\n        R = 0.15\n        dim = 2\n        rect_tag = gmsh.model.occ.add_rectangle(0,0,0,1,1)\n        circle_tag = gmsh.model.occ.add_circle(0.5,0.5,0,R)\n        circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])\n        circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])\n        gmsh.model.occ.cut([(dim,rect_tag)],[(dim,circle_surf_tag)]);\n        gmsh.model.occ.synchronize()\n        domain_tags = [1]\n        outer_tags = [6,7,8,9]\n        inner_tags = [5]\n        gmsh.model.model.add_physical_group(dim,domain_tags,-1,\"domain\")\n        gmsh.model.model.add_physical_group(dim-1,outer_tags,-1,\"outer\")\n        gmsh.model.model.add_physical_group(dim-1,inner_tags,-1,\"inner\")\n        gmsh.option.setNumber(\"Mesh.MeshSizeMax\",mesh_size)\n        gmsh.model.mesh.generate(dim)\n        GT.mesh_from_gmsh(gmsh)\n    end\n\n    #Domains\n    Ω = GT.interior(mesh;physical_names=[\"domain\"])\n    Γ1 = GT.boundary(mesh;physical_names=[\"outer\"])\n    Γ2 = GT.boundary(mesh;physical_names=[\"inner\"])\n    Γ = GT.piecewise_domain(Γ1,Γ2)\n\n    #Interpolation\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γ)\n    uh = GT.undef_field(Float64,V)\n\n    #Integration\n    degree = 2*GT.order(V)\n    dΩ = GT.measure(Ω,degree)\n\n    #Initial condition\n    u0 = GT.analytical_field(x->0.0,Ω)\n    GT.interpolate_free!(u0,uh)\n\n    #Time-dependent Dirichlet function\n    α = t -> sin(3*pi*t)\n    function dirichlet_dynamics!(t,uh,duh=nothing)\n        g1 = GT.analytical_field(x->0.0,Ω)\n        if uh !== nothing\n            g2 = GT.analytical_field(x->α(t),Ω)\n            g = GT.piecewise_field(g1,g2)\n            GT.interpolate_dirichlet!(g,uh)\n        end\n        if duh !== nothing\n            g2 = GT.analytical_field(x->ForwardDiff.derivative(α,t),Ω)\n            g = GT.piecewise_field(g1,g2)\n            GT.interpolate_dirichlet!(g,duh)\n        end\n    end\n\n    #Definition of the ODE problem\n    C = 10\n    ∇ = (u,q) -> ForwardDiff.gradient(u,q)\n    m = (u,v) -> GT.∫(x->C*v(x)*u(x),dΩ)\n    a = (u,v) -> -1*GT.∫(x->∇(u,x)⋅∇(v,x), dΩ)\n    r = (uh,t) -> v -> a(uh,v)\n    j = (uh,t) -> a\n    tspan = (0.0,T)\n    problem = GT.SciMLBase_ODEProblem(tspan,uh,m,r,j;dirichlet_dynamics!)\n\n    #Selection and setup of the ODE solver\n    dt = T/N\n    solver = DifferentialEquations.Rodas5P(autodiff=false);\n    integrator = DifferentialEquations.init(problem,solver;\n        initializealg=DifferentialEquations.NoInit(),dt,adaptive=false)\n\n    #Setup Makie scene\n    axis = (aspect = Makie.DataAspect(),)\n    color = Makie.Observable(uh)\n    fig = Makie.Figure()\n    ax,sc = Makie.plot(fig[1,1],Ω;color,axis,colorrange=(-1,1))\n    Makie.Colorbar(fig[1,2],sc)\n\n    #Record Makie scene while solving\n    fn = \"fig_transient_heat_equation.gif\"\n    file = joinpath(@__DIR__,fn)\n    Makie.record(fig,file,DifferentialEquations.intervals(integrator)) do interval\n        x,t = interval\n        dirichlet_dynamics!(t,uh)\n        color[] = GT.solution_field(uh,x)\n    end\n\nend","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"Call the main function.","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"main()","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"","category":"page"},{"location":"src_md/example_transient_heat_eq/","page":"Transient heat equation with DifferentialEquations.jl","title":"Transient heat equation with DifferentialEquations.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GalerkinToolkit","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation page of GalerkinToolkit!","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nGalerking is already useful in many situations, but keep it mind that it is under active development. This documentation page is under construction.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Home – This page.\nLectures – Learning material to get familiar with the basics of the FEM. They are useful even if you are FEM expert as they walk you through the library step by step.\nExamples – They provide a quick overview of the main functionality of the library.\nManual – The user and developer guide. It gives the detailed explanations on how to use and extend the library.\nAPI – All the docstrings are there.","category":"page"},{"location":"#What","page":"Home","title":"What","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GalerkinToolkit provides a collection of tools to build computer codes to solve partial differential equations (PDEs) using finite element methods (FEMs) on different computing platforms, from laptops to modern GPU-based supercomputers. GalerkingToolkit is fully implemented in the Julia programming language and provides (or it will soon provide) tools for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Reading and partitioning computational meshes generated from external mesh generators (Gmsh at this moment).\nDefining discrete interpolation spaces on computational meshes including continuous and discontinuous interpolations.\nIntegrating 0, 1, and 2-forms on triangulated manifolds for a variety of problems, including scalar- and vector-valued equations, and single- and multi-field systems.\nDiscretizing PDEs into systems of linear-, nonlinear-, and differential-algebraic equations, including matrix-free operators.\nRepresenting such algebraic problems in a way that can be readily solved using external tools such as PartitionedSolvers.jl, PetscCall.jl, LinearSolve.jl, NonLinearSolve.jl, and DifferentialEquations.jl.\nAutomatic differentiation for non-linear and parametric problems.\nVisualizing results with Makie.jl and Paraview.","category":"page"},{"location":"","page":"Home","title":"Home","text":"From these items, the ones currently missing are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Automatic differentiation (expected by 2026).\nMatrix-free 2-forms (expected by 2026).\nDistributed computing (only partially available at the moment, expected by 2026).\nSingle- and multi-GPU support (ongoing PhD project, expected by 2027).","category":"page"},{"location":"#Why","page":"Home","title":"Why","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GalerkinToolkit is definitively not the first FEM software project out there, but it has some unique design features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"It combines the vision of frameworks like FEniCS and libraries like Deal-ii in a single package. It provides a high-level API backed with automatic code generation, and also easy access to the low-level building blocks of FE codes. See in the Examples section examples using the high-level API and automatic-code generation and also examples implementing the integration loops \"by hand\" using the low-level building blocks.\nIt is designed to blend with the Julia package ecosystem, and reuses as much as possible from it. For instance, GalerkinToolkit does not define differential operators, it simply uses the operators already defined in ForwardDiff.jl. It leverages PartitionedArrays.jl for distributed linear algebra data structures. You can use StaticArrays.jl and Tensors.jl, when working with vector- and tensor- valued PDEs. It also makes straight-forward to use external solvers to solve the algebraic systems you get after discretizing a PDE. For visualization, it defines recipes for Makie.jl and defines helper functions to save results with WriteVTK.jl in vtk format.\nIt is based on a new form compiler, the GalerkinToolkit form compiler (GTFC), that fixes the rigidity of domain-specific languages like UFL. It introduces an alternative multi-level intermediate representation (MLIR) and leveraging the meta-programming features of the Julia programming language. ","category":"page"},{"location":"#Help-and-discussion","page":"Home","title":"Help and discussion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can open a new discussion to ask questions here.\nIf you have found a bug, open an issue here. Do not forget to include a (minimal) reproducer.","category":"page"},{"location":"#How-to-cite","page":"Home","title":"How to cite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the CITATION.cff file.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is under active development and there are several ways to contribute:","category":"page"},{"location":"","page":"Home","title":"Home","text":"by enhancing the documentation (e.g., fixing typos, enhancing doc strings, adding examples).\nby addressing one of the issues waiting for help.\nby adding more tests to increase the code coverage.\nby extending the current functionality. In this case, open a discussion here to coordinate with the package maintainers before proposing significant changes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Discuss with the package authors before working on any non-trivial contribution.","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since July 2024, this package is being developed with support from the Netherlands eScience Center under grant ID NLESC.SS.2023.008.","category":"page"}]
}
