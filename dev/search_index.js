var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"manual/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"manual/getting_started/#Pre-requirements","page":"Getting started","title":"Pre-requirements","text":"","category":"section"},{"location":"manual/getting_started/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"EditURL = \"../src_jl/example_p_laplacian.jl\"","category":"page"},{"location":"src_md/example_p_laplacian/#p-Laplacian","page":"p-Laplacian","title":"p-Laplacian","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/#Problem-statement","page":"p-Laplacian","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Find the scalar-field u such that","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"leftlbrace\nbeginaligned\n-nabla cdot left( nabla u^p-2  nabla u right) = f textin Omega\nu = -1  texton  Gamma_0\nu = 1  texton  Gamma_1\nleft( nabla u^p-2 nabla u right)cdot n = 0  textelsewhere on  partialOmega\nendaligned\nright","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"with p2. The vector field n is the outwards unit normal vector to partialOmega. The computational domains are defined in the mesh file model.msh. The domain Omega is represented by the 3D faces in this mesh. The domain Gamma_0 is represented by the physical group named \"sides\" and Gamma_1 is the union of the physical groups named \"circle\", \"triangle\", and \"square\".  To solve this PDE, we use a conventional Galerkin finite element method with conforming Lagrangian FE spaces.","category":"page"},{"location":"src_md/example_p_laplacian/#Implementation","page":"p-Laplacian","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Import other dependencies.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Read and visualize the mesh.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"assets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"model.msh\")\nmesh = GT.mesh_from_msh(msh_file)\nnothing # hide\n\nMakie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_1.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define domains.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"dirichlet_0_names = [\"sides\"]\ndirichlet_1_names = [\"circle\", \"triangle\", \"square\"]\nΩ = GT.interior(mesh)\nΓ0 = GT.boundary(mesh;physical_names=dirichlet_0_names)\nΓ1 = GT.boundary(mesh;physical_names=dirichlet_1_names)\nΓd = GT.piecewise_domain(Γ0,Γ1)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define forcing data.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"g0 = GT.analytical_field(x->-1.0,Ω)\ng1 = GT.analytical_field(x->1.0,Ω)\ng = GT.piecewise_field(g0,g1)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define the interpolation space.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"k = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Interpolate Dirichlet values.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"T = Float64\nuh = GT.rand_field(T,V)\nGT.interpolate_dirichlet!(g,uh)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Visualize the Dirichlet field.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Makie.plot(Ω,color=uh,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define numerical integration.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"degree = 2*k\ndΩ = GT.measure(Ω,degree)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define weak form.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"const ∇ = ForwardDiff.gradient\nconst q = 3\nflux(∇u) = norm(∇u)^(q-2) * ∇u\ndflux(∇du,∇u) = (q-2)*norm(∇u)^(q-4)*(∇u⋅∇du)*∇u+norm(∇u)^(q-2)*∇du\nres = u -> v -> GT.∫( x-> ∇(v,x)⋅GT.call(flux,∇(u,x)), dΩ)\njac = u -> (du,v) -> GT.∫( x-> ∇(v,x)⋅GT.call(dflux,∇(du,x),∇(u,x)) , dΩ)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define non-linear problem using the automatic assembly loop generator.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"p = GT.nonlinear_problem(uh,res,jac)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define a nonlinear solver and solve the problem, and visualize the solution.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"s = PS.newton_raphson(p,verbose=true)\ns = PS.solve(s)\nuh = GT.solution_field(uh,s)\nMakie.plot(Ω;color=uh,strokecolor=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Now, solve while showing the intermediate results in the iteration process.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"uh = GT.rand_field(Float64,V)\nGT.interpolate_dirichlet!(g,uh)\np = GT.nonlinear_problem(uh,res,jac)\ns = PS.newton_raphson(p)\ncolor = Makie.Observable(uh)\nfig = Makie.plot(Ω;color,strokecolor=:black)\nfn = joinpath(@__DIR__,\"fig_p_laplacian.gif\")\nMakie.record(fig,fn,PS.history(s);framerate=2) do s\n    color[] = GT.solution_field(uh,s)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"EditURL = \"../src_jl/example_hello_world.jl\"","category":"page"},{"location":"src_md/example_hello_world/#Hello,-World!","page":"Hello, World!","title":"Hello, World!","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world/#Problem-statement","page":"Hello, World!","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"In this example, we show how to solve the \"Hello, world\" PDE example: the Poisson equation on the unit hyper-cube Omega  =01^d, din23, with Dirichlet boundary conditions.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"with f=0 and g(x)=textsum(x). In this case, we know that the solution is u=g which allows us to check that we solve the problem correctly, by integration an error norm.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"To solve this PDE, we use a conventional Galerkin finite element (FE) method with conforming Lagrangian FE spaces (see, e.g., [1] for specific details on this formulation).","category":"page"},{"location":"src_md/example_hello_world/#Implementation","page":"Hello, World!","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Import other dependencies","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Generate the computational mesh.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"domain = (0,1,0,1)\ncells = (10,10)\nmesh = GT.cartesian_mesh(domain,cells)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Visualize the mesh.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"axis = (aspect = Makie.DataAspect(),)\nMakie.plot(mesh;color=:pink,strokecolor=:blue,axis)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_1.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define the Dirichlet boundary.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"dirichlet_tag = \"dirichlet\"\nGT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Defile computational domains.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Ω = GT.interior(mesh)\nΓd = GT.boundary(mesh;physical_names=[dirichlet_tag])\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define differential operators","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"const ∇ = ForwardDiff.gradient\nΔ(f,x) = tr(ForwardDiff.jacobian(y->∇(f,y),x))","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define manufactured fields.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"g = GT.analytical_field(sum,Ω)\nf = GT.analytical_field(x->-Δ(g.definition,x),Ω)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define the interpolation space.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"k = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Interpolate Dirichlet values.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"T = Float64\nuhd = GT.zero_dirichlet_field(T,V)\nGT.interpolate_dirichlet!(g,uhd)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Visualize the Dirichlet field.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Makie.plot(Ω;color=uhd,strokecolor=:blue,axis)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define numerical integration.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"degree = 2*k\ndΩ = GT.measure(Ω,degree)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define weak form.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"a = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\nl = v -> GT.∫( x->v(x)*f(x), dΩ)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Assemble the problem using the automatic assembly loop generator","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"p = GT.linear_problem(uhd,a,l)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Solve the problem","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"s = PS.LinearAlgebra_lu(p)\ns = PS.solve(s)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Build the FE solution.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"uh = GT.solution_field(uhd,s)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Visualize the solution.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Makie.plot(Ω;color=uh,strokecolor=:black,axis)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Compute the L2 norm of the discretization error.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"eh = x -> uh(x) - g(x)\nel2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt","category":"page"},{"location":"src_md/example_hello_world/#Final-program","page":"Hello, World!","title":"Final program","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"module Program\n\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\n\nfunction main(;domain,cells)\n    mesh = GT.cartesian_mesh(domain,cells)\n    dirichlet_tag = \"dirichlet\"\n    GT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\n    Ω = GT.interior(mesh)\n    Γd = GT.boundary(mesh;physical_names=[dirichlet_tag])\n    ∇ = ForwardDiff.gradient\n    Δ(f,x) = tr(ForwardDiff.jacobian(y->∇(f,y),x))\n    g = GT.analytical_field(sum,Ω)\n    f = GT.analytical_field(x->-Δ(g.definition,x),Ω)\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n    T = Float64\n    uhd = GT.zero_dirichlet_field(T,V)\n    GT.interpolate_dirichlet!(g,uhd)\n    degree = 2*k\n    dΩ = GT.measure(Ω,degree)\n    a = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\n    l = v -> GT.∫( x->v(x)*f(x), dΩ)\n    p = GT.linear_problem(uhd,a,l)\n    s = PS.LinearAlgebra_lu(p)\n    s = PS.solve(s)\n    uh = GT.solution_field(uhd,s)\n    eh = x -> uh(x) - g(x)\n    el2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt\nend\n\nend # module","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Run it for a 2d case.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Program.main(domain=(0,1,0,1),cells=(10,10))","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Run it for a 3d case.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Program.main(domain=(0,1,0,1,0,1),cells=(10,10,10))","category":"page"},{"location":"src_md/example_hello_world/#References","page":"Hello, World!","title":"References","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"[1] C. Johnson. Numerical Solution of Partial Differential Equations by the Finite Element Method. Dover Publications, 2009.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"EditURL = \"../src_jl/example_poisson_equation.jl\"","category":"page"},{"location":"src_md/example_poisson_equation/#Poisson-equation","page":"Poisson equation","title":"Poisson equation","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/#Problem-statement","page":"Poisson equation","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Find the scalar field u such that","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton Gamma_rm D\nnabla ucdot n = h  texton  Gamma_rm N\nnabla ucdot n = 0  textelsewhere on  partial Omega\nendaligned\nright","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"being n the outwards unit normal vector to partialOmega. In this example, we chose f(x) = 1, g(x) = 2, and h(x)=3. The variable x is the position vector x=(x_1x_2x_3).  The computational domains are defined in the mesh file model.msh. The domain Omega is represented by the 3D faces in this mesh. The domain Gamma_rm D is represented by the physical group named \"sides\" and Gamma_rm N is the union of the physical groups named \"circle\", \"triangle\", and \"square\".  To solve this PDE, we use a conventional Galerkin finite element method with conforming Lagrangian FE spaces.","category":"page"},{"location":"src_md/example_poisson_equation/#Implementation","page":"Poisson equation","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Import other dependencies","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Read and visualize the mesh","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"assets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"model.msh\")\nmesh = GT.mesh_from_msh(msh_file)\nnothing # hide\n\nMakie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_0.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define domains and visualize them","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Ω = GT.interior(mesh)\nMakie.plot(Ω,color=:pink)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_1.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"dirichlet_names = [\"sides\"]\nΓd = GT.boundary(mesh;physical_names=dirichlet_names)\nMakie.plot(Γd,color=:pink)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"neumann_names = [\"circle\", \"triangle\", \"square\"]\nΓn = GT.boundary(mesh;physical_names=neumann_names)\nMakie.plot(Γn,color=:pink)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define forcing data","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"f = GT.analytical_field(x->1.0,Ω)\ng = GT.analytical_field(x->2.0,Ω)\nh = GT.analytical_field(x->3.0,Ω)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define the interpolation space.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"k = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Interpolate Dirichlet values.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"T = Float64\nuhd = GT.zero_dirichlet_field(T,V)\nGT.interpolate_dirichlet!(g,uhd)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Visualize the Dirichlet field.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Makie.plot(Ω,color=uhd,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_4.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define numerical integration.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"degree = 2*k\ndΩ = GT.measure(Ω,degree)\ndΓn = GT.measure(Γn,degree)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define weak form.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"const ∇ = ForwardDiff.gradient\na = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\nl = v -> GT.∫( x->v(x)*f(x), dΩ) + GT.∫( x->v(x)*h(x), dΓn)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Assemble the problem using the automatic assembly loop generator","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"p = GT.linear_problem(uhd,a,l)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Solve the problem","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"s = PS.LinearAlgebra_lu(p)\ns = PS.solve(s)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Build the FE solution.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"uh = GT.solution_field(uhd,s)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Visualize the solution.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Makie.plot(Ω;color=uh,strokecolor=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_5.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/for_developers/#For-developers","page":"For developers","title":"For developers","text":"","category":"section"},{"location":"manual/for_developers/#Building-the-documentation-locally","page":"For developers","title":"Building the documentation locally","text":"","category":"section"},{"location":"manual/for_developers/#Setup-the-docs-folder-environment","page":"For developers","title":"Setup the docs folder environment","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"We assume that your terminal is located in the root folder of the GalerkingToolkit.jl repo. Open Julia, pointing to the docs folder.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"$ julia --project=docs/","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"Develop your current copy of GalerkingToolkit.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> ]\n(docs) pkg> dev .","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"You will need to do this each time the dependencies of the documentation or of GalerkinToolkit change.","category":"page"},{"location":"manual/for_developers/#Standard-build","page":"For developers","title":"Standard build","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"After the setup, exit package mode and run","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/make.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"This will take a while. When it is done, you will have the html docs in the folder docs/build.","category":"page"},{"location":"manual/for_developers/#Visualizing-the-documentation","page":"For developers","title":"Visualizing the documentation","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The easiest way to visualize the documentation is using LiveServer as follows.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> using LiveServer\nserve(dir=\"docs/build/\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"After it, your docs will be served at the given url.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"If nor yet done, you can install LiveServer as follows. We recommend to install it in your global environment.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> ]\npkg> activate\npgk> add LiveServer","category":"page"},{"location":"manual/for_developers/#Quick-build","page":"For developers","title":"Quick build","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The standard build takes a long time since it runs several examples. This delay makes this approach impractical to write documentation, since one needs to build the docs often to check the final result.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"To avoid this, one can run all the files in docs/src/src_jl in advance using","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/make_media.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"and then one can quickly build the documentation with","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/make_with_media.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"This will work as long as you are not including new figures or animations that are generated by running the files in the docs/src/src_jl folder. Otherwise you will need to run the particular file with","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/src/src_jl/<file that generates the figure>.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"or running again","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/media.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The output documentation is not exactly the same as the generated with the standard build method, but it is good enough for development.","category":"page"},{"location":"manual/for_developers/#Performance-Benchmarks","page":"For developers","title":"Performance Benchmarks","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"There is a benchmark suite defined in GalerkinToolkitExamples/benchmarks. This uses BenchmarkTools.jl to perform the timings and github-action-benchmark to collect the results and store them in the benchmarks branch. Upon merging of a PR, and after the docs have built, the benchmark results are copied from the benchmarks branch into the gh-pages branch. This is required to prevent overwriting of the previous results by docs deployment etc.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"Graphs of performance changes over time (per commit hash) can then be viewed here: https://galerkintoolkit.github.io/GalerkinToolkit.jl/dev/bench/.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The github action can be configured (in .github/workflows/CI.yml, job benchmark) to fail if the performance change is beyond a given threshold. Look for the alert-threshold: and fail-on-alert: keys.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"More benchmarks can be added (or existing ones modified) in GalerkinToolkitExamples/benchmarks/run_benchmarks.jl.","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"EditURL = \"../src_jl/example_stokes.jl\"","category":"page"},{"location":"src_md/example_stokes/#Stokes-lid-driven-cavity","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"","category":"section"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"(Image: )","category":"page"},{"location":"src_md/example_stokes/#Problem-statement","page":"Stokes lid-driven cavity","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"We solve the lid-driven cavity for a stokes flow. We use an inf-sub stable high order formulation. The velocity is a continuous piecewise multi-linear polynomial of order order and the pressure is a discontinuous piecewise linear polinomyal of order order-1. We constraint the pressure to zero at an arbitrary point of the domain (the last pressure node) to end up with a problem with unique solution.","category":"page"},{"location":"src_md/example_stokes/#Implementation","page":"Stokes lid-driven cavity","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport GLMakie as Makie\nimport ForwardDiff\nimport StaticArrays\nimport Tensors\nusing LinearAlgebra\nimport FileIO # hide\ndomain = (0,1,0,1)\ncells = (20,20)\nD = length(cells)\nmesh = GT.cartesian_mesh(domain,cells)\nΩ = GT.interior(mesh)\nΓ1 = GT.boundary(mesh;physical_names=[\"1-face-2\"])\nΓ2 = GT.boundary(mesh;physical_names=[\"1-face-1\",\"1-face-3\",\"1-face-4\"])\ng1 = GT.analytical_field(x->StaticArrays.SVector(1,0),Ω)\ng2 = GT.analytical_field(x->StaticArrays.SVector(0,0),Ω)\ng = GT.piecewise_field(g1,g2)\nΓ = GT.piecewise_domain(Γ1,Γ2)\norder = 2\nV = GT.lagrange_space(Ω,order;space_type=:Q,tensor_size=Val((D,)),dirichlet_boundary=Γ)\nQ = GT.lagrange_space(Ω,order-1;space_type=:P,dirichlet_boundary=GT.last_dof())\nVxQ = V × Q\nu_field, p_field = 1,2\nuhph_dirichlet = GT.zero_dirichlet_field(Float64,VxQ)\nuhd = GT.field(uhph_dirichlet,u_field)\nGT.interpolate_dirichlet!(g,uhd)\ndΩ = GT.measure(Ω,2*order)\n∇ = ForwardDiff.jacobian\ndiv(u,x) = tr(∇(u,x))\na((u,p),(v,q)) = GT.∫( x-> ∇(v,x)⋅∇(u,x) - div(v,x)*p(x) + q(x)*div(u,x), dΩ)\nl((v,q)) = 0\np = GT.linear_problem(uhph_dirichlet,a,l)\ns = PS.LinearAlgebra_lu(p)\ns = PS.solve(s)\nuh,ph = GT.solution_field(uhph_dirichlet,s)\naxis = (aspect = Makie.DataAspect(),)\nMakie.plot(Ω;color=ph,axis)\nMakie.arrows!(uh;color=x->norm(uh(x)),lengthscale=0.1)\nFileIO.save(joinpath(@__DIR__,\"fig_stokes.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"(Image: )","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"EditURL = \"../src_jl/tutorial_intro_to_fem.jl\"","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Introduction-to-FEM","page":"Introduction to FEM","title":"Introduction to FEM","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"by Francesc Verdugo (VU Amsterdam)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"In this tutorial, we will learn:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The gist of the finite element method (FEM).\nHow to solve a simple partial differential equation (PDE) with it.\nHow to express the key concept in code using GalerkinToolkit.\nHow to validate the code using the method manufactured solutions.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"This tutorial is useful even if you are a FEM expert if you want to learn GalerkinToolkit. It will walk you through the key parts of the library.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"This tutorial is made available under a CC BY 4.0 license. The API documentation and source code of GalerkinToolkit is available under an MIT license.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Problem-statement","page":"Introduction to FEM","title":"Problem statement","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"In this tutorial, we show how to solve a simple PDE with the FEM. To make this introduction really an introduction we consider what is considered the \"hello, world\" PDE: the Poisson equation.  Our goal is to solve the Poisson equation with Dirichlet boundary conditions on a given domain OmegasubsetmathbbR^d with d being the number of spatial dimensions (d=2 in this example). This problem is formalized as finding the function uOmegarightarrowmathbbR such that","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where Delta u = sum_i=1^d partial^2 u  partial x_i^2 is the Laplace operator and f, g are two given functions fgOmegarightarrowmathbbR. The boundary condition g applies on the boundary of Omega, which is denoted as partialOmega. For simplicity, we will define Omega as a disk of radius one. This is a simple geometry, but yet more complex than a two-dimensional box. We this, we illustrate that FEM can be used to solve PDEs on complex geometries beyond simple \"boxes\".","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#The-method-of-manufactured-solutions","page":"Introduction to FEM","title":"The method of manufactured solutions","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We are going to select f and g in such a way u is a known function. This will allow us to compare the numerical approximation computed with FEM against the theoretical exact solution u. This technique is known as the \"method of manufactured solutions\". Let us, \"manufacture\" f and g such that function u(x)=(sum_i=1^d x_i)^p is the solution of the PDE above. The scalar p is a given integer p0. It will be useful to see how the numerical solution will behave for different values of p.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"To manufacture function f and g we applying the PDE operators to the given function u. That is, f needs to be computed as f= -Delta ((sum_i=1^d x_i)^p) and g is simply g(x)=(sum_i=1^d x_i)^p. Applying the Laplace operator to (sum_i=1^d x_i)^p, we get the closed-form expression for f, namely f(x)= -p(p-1)(sum_i=1^d x_i)^(p-2).","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Numerical-approximation","page":"Introduction to FEM","title":"Numerical approximation","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The FEM transforms a PDE into a system of linear algebraic equations of the form Ax=b, where A is a matrix and b is a vector. This reduces the problem of finding function u to finding vector x, which can be done on a computer using arrays and other numeric data structures. To do this, FEM does not look for the exact function u, but for approximations of it that can be written as a linear combination of a finite number of basis functions, namely","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"u^mathrmfem(x)=sum_j=1^N alpha_j s_j(x)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"where alpha_i are the coefficients of the linear combination, s_i are functions such that s_iOmegarightarrowmathbbR and N is an integer. The basis functions s_i are also called \"shape functions\" or \"hat functions\". The goal of FEM is to find suitable values for alpha_i and s_i(x) such that u^mathrmfem is a good approximation of the exact solution u, namely u^mathrmfem(x)approx u(x) for points xinOmega. Spoiler alert: the more computational effort we put in building function u^mathrmfem the better will be the approximation.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Workflow","page":"Introduction to FEM","title":"Workflow","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Function u^mathrmfem is built as follows. First, we define the auxiliary functions s_i(x). This step is often referred as the \"numerical discretization\" and entails defining a computational mesh and a finite element (FE) function space. The next step is building a system of linear algebraic equations Ax=b. This step is called the \"FEM assembly\". Then, one solves for the vector x in what is called the \"solver\" or \"solution\" step. At this points, the coefficients alpha_i can be computed using both vector x and the Dirichlet boundary conditions of the PDE. The final step is typically some post-process of function u^mathrmfem. For instance, visualize it, store it into a file, compute some quantity of interest, etc. In summary, these are the key phases in a FEM computation:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Discretization\nAssembly\nSolution\nPost-process","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Mesh-generation","page":"Introduction to FEM","title":"Mesh generation","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The FEM starts by building a \"triangulation\" mathcalT of the domain Omega in which the PDE is defined. A triangulation mathcalT is a set of simpler domains T_ksubsetmathbbR^d, whose union is an approximation of Omega, namely cup_k=1^M T_kapproxOmega. Each domain T_k is often called an \"element\", a \"cell\" or a \"face\", and they are typically simple geometries such as triangles, tetrahedra, hexahedra, etc. The integer M denotes the number of elements here. The triangulation is also often called a computational mesh or a computational grid.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Let's build a mesh for our domain Omega using code. First, let us load all packages that we will use in this tutorial:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"using LinearAlgebra\nusing Random\nimport GalerkinToolkit as GT\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"A common practice in GalerkinToolkit is to load packages in the Julia standard library with using. Other packages are loaded with import. This makes clear from which package each function comes from, while assuming that developers already know functions in the standard library.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The following cell builds a triangulation (a mesh object) using the external mesh generation tool GMSH. The variable mesh_size controls how fine are the cells in the mesh (smaller is finer). We start with a coarse mesh to make visualization easier. In this tutorial, we are not going to comment in detail all code lines. We will discuss only the parts relevant in this high-level introduction. You can refer to the API documentation other tutorials when needed.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"mesh_size = 0.3\nR = 1 #Radius\nmesh = GT.with_gmsh() do gmsh\n    dim = 2\n    circle_tag = gmsh.model.occ.add_circle(0,0,0,R)\n    circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])\n    circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])\n    gmsh.model.occ.synchronize()\n    gmsh.model.model.add_physical_group(dim,[circle_surf_tag],-1,\"Omega\")\n    gmsh.option.setNumber(\"Mesh.MeshSizeMax\",mesh_size)\n    gmsh.model.mesh.generate(dim)\n    GT.mesh_from_gmsh(gmsh)\nend\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"There are ways of accessing the low level information in this mesh object, but we are not going to discuss them in this tutorial. Here, we only need to know how to visualize the mesh, and other high-level operations. The mesh can be visualized both using Paraview and Makie. We use Makie in this tutorial.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"axis = (aspect = Makie.DataAspect(),)\nMakie.plot(mesh;color=:pink,strokecolor=:blue,axis)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_mesh.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Computational-domains","page":"Introduction to FEM","title":"Computational domains","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Note that two domains appear in the definition of the PDE above, the domain Omega and its boundary partialOmega. We need to build data objects representing these domains in order to solve the PDE with GalerkinToolkit. They are built from the mesh objects as follows:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Ω = GT.interior(mesh)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"and","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"∂Ω = GT.boundary(mesh)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We can also visualize them using Makie.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Makie.plot(Ω;color=:pink,axis)\nMakie.plot!(∂Ω;color=:blue,linewidth=3)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_domains.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Note that Ω is indeed an approximation of the unit disk (visualized as a pink surface), and ∂Ω is its boundary (visualized as blue lines).","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#FE-space","page":"Introduction to FEM","title":"FE space","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Let us build the data structure representing the finite element function u^mathrmfem. We need two ingredients, the functions s_i and the coefficients α_i. Functions s_i are linearly independent and can be understood as the basis of a vector space V=mathrmspans_1ldotss_N. This space is called the FE space. There are many ways of defining FE spaces. Here, we will use the simplest one, which is based on Lagrange polynomials. To build it with GalerkinToolkit, we need the discretized computational domain on which the functions of the space are defined and their polynomial degree of the Lagrange basis functions.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"degree = 3\nV = GT.lagrange_space(Ω,degree)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We will discus the mathematical derivation of this FE space in another tutorial. For now, it is enough to understand that the object V has information about the basis functions s_i. For instance, you can get the number of basis functions with","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"N = GT.num_dofs(V)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The word \"dofs\" stands for degrees of freedom (DOFs). Each coefficent alpha_i can be understood as a degree of freedom, i.e., a quantity that can be tweaked to modify function u^mathrmfem.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The coefficients alpha_i are unknown at this point. We will compute them later. For the moment, we can build a mock u^mathrmfem using some random coefficients alpha_i just to see the connection between the coefficients  alpha_i and the resulting function u^mathrmfem. We create them as a random vector of length N.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Random.seed!(1)\nα = rand(N)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Now we can create the function from these coefficients and the FE space as follows:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"u_fem = GT.solution_field(V,α)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Let's us visualize it. We do this by plotting domain Omega but not colored using the function value.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"#Create figure\nfig = Makie.Figure()\n#Plot u_fem on a finer mesh\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=u_fem,refinement=5)\n#Plot edges of the original mesh\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\n#Plot colorbar\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_rand_field.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"By looking into the figure it is clear that function u^mathrmfem(x) is ineed a function that can be evaluated at any point inside the domain Omega.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"To have a better intuition of the meaning of the basis functions s_i, let us visualize one of them. If we want to visualize s_400, we just need to create coefficients such that alpha_400=1 and alpha_i=0 for ineq 400.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"α2 = zeros(N)\nα2[400] = 1\ns_400 = GT.solution_field(V,α2)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Now, we can visualize this function as we did before for u^mathrmfem.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=s_400,refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_shape.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Note that the function is equal to one at a single point and zero almost everywhere. The point x_i in which the function s_i(x_i)=1 is called the \"node\" associated with this function. Each function s_i has a node associated with it. We can get the coordinates of all this nodes as follows:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"x = GT.node_coordinates(V)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"This is a vector containing the coordinates for all nodes. The coordinates for the node associated with function s_400 can be accessed as","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"x_400 = x[400]","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We can also visualize all node coordinates.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Makie.plot(Ω;color=:pink,strokecolor=:black,axis)\nMakie.scatter!(x;color=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_nodes.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"We have as many basis functions as nodes in this figure. The shape functions s_i have also a very important property. Function s_i is equal to one at its node x_i, but it is zero at all other nodes, namely s_i(x_j)=delta_ij, where delta_ij is Kronecker's delta. This property allows us to interpret the coefficients alpha_i as the \"nodal values\" of function u^mathrmfem. That is, alpha_i is the value of u^mathrmfem at node x_i, alpha_i=u^mathrmfem(x_i). You can easily prove this by taking u^mathrmfem(x_i) = sum_j=1^N alpha_j s_j(x_i) and considering that s_j(x_i)=delta_ji.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"In summary, the coefficients α_i are the values of u^mathrmfem at the nodes, whereas, function u^mathrmfem can be understood as the (Lagrange) interpolation of these nodal values into any other point of the domain Ω as shown in this figure:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"_,schene = Makie.plot(Ω;axis,color=u_fem,refinement=5)\nMakie.plot!(Ω;color=nothing,strokecolor=:black)\ncolorrange = scene[:colorrange]\nMakie.scatter!(x;color=α,colormap=:bluesreds,colorrange)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_nodes_color2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"NB. In this scalar-valued FE space, there is a one-to-one relation between the coefficients (DOFs) alpha_i and the nodes x_i. This is not true for other types of spaces. In vector-valued Lagrange spaces, there are several DOFs in one node.  In other FE spaces the concept of \"nodes\" does not make sense at all.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Free-and-Dirichlet-nodes","page":"Introduction to FEM","title":"Free and Dirichlet nodes","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Remember that our goal is to find the coefficients α_i. Most of these coefficients are unknown, but not all of them. Note that the PDE states that u=g on the boundary partialOmega. With this information we can easily compute the coefficients alpha_i for nodes x_i on the Dirichlet boundary partialOmega simply as alpha_i=g(x_i). We need to classify the nodes into two groups: the ones on the Dirichlet boundary partialOmega in one group and the remaining nodes in another group. Let us call mathcalI^mathrmd (\"d\" for Dirichlet) the set of all integers i for which the node x_i is on partialOmega. Let us call mathcalI^mathrmf (\"f\" for free) the other of all integers i for which the node x_i is not on partialOmega.  The coefficient alpha_i is computed as alpha_i=g(x_i) for iinmathcalI^mathrmd and the remaining coefficients will be computed solving a system of linear equations. The union of mathcalI^mathrmd and mathcalI^mathrmf cover all nodes of the FE space. We call N^mathrmf and N^mathrmd the number of items in mathcalI^mathrmf and mathcalI^mathrmd respectively, i.e, the number of free and Dirichlet nodes.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"The nodes are classified in the code as follows. We create a FE space that is aware of the Dirichlet boundary:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"V = GT.lagrange_space(Ω,degree;dirichlet_boundary=∂Ω)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Now the nodes/DOFs in this space are split on two groups: free and Dirichlet. We can get the number of free nodes/DOFs","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"N_f = GT.num_free_dofs(V)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"and the number of Dirichlet nodes/DOFs.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"N_d = GT.num_dirichlet_dofs(V)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Dirichlet-Field","page":"Introduction to FEM","title":"Dirichlet Field","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Using the classification of nodes, we can decompose function u^mathrmfem as the sum of two functions, u^mathrmfem(x)=u^mathrmf(x)+u^mathrmd(x)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"u^mathrmf(x)=sum_jinmathcalI^mathrmf alpha_j s_j(x)\ntext and \nu^mathrmd(x)=sum_jinmathcalI^mathrmd alpha_j s_j(x)","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"which corresponds to restrict the linear combination to free or Dirichlet DOFs respectively. This decomposition is useful because u^mathrmd can be directly computed from the Dirichlet Boundary condition. We refer to u^mathrmd as the \"Dirichlet field\". If can be computed in the code as follows. First, we compute the coefficients for the Dirichlet nodes. We do this by using function g and the nodal coordinates of the Dirichlet nodes. These coordinates can be computed by restricting the vector of coordinates of all nodes, to only the Dirichlet nodes:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"node_to_x = GT.node_coordinates(V)\ndirichlet_dof_to_node = GT.dirichlet_dof_node(V)\ndirichlet_dof_to_x = node_to_x[dirichlet_dof_to_node]\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Note that dirichlet_dof_to_node contains the ids of all nodes on the Dirichlet boundary. Now, we can compute the values using the definition of function g.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"α_d = map(dirichlet_dof_to_x) do x\n    p = 1\n    sum(x)^p\nend\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Finally, we create the object for the Dirichlet field from the computed values","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"u_d = GT.dirichlet_field(V,α_d)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Now we can visualize the Dirichlet field and confirm that it is indeed a function that is non-zero at the nodes on the Dirichlet boundary, and zero at the other nodes:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=u_d,refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_diri.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"There is a more compact and more general way of generating the Dirichlet:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"g = GT.analytical_field(Ω) do x\n    p = 1\n    sum(x)^p\nend\nu_d = GT.interpolate_dirichlet(g,V)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"This will work also for FE spaces that are not associated with \"nodes\". In this case, the Dirichlet values will be filled in using a base of the dual space of V.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Using the Dirichlet field, we can create function u^mathrmfem only from coefficients that are associated with free nodes. These are going to be computed later by solving a system of linear equations, but we can create a mock version from randomly generated coefficients. In this case, we generate a vector of length N^mathrmf instead of N because it should contain only \"free\" values.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Random.seed!(2)\nα_f = rand(N_f)\nu_fem = GT.solution_field(u_d,α_f)\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"In the following figure, one can see that u^mathrmfem generated in this way has random values in the interior of Omega, while matching the Dirichlet boundary condition on partialOmega.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=u_fem,refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_fem_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Weak-form","page":"Introduction to FEM","title":"Weak form","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"To solve the problem we need to find as many as N^mathrmf coefficients. In other words, we have N^mathrmf unknowns, which suggests that we needs to consider N^mathrmf equations. These equations will follow from the PDE above. One can try to substitute the expression of u^mathrmfem and try to find which coefficients alpha_i that minimize the residual of the equation in some norm. However, we cannot use the PDE directly in this form. The equation is in face not well defined for function u^mathrmfem. This function is continuous, but its gradient it is not continuous at the boundaries of the mesh cells. As a consequence the Laplace operator it is not well defined as one cannot compute derivatives of a discontinuous function.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Let us visualize one of the component of gradient of u^mathrmfem to confirm that is discontinuous. First, let us define the nabla operator","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"∇ = ForwardDiff.gradient\nnothing # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"Now we can visualize the first component of the gradient as follows:","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"fig = Makie.Figure()\n_,scene = Makie.plot(fig[1,1],Ω;axis,color=x->∇(u_fem,x)[1],refinement=5)\nMakie.plot!(fig[1,1],Ω,color=nothing,strokecolor=:black)\nMakie.Colorbar(fig[1,2],scene)\nFileIO.save(joinpath(@__DIR__,\"fig_tutorial_intro_grad.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"(Image: )","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"It is indeed discontinuous at the mesh cell boundaries.","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"EditURL = \"../src_jl/example_hello_world_manual.jl\"","category":"page"},{"location":"src_md/example_hello_world_manual/#Hello,-World!-(manual-assembly)","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"","category":"section"},{"location":"src_md/example_hello_world_manual/#Problem-statement","page":"Hello, World! (manual assembly)","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"We solve the same problem as in the Hello, World! example, but in this case we explicitly write the numerical integration loops.","category":"page"},{"location":"src_md/example_hello_world_manual/#Implementation","page":"Hello, World! (manual assembly)","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Import other dependencies","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Setup the objects defining this example","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function setup_example(;domain,cells)\n    mesh = GT.cartesian_mesh(domain,cells)\n    dirichlet_tag = \"dirichlet\"\n    GT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\n    Ω = GT.interior(mesh)\n    Γd = GT.boundary(mesh;physical_names=[dirichlet_tag])\n    ∇ = ForwardDiff.gradient\n    Δ(f,x) = tr(ForwardDiff.jacobian(y->∇(f,y),x))\n    g = GT.analytical_field(sum,Ω)\n    f = GT.analytical_field(x->-Δ(g.definition,x),Ω)\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n    T = Float64\n    uhd = GT.zero_dirichlet_field(T,V)\n    GT.interpolate_dirichlet!(g,uhd)\n    degree = 2*k\n    dΩ = GT.measure(Ω,degree)\n    example = (;mesh,Ω,dΩ,V,uhd,f,g)\n    state = (;example)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Create accessor functions for low-level integration quantities.","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function setup_integration_accessors(state)\n    (;dΩ) = state.example\n    face_point_x = GT.coordinate_accessor(dΩ)\n    face_point_J = GT.jacobian_accessor(dΩ)\n    face_point_dV = GT.weight_accessor(dΩ)\n    face_npoints = GT.num_points_accessor(dΩ)\n    integration = (;\n        face_point_x,face_point_J, face_point_dV,face_npoints)\n    (;integration,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Create accessor functions for low-level interpolation quantities.","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function setup_interpolation_accessors(state)\n    (;dΩ,Ω,V,uhd) = state.example\n    face_dofs = GT.dofs_accessor(V,Ω)\n    face_point_dof_s = GT.shape_function_accessor(GT.value,V,dΩ)\n    face_point_dof_∇s = GT.shape_function_accessor(ForwardDiff.gradient,V,dΩ)\n    face_dirichlet! = GT.dirichlet_accessor(uhd,Ω)\n    interpolation = (;\n        face_dofs,face_point_dof_s,face_point_dof_∇s,face_dirichlet!)\n    (;interpolation,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Compute local matrix and vector","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function face_tensors!(Auu,bu,face,state)\n\n    (;example,integration,interpolation) = state\n    (;f) = example\n\n    #Get quantities at current face\n    npoints = integration.face_npoints(face)\n    point_x = integration.face_point_x(face)\n    point_J = integration.face_point_J(face)\n    point_dV = integration.face_point_dV(face)\n    point_dof_s = interpolation.face_point_dof_s(face)\n    point_dof_∇s = interpolation.face_point_dof_∇s(face)\n    dofs = interpolation.face_dofs(face)\n    dirichlet! = interpolation.face_dirichlet!(face)\n\n    #Reset face matrix and vector\n    fill!(Auu,zero(eltype(Auu)))\n    fill!(bu,zero(eltype(bu)))\n\n    #Loop over integration points\n    for point in 1:npoints\n\n        #Get quantities at current integration point\n        x = point_x(point)\n        J = point_J(point)\n        dV = point_dV(point,J)\n        dof_s = point_dof_s(point)\n        dof_∇s = point_dof_∇s(point,J)\n\n        #Fill in face matrix and vector\n        for (i,dofi) in enumerate(dofs)\n            v = dof_s(i)\n            ∇v = dof_∇s(i)\n            bu[i] += f.definition(x)*v*dV\n            for (j,dofj) in enumerate(dofs)\n                ∇u = dof_∇s(j)\n                Auu[i,j] += ∇v⋅∇u*dV\n            end\n        end\n    end\n\n    #Apply Dirichlet conditions on face vector\n    dirichlet!(Auu,bu)\n\n    #Return dof ids for this face\n    dofs\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Assemble linear problem","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function assemble_problem(state)\n\n    (;example) = state\n    (;V,Ω,f) = example\n\n    #Allocate auxiliary face matrix and vector\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Allocate space for the global matrix and vector\n    b_alloc = GT.allocate_vector(T,V,Ω)\n    A_alloc = GT.allocate_matrix(T,V,V,Ω)\n\n    #Loop over the faces of the domain\n    for face in 1:GT.num_faces(Ω)\n\n        #Compute face tensors\n        dofs = face_tensors!(Auu,bu,face,state)\n\n        #Add face contribution to global allocation\n        GT.contribute!(b_alloc,bu,dofs)\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n    end\n\n    #Compress matrix and vector into the final format\n    b = GT.compress(b_alloc)\n    A = GT.compress(A_alloc)\n\n    #Allocate space for the solution\n    sol = similar(b,axes(A,2))\n\n    #Create linear problem object\n    problem = PS.linear_problem(sol,A,b)\n    (;problem,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Solve the solution problem and build the solution field","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function solve_problem(state)\n    (;problem,example) = state\n    (;uhd) = example\n    solver = PS.LinearAlgebra_lu(problem)\n    solver = PS.solve(solver)\n    uh = GT.solution_field(uhd,solver)\n    (;uh,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Setup accessor functions to integrate error norms","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function setup_postpro_accessors(state)\n    (;uh,example) = state\n    (;dΩ) = example\n    #TODO add also h1 norm\n    face_point_uhx = GT.discrete_field_accessor(GT.value,uh,dΩ)\n    postpro = (;face_point_uhx)\n    (;postpro,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Compute the error norms","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function integrate_error_norms(state)\n    (;postpro,example,integration) = state\n    (;Ω,dΩ,g) = example\n    #TODO add also h1 norm\n    T = Float64\n    el2 = zero(T)\n    for face in 1:GT.num_faces(Ω)\n        npoints = integration.face_npoints(face)\n        point_x = integration.face_point_x(face)\n        point_J = integration.face_point_J(face)\n        point_dV = integration.face_point_dV(face)\n        point_uhx = postpro.face_point_uhx(face)\n        for point in 1:npoints\n            x = point_x(point)\n            J = point_J(point)\n            dV = point_dV(point,J)\n            uhx = point_uhx(point,J)\n            el2 += abs2(uhx-g.definition(x))*dV\n        end\n    end\n    el2 = sqrt(el2)\n    norms = (;el2)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/#Final-Program","page":"Hello, World! (manual assembly)","title":"Final Program","text":"","category":"section"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function main(;kwargs...)\n    state1 = setup_example(;kwargs...)\n    state2 = setup_integration_accessors(state1)\n    state3 = setup_interpolation_accessors(state2)\n    state4 = assemble_problem(state3)\n    state5 = solve_problem(state4)\n    state6 = setup_postpro_accessors(state5)\n    norms = integrate_error_norms(state6)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Run it for a 2d case","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"main(domain=(0,1,0,1),cells=(10,10))","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Run it for a 3d case","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"main(domain=(0,1,0,1,0,1),cells=(10,10,10))","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"EditURL = \"../src_jl/example_p_laplacian_manual.jl\"","category":"page"},{"location":"src_md/example_p_laplacian_manual/#p-Laplacian-(manual-assembly)","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"","category":"section"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian_manual/#Problem-statement","page":"p-Laplacian (manual assembly)","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"We solve the same problem as in the p-Laplacian example, but in this case we explicitly write the numerical integration loops.","category":"page"},{"location":"src_md/example_p_laplacian_manual/#Implementation","page":"p-Laplacian (manual assembly)","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Import other dependencies","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Setup the objects defining this example","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function setup_example(;file)\n    assets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\n    msh_file = joinpath(assets_dir,\"model.msh\")\n    mesh = GT.mesh_from_msh(msh_file)\n    dirichlet_0_names = [\"sides\"]\n    dirichlet_1_names = [\"circle\", \"triangle\", \"square\"]\n    Ω = GT.interior(mesh)\n    Γ0 = GT.boundary(mesh;physical_names=dirichlet_0_names)\n    Γ1 = GT.boundary(mesh;physical_names=dirichlet_1_names)\n    Γd = GT.piecewise_domain(Γ0,Γ1)\n    g0 = GT.analytical_field(x->-1.0,Ω)\n    g1 = GT.analytical_field(x->1.0,Ω)\n    g = GT.piecewise_field(g0,g1)\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n    T = Float64\n    uh = GT.rand_field(T,V)\n    GT.interpolate_dirichlet!(g,uh)\n    degree = 2*k\n    dΩ = GT.measure(Ω,degree)\n    example = (;mesh,Ω,dΩ,V,uh,T,g,file)\n    state = (;example)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Create accessor functions for low-level integration quantities.","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function setup_integration_accessors(state)\n    (;dΩ) = state.example\n    face_point_x = GT.coordinate_accessor(dΩ)\n    face_point_J = GT.jacobian_accessor(dΩ)\n    face_point_dV = GT.weight_accessor(dΩ)\n    face_npoints = GT.num_points_accessor(dΩ)\n    integration = (;\n        face_point_x,face_point_J, face_point_dV,face_npoints)\n    (;integration,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Create accessor functions for low-level interpolation quantities.","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function setup_interpolation_accessors(state)\n    (;dΩ,Ω,V,uh) = state.example\n    face_dofs = GT.dofs_accessor(V,Ω)\n    face_point_dof_s = GT.shape_function_accessor(GT.value,V,dΩ)\n    face_point_dof_∇s = GT.shape_function_accessor(ForwardDiff.gradient,V,dΩ)\n    interpolation = (;face_dofs,face_point_dof_s,face_point_dof_∇s)\n    (;interpolation,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Define the algebraic non-linear problem object","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function setup_nonlinear_problem(state)\n\n    (;example) = state\n    (;V,Ω,dΩ,T,uh) = example\n\n    #Get initial guess\n    x = GT.free_values(uh)\n\n    #Create accessor for the field gradient\n    face_point_∇uh = GT.discrete_field_accessor(ForwardDiff.gradient,uh,dΩ)\n\n    #Allocate auxiliary face matrix and vector\n    n = GT.max_num_reference_dofs(V)\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Allocate space for the global matrix and vector\n    b_alloc = GT.allocate_vector(T,V,Ω)\n    A_alloc = GT.allocate_matrix(T,V,V,Ω)\n\n    #Fill in residual and jacobian according to the initial state\n    allocs = (;A_alloc,b_alloc,Auu,bu)\n    fill_residual_and_jacobian!(state,allocs,face_point_∇uh) # Defined later\n\n    #Compress matrix and vector into the final format\n    b,b_cache = GT.compress(b_alloc;reuse=Val(true))\n    A,A_cache = GT.compress(A_alloc;reuse=Val(true))\n\n    #Build the nonlinear problem object\n    workspace = (;state,face_point_∇uh,allocs,b,b_cache,A,A_cache)\n    problem = PS.nonlinear_problem(update_problem,x,b,A,workspace)\n\n    (;problem,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Non-linear problem update function. The input problem is in an inconsistent state: residual(problem) and jacobian(problem) are not synchronized with solution(problem). The goal of this function is to update the residual and jacobian for the current solution guess.","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function update_problem(problem)\n\n    #Unpack workspace\n    (;state,face_point_∇uh,allocs,b,b_cache,A,A_cache) = PS.workspace(problem)\n    (;A_alloc,b_alloc,Auu,bu) = allocs\n    (;example) = state\n    (;uh) = example\n\n    #Get the current solution vector\n    x = PS.solution(problem)\n\n    #Build the current solution field\n    uh = GT.solution_field(uh,x)\n\n    #Update the accessor\n    face_point_∇uh = GT.update(face_point_∇uh,discrete_field=uh)\n\n    #Fill in residual and Jacobian\n    fill_residual_and_jacobian!(state,allocs,face_point_∇uh)\n\n    #In-place compression of matrix and vector\n    GT.compress!(b_alloc,b,b_cache)\n    GT.compress!(A_alloc,A,A_cache)\n\n    #Update the nonlinear problem object\n    #Here, we computed the residual and Jacobian simultaneously,\n    #but this API also allows to compute them separately.\n    if PS.residual(problem) !== nothing\n        problem = PS.update(problem,residual=b)\n    end\n    if PS.jacobian(problem) !== nothing\n        problem = PS.update(problem,jacobian=A)\n    end\n\n    problem\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Assembly loop","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function fill_residual_and_jacobian!(state,allocs,face_point_∇uh)\n    (;A_alloc,b_alloc,Auu,bu) = allocs\n    (;example) = state\n    (;Ω,) = example\n\n    #Reset allocations\n    GT.reset!(b_alloc)\n    GT.reset!(A_alloc)\n\n    #Loop over the faces of the domain\n    for face in 1:GT.num_faces(Ω)\n\n        #Compute face tensors\n        dofs = face_tensors!(Auu,bu,face,state,face_point_∇uh) # Defined later\n\n        #Add face contribution to global allocation\n        GT.contribute!(b_alloc,bu,dofs)\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n    end\n\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Compute local Jacobian and residual","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function face_tensors!(Auu,bu,face,state,face_point_∇uh)\n\n    (;example,integration,interpolation) = state\n\n    #Define flux and its derivative\n    q = 3\n    flux(∇u) = norm(∇u)^(q-2) * ∇u\n    dflux(∇du,∇u) = (q-2)*norm(∇u)^(q-4)*(∇u⋅∇du)*∇u+norm(∇u)^(q-2)*∇du\n\n    #Get quantities at current face\n    npoints = integration.face_npoints(face)\n    point_J = integration.face_point_J(face)\n    point_dV = integration.face_point_dV(face)\n    point_dof_∇s = interpolation.face_point_dof_∇s(face)\n    point_∇uh = face_point_∇uh(face)\n    dofs = interpolation.face_dofs(face)\n\n    #Reset face matrix and vector\n    fill!(Auu,zero(eltype(Auu)))\n    fill!(bu,zero(eltype(bu)))\n\n    #Loop over integration points\n    for point in 1:npoints\n\n        #Get quantities at current integration point\n        J = point_J(point)\n        dV = point_dV(point,J)\n        dof_∇s = point_dof_∇s(point,J)\n        ∇uh = point_∇uh(point,J)\n\n        #Fill in face matrix and vector\n        for (i,dofi) in enumerate(dofs)\n            ∇v = dof_∇s(i)\n            bu[i] += flux(∇uh)⋅∇v*dV\n            for (j,dofj) in enumerate(dofs)\n                ∇du = dof_∇s(j)\n                Auu[i,j] += dflux(∇du,∇uh)⋅∇v*dV\n            end\n        end\n    end\n\n    #Return dof ids for this face\n    dofs\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Solve and visualize results","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function solve_and_visualize(state)\n    (;problem,example) = state\n    (;uh,file,Ω) = example\n\n    #Setup solver\n    solver = PS.newton_raphson(problem,verbose=true)\n\n    #Get the lazy solver history\n    solver_history = PS.history(solver)\n\n    #Visualize\n    color = Makie.Observable(uh)\n    fig = Makie.plot(Ω;color,strokecolor=:black)\n    fn = joinpath(@__DIR__,\"fig_pt_plaplacian.gif\")\n    Makie.record(fig,file,solver_history;framerate=2) do s\n        color[] = uh\n    end\nend","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Final program.","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"function main(;kwargs...)\n    state1 = setup_example(;kwargs...)\n    state2 = setup_integration_accessors(state1)\n    state3 = setup_interpolation_accessors(state2)\n    state4 = setup_nonlinear_problem(state3)\n    solve_and_visualize(state4)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"Run it for a 2d case","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"file = joinpath(@__DIR__,\"p_laplacian_manual.gif\")\nmain(;file)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"","category":"page"},{"location":"src_md/example_p_laplacian_manual/","page":"p-Laplacian (manual assembly)","title":"p-Laplacian (manual assembly)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#API","page":"API","title":"API","text":"","category":"section"},{"location":"reference/","page":"API","title":"API","text":"Modules = [GalerkinToolkit]","category":"page"},{"location":"reference/#GalerkinToolkit.AbstractDomain","page":"API","title":"GalerkinToolkit.AbstractDomain","text":"abstract type AbstractDomain{A} <: AbstractType end\n\nAbstract type representing a subset of mathbbR^d, typically din0123. Domains are defined using an underlying computational mesh. A is an (abstract) type indicating on which type of mesh this domain is defined.\n\nSee also AbstractMesh.\n\nLevel\n\nBeginner\n\nBasic constructors\n\nunit_simplex\nunit_n_cube\ndomain\ninterior\nboundary\nskeleton\n\nBasic queries\n\nnum_dims\nnum_ambient_dims\nnum_codims\nis_axis_aligned\nis_simplex\nis_n_cube\nis_unit_n_cube\nis_unit_simplex\nis_unitary\nbounding_box\nvertex_permutations\nmesh\nfaces\ninverse_faces\noptions\nis_boundary\nface_around\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceDomain","page":"API","title":"GalerkinToolkit.AbstractFaceDomain","text":"abstract type AbstractFaceDomain <: AbstractDomain{AbstractMesh} end\n\nA domain defined on a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\nBasic constructors\n\nunit_simplex\nunit_n_cube\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceSpace","page":"API","title":"GalerkinToolkit.AbstractFaceSpace","text":"abstract type AbstractFaceSpace <: AbstractSpace{AbstractMesh} end\n\nLike AbstractSpace, but for a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceTopology","page":"API","title":"GalerkinToolkit.AbstractFaceTopology","text":"abstract type AbstractFaceTopology <: AbstractTopology end\n\nLike AbstractTopology, but for a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractMesh","page":"API","title":"GalerkinToolkit.AbstractMesh","text":"abstract type AbstractMesh <: AbstractType end\n\nAbstract type representing a triangulation of a subset of mathbbR^d, typically din0123, plus metadata useful in finite element computations, such as physical groups for imposing boundary conditions.\n\nNotation\n\nEach of of the elements of the triangulation is referred to as a face. A mesh can contain faces of different dimensions. A mesh might or might not represent a cell complex (all possible low dimensional faces are present in the mesh), but it is often assumed that it represents a cell complex.\n\nLevel\n\nBeginner\n\nBasic constructors\n\nmesh\nchain\nmesh_from_msh\nmesh_from_space\ncartesian_mesh\ncomplexify\nsimplexify\n\nBasic queries\n\nnum_dims\nnum_ambient_dims\nnum_codims\nnum_faces\nnum_nodes\nnode_coordinates\nface_nodes\nface_reference_id\nreference_spaces\nperiodic_nodes\nphysical_faces\ngeometries\noutward_normals\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractPMesh","page":"API","title":"GalerkinToolkit.AbstractPMesh","text":"\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractQuadrature","page":"API","title":"GalerkinToolkit.AbstractQuadrature","text":"abstract type AbstractQuadrature\n\nBasic queries\n\ndomain\ncoordinates\nweights\nnum_points\nface_reference_id\nreference_quadratures\n\nBasic constructors\n\nquadrature\nduffy_quadrature\ntensor_product_quadrature\nnode_quadrature\n\nSupertype hierarchy\n\nAbstractQuadrature <: GT.AbstractType\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractSpace","page":"API","title":"GalerkinToolkit.AbstractSpace","text":"abstract type AbstractSpace{A} <: AbstractType end\n\nAbstract type representing a finite element space.  A is an (abstract) type  indicating on which type of mesh this domain is defined.\n\nLevel\n\nBasic\n\nBasic constructors\n\nlagrange_space raviart_thomas_space\n\nBasic queries\n\ndomain\nnum_dofs\nface_dofs\nface_nodes\nface_reference_id\nreference_spaces\ngeometry_own_dofs\ngeometry_own_dofs_permutations\n\nAdditional queries\n\nFor spaces, used as reference spaces in AbstractMesh specializations.\n\nnum_nodes\ninterior_nodes\ninterior_nodes_permutations\ngeometry_interior_nodes\ngeometry_interior_nodes_permutations\ngeometry_nodes\ngeometry_nodes_permutations\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractTopology","page":"API","title":"GalerkinToolkit.AbstractTopology","text":"abstract type AbstractTopology\n\nAbstract type representing the incidence relations in a cell complex.\n\nSee also AbstractFaceTopology.\n\nLevel\n\nIntermediate\n\nBasic constructors\n\ntopology\n\nBasic queries\n\nface_incidence\nface_reference_id\nface_permutation_ids\nreference_topologies\nvertex_permutations\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractType","page":"API","title":"GalerkinToolkit.AbstractType","text":"abstract type AbstractType end\n\nParent of all types defined in GalerkinToolkit.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.Options","page":"API","title":"GalerkinToolkit.Options","text":"struct Options{...} <: AbstractType\n\nType of the objects returned by function options. All properties and type parameters are private.\n\nBasic queries\n\nreference_int_type\nint_type\nglobal_int_type\nreal_type\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.boundary","page":"API","title":"GalerkinToolkit.boundary","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.bounding_box","page":"API","title":"GalerkinToolkit.bounding_box","text":"p0,p1 = bounding_box(x)\n\nReturn a tuple of two vectors, where the vectors p0 and p1 define the span of the bounding box of x.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.cartesian_mesh-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.cartesian_mesh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.chain-Tuple{}","page":"API","title":"GalerkinToolkit.chain","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.complexify","page":"API","title":"GalerkinToolkit.complexify","text":"complexify(x)\n\nConvert x into a mesh representing a cell complex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.coordinates","page":"API","title":"GalerkinToolkit.coordinates","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.domain","page":"API","title":"GalerkinToolkit.domain","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.duffy_quadrature-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.duffy_quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.face_around","page":"API","title":"GalerkinToolkit.face_around","text":"face_around(x)\n\nReturn an integer that allows to break ties when faces in x need to point to faces around of one dimension higher. Return nothing if x does not break such ties.\n\nNote: This function will eventually return a vector of integers.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_dofs","page":"API","title":"GalerkinToolkit.face_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_incidence","page":"API","title":"GalerkinToolkit.face_incidence","text":"face_incidence(x,d)\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_nodes","page":"API","title":"GalerkinToolkit.face_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_permutation_ids","page":"API","title":"GalerkinToolkit.face_permutation_ids","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_reference_id","page":"API","title":"GalerkinToolkit.face_reference_id","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.faces","page":"API","title":"GalerkinToolkit.faces","text":"faces(x)\n\nReturn the subset of face ids in mesh(x) of dimension num_dims(x) defining the domain x. This is effectively the map from domain face id to mesh face id.\n\nSee also inverse_faces.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometries","page":"API","title":"GalerkinToolkit.geometries","text":"geometries(x,d)\ngeometries(x,Val(d))\n\nReturn a vector of domains representing the geometrical entities of x of dimension d. The returned domains and x are defined on the same mesh. That is, faces(geometries(x,1)[2]) are the face ids in mesh(x) representing the second edge of x.\n\nNotation\n\ngeometries(x,Val(0)) are referred to as the vertices of x. geometries(x,Val(1)) are referred to as the edges of x. geometries(x,Val(d)) are referred to as the d-faces of x.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_interior_nodes","page":"API","title":"GalerkinToolkit.geometry_interior_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_interior_nodes_permutations","page":"API","title":"GalerkinToolkit.geometry_interior_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_nodes","page":"API","title":"GalerkinToolkit.geometry_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_nodes_permutations","page":"API","title":"GalerkinToolkit.geometry_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_own_dofs","page":"API","title":"GalerkinToolkit.geometry_own_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_own_dofs_permutations","page":"API","title":"GalerkinToolkit.geometry_own_dofs_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.global_int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.global_int_type","text":"global_int_type(options::Options)\n\nReturn the type of the integers used to enumerate global quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.int_type","text":"int_type(options::Options)\n\nReturn the default integer type used in the computation except for reference and global quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.interior","page":"API","title":"GalerkinToolkit.interior","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.interior_node_permutations-Tuple{GalerkinToolkit.LagrangeFaceSpace}","page":"API","title":"GalerkinToolkit.interior_node_permutations","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.interior_nodes","page":"API","title":"GalerkinToolkit.interior_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.interior_nodes_permutations","page":"API","title":"GalerkinToolkit.interior_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.inverse_faces","page":"API","title":"GalerkinToolkit.inverse_faces","text":"inverse_faces(x)\n\nReturn the inverse integer mas of faces(x). This is effectively the map from mesh face id to domain face id. Mesh faces not present in the domain, receive an invalid index id.\n\nSee also faces.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_axis_aligned","page":"API","title":"GalerkinToolkit.is_axis_aligned","text":"is_axis_aligned(x)\n\nTrue if x is a unit simplex or a unit cube.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_boundary","page":"API","title":"GalerkinToolkit.is_boundary","text":"is_boundary(x)\n\nTrue if x represent an (internal) boundary. Faces in an internal boundary \"point\" to only of the two faces around of a dimension higher.\n\nSee also face_around.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_n_cube","page":"API","title":"GalerkinToolkit.is_n_cube","text":"is_n_cube(x)\n\nTrue if x is a n-cube (hypercube).\n\nSee also is_simplex, is_unit_simplex, is_unit_n_cube.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_simplex","page":"API","title":"GalerkinToolkit.is_simplex","text":"is_simplex(x)\n\nTrue if x is a simplex.\n\nSee also is_n_cube, is_unit_simplex, is_unit_n_cube.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unit_n_cube","page":"API","title":"GalerkinToolkit.is_unit_n_cube","text":"is_unit_n_cube(x)\n\nTrue if x is a unit n-cube.\n\nSee also is_n_cube, is_unit_simplex, is_simplex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unit_simplex","page":"API","title":"GalerkinToolkit.is_unit_simplex","text":"is_unit_simplex(x)\n\nTrue if x is a unit simplex.\n\nSee also is_n_cube, is_unit_n_cube, is_simplex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unitary","page":"API","title":"GalerkinToolkit.is_unitary","text":"is_unitary(x)\n\nTrue bounding_box(x) coincides with a unit n-cube.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.lagrange_space","page":"API","title":"GalerkinToolkit.lagrange_space","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.mesh-Tuple{GalerkinToolkit.Chain}","page":"API","title":"GalerkinToolkit.mesh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_msh-Tuple{Any}","page":"API","title":"GalerkinToolkit.mesh_from_msh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_space","page":"API","title":"GalerkinToolkit.mesh_from_space","text":"mesh_from_space(space)\n\nReturn the mesh induced by space. For instance, a (high order) Lagrange space can be interpreted as a mesh using this function.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.node_coordinates","page":"API","title":"GalerkinToolkit.node_coordinates","text":"node_coordinates(x)\n\nReturn the vector of node coordinates associated with `x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.node_permutations-Tuple{GalerkinToolkit.LagrangeFaceSpace}","page":"API","title":"GalerkinToolkit.node_permutations","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.node_quadrature","page":"API","title":"GalerkinToolkit.node_quadrature","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_ambient_dims","page":"API","title":"GalerkinToolkit.num_ambient_dims","text":"num_ambient_dims(x)\n\nReturn the ambient dimension where object x lives.\n\nSee also num_codims, num_dims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_codims","page":"API","title":"GalerkinToolkit.num_codims","text":"num_codims(x)\n\nReturn num_ambient_dims(x)-num_dims(x).\n\nSee also num_ambient_dims, num_dims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_dims","page":"API","title":"GalerkinToolkit.num_dims","text":"num_dims(x)\n\nReturn the parametric dimension of x.\n\nSee also num_ambient_dims, num_codims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_dofs","page":"API","title":"GalerkinToolkit.num_dofs","text":"num_dofs(x)\n\nReturn the number of degrees of freedom of x.\n\nSee also num_nodes.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_faces","page":"API","title":"GalerkinToolkit.num_faces","text":"num_faces(x)\nnum_faces(x,d)\n\nReturn the number of faces  of dimension d in mesh(x). If d is omitted, return a vector with the number of faces in each dimension, starting from dimension 0 up to num_dims(x).\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_nodes","page":"API","title":"GalerkinToolkit.num_nodes","text":"num_nodes(x)\n\nReturn the number of nodes of x.\n\nSee also num_dofs.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_points","page":"API","title":"GalerkinToolkit.num_points","text":"num_points(x)\n\nReturn the number of integration points in x.\n\nSee also num_nodes.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.options-Tuple{}","page":"API","title":"GalerkinToolkit.options","text":"options(;kwargs...) -> Options\n\nCreate an object representing the default options for the current simulation. This object can be used as an optional argument in several object constructors in GalerkinToolkit, such as the mesh constructors cartesian_mesh and mesh_from_msh. In this case, the computations using the generated mesh, will use the given options by default.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.outward_normals","page":"API","title":"GalerkinToolkit.outward_normals","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.periodic_nodes","page":"API","title":"GalerkinToolkit.periodic_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.physical_faces","page":"API","title":"GalerkinToolkit.physical_faces","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.physical_names-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.physical_names","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.push","page":"API","title":"GalerkinToolkit.push","text":"push(a,ai)\n\nLike push!, but creates a new object to store the result.  This function is used to push to immutable collections such as tuples.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.quadrature-Tuple{GalerkinToolkit.AbstractFaceDomain, Any}","page":"API","title":"GalerkinToolkit.quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.raviart_thomas_space","page":"API","title":"GalerkinToolkit.raviart_thomas_space","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.real_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.real_type","text":"real_type(options::Options)\n\nReturn the default real type used in the computation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.reference_int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.reference_int_type","text":"reference_int_type(options::Options)\n\nReturn the type of the integers used to enumerate reference quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.reference_quadratures","page":"API","title":"GalerkinToolkit.reference_quadratures","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_spaces","page":"API","title":"GalerkinToolkit.reference_spaces","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_topologies","page":"API","title":"GalerkinToolkit.reference_topologies","text":"reference_topologies(x)\nreference_topologies(x,d)\nreference_topologies(x,Val(d))\n\nReturn the list (a vector or a tuple) of reference topologies in x of dimension d. If the second argument is omitted, return a tuple with the reference topologies in each dimension, starting from dimension 0 up to num_dims(x).\n\nSee also face_reference_id.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.shape_functions-Tuple{GalerkinToolkit.AbstractSpace}","page":"API","title":"GalerkinToolkit.shape_functions","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.simplexify","page":"API","title":"GalerkinToolkit.simplexify","text":"simplexify(x)\n\nConvert x into a mesh made of simplex cells.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.skeleton","page":"API","title":"GalerkinToolkit.skeleton","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.tabulator-Tuple{GalerkinToolkit.AbstractSpace}","page":"API","title":"GalerkinToolkit.tabulator","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.tensor_product_quadrature-Tuple{GalerkinToolkit.AbstractFaceDomain, Any}","page":"API","title":"GalerkinToolkit.tensor_product_quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.topology-Tuple{GalerkinToolkit.AbstractMesh}","page":"API","title":"GalerkinToolkit.topology","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.unit_n_cube-Tuple{Any}","page":"API","title":"GalerkinToolkit.unit_n_cube","text":"unit_n_cube(d)\nunit_n_cube(Val(d))\n\nReturn an object representing a unit d-cube.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.unit_simplex-Tuple{Any}","page":"API","title":"GalerkinToolkit.unit_simplex","text":"unit_simplex(d)\nunit_simplex(Val(d))\n\nReturn an object representing a unit simplex of dimension d.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.val_parameter-Tuple{Any}","page":"API","title":"GalerkinToolkit.val_parameter","text":"val_parameter(a)\n\nFor a::Val{A} it returns A. Otherwise, it returns a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.vertex_permutations","page":"API","title":"GalerkinToolkit.vertex_permutations","text":"vertex_permutations(x)\n\nReturn a list of permutations representing the admissible re-labelings of the vertices of x.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.weights","page":"API","title":"GalerkinToolkit.weights","text":"\n\n\n\n","category":"function"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"EditURL = \"../src_jl/example_transient_heat_eq_manual.jl\"","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/#Transient-heat-equation-(manual-assembly)","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"","category":"section"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"(Image: )","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/#Implementation","page":"Transient heat equation (manual assembly)","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Import other dependencies","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport WriteVTK\nimport FileIO # hide","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Main program. The individual functions are defined later.","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function main(;mesh_size=0.02,R=0.15,T=2,N=100)\n    params = (;mesh_size,R,T,N)\n    state0 = setup_mesh(params)\n    state1 = setup_example(state0)\n    state2 = setup_accessors(state1)\n    state3 = assemble_matrices(state2)\n    state4 = setup_time_steps(state3)\n    time_steps_makie(state4)\n    time_steps_vtk(state4)\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Setup the mesh with GMSH","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function setup_mesh(state)\n    (;mesh_size,R) = state\n    mesh = GT.with_gmsh() do gmsh\n        R = 0.15\n        dim = 2\n        rect_tag = gmsh.model.occ.add_rectangle(0,0,0,1,1)\n        circle_tag = gmsh.model.occ.add_circle(0.5,0.5,0,R)\n        circle_curve_tag = gmsh.model.occ.add_curve_loop([circle_tag])\n        circle_surf_tag = gmsh.model.occ.add_plane_surface([circle_curve_tag])\n        gmsh.model.occ.cut([(dim,rect_tag)],[(dim,circle_surf_tag)]);\n        gmsh.model.occ.synchronize()\n        domain_tags = [1]\n        outer_tags = [6,7,8,9]\n        inner_tags = [5]\n        gmsh.model.model.add_physical_group(dim,domain_tags,-1,\"domain\")\n        gmsh.model.model.add_physical_group(dim-1,outer_tags,-1,\"outer\")\n        gmsh.model.model.add_physical_group(dim-1,inner_tags,-1,\"inner\")\n        gmsh.option.setNumber(\"Mesh.MeshSizeMax\",mesh_size)\n        gmsh.model.mesh.generate(dim)\n        GT.mesh_from_gmsh(gmsh)\n    end\n    (;mesh,state...)\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Setup the quantities for this example","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function setup_example(state)\n    (;mesh) = state\n    #Domains\n    Ω = GT.interior(mesh;physical_names=[\"domain\"])\n    Γ1 = GT.boundary(mesh;physical_names=[\"outer\"])\n    Γ2 = GT.boundary(mesh;physical_names=[\"inner\"])\n    Γ = GT.piecewise_domain(Γ1,Γ2)\n    #Space\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γ)\n    #Time dependent dirichlet field\n    uh = GT.semi_discrete_field(Float64,V) do t,uht\n        α = sin(3*pi*t)\n        g1 = GT.analytical_field(x->0.0,Ω)\n        g2 = GT.analytical_field(x->1.0*α,Ω)\n        g = GT.piecewise_field(g1,g2)\n        GT.interpolate_dirichlet!(g,uht)\n    end\n    #Initial condition\n    u0 = GT.analytical_field(x->0.0,Ω)\n    (;Ω,V,uh,u0,state...)\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Create the accessor functions used later for integration","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function setup_accessors(state)\n    (;Ω,V) = state\n    degree = 2*GT.order(V)\n    dΩ = GT.measure(Ω,degree)\n    face_point_x = GT.coordinate_accessor(dΩ)\n    face_point_J = GT.jacobian_accessor(dΩ)\n    face_point_dV = GT.weight_accessor(dΩ)\n    face_npoints = GT.num_points_accessor(dΩ)\n    face_dofs = GT.dofs_accessor(V,Ω)\n    face_point_dof_s = GT.shape_function_accessor(GT.value,V,dΩ)\n    face_point_dof_∇s = GT.shape_function_accessor(ForwardDiff.gradient,V,dΩ)\n    accessors = (;face_point_x,face_point_J,face_point_dV,\n                 face_npoints,face_dofs,face_point_dof_s,face_point_dof_∇s)\n    (;accessors,state...)\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Assemble the problem matrices","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function assemble_matrices(state)\n    (;V,Ω,accessors) = state\n\n    #Allocate auxiliary face matrix and vector\n    n = GT.max_num_reference_dofs(V)\n    T = Float64\n    Ke = zeros(T,n,n)\n    Me = zeros(T,n,n)\n\n    #Allocate space for the global matrices\n    ff = (GT.FREE,GT.FREE)\n    fd = (GT.FREE,GT.DIRICHLET)\n    K_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet=ff)\n    M_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet=ff)\n    Kfd_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet=fd)\n    Mfd_alloc = GT.allocate_matrix(T,V,V,Ω;free_or_dirichlet=fd)\n\n    allocs = (;K_alloc,M_alloc,Kfd_alloc,Mfd_alloc,Ke,Me)\n\n    #Assembly loop (defined later)\n    assembly_loop!(state,allocs)\n\n    #Compress matrices\n    K = GT.compress(K_alloc)\n    Kfd = GT.compress(Kfd_alloc)\n    M = GT.compress(M_alloc)\n    Mfd = GT.compress(Mfd_alloc)\n\n    (;K,M,Kfd,Mfd,state...)\n\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Manual assembly loop","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function assembly_loop!(state,allocs)\n    (;Ω,accessors) = state\n    (;K_alloc,M_alloc,Kfd_alloc,Mfd_alloc,Ke,Me) = allocs\n\n    #Reset allocations\n    GT.reset!(K_alloc)\n    GT.reset!(Kfd_alloc)\n    GT.reset!(M_alloc)\n    GT.reset!(Mfd_alloc)\n\n    C = 10\n\n    #Loop over the faces of the domain\n    for face in 1:GT.num_faces(Ω)\n\n        #Reset element matrices\n        fill!(Ke,zero(eltype(Ke)))\n        fill!(Me,zero(eltype(Me)))\n\n        #Get quantities at current face\n        npoints = accessors.face_npoints(face)\n        point_x = accessors.face_point_x(face)\n        point_J = accessors.face_point_J(face)\n        point_dV = accessors.face_point_dV(face)\n        point_dof_s = accessors.face_point_dof_s(face)\n        point_dof_∇s = accessors.face_point_dof_∇s(face)\n        dofs = accessors.face_dofs(face)\n\n        #Loop over integration points\n        for point in 1:npoints\n\n            #Get quantities at current integration point\n            x = point_x(point)\n            J = point_J(point)\n            dV = point_dV(point,J)\n            dof_s = point_dof_s(point)\n            dof_∇s = point_dof_∇s(point,J)\n\n            #Fill in face matrix and vector\n            for (i,dofi) in enumerate(dofs)\n                v = dof_s(i)\n                ∇v = dof_∇s(i)\n                for (j,dofj) in enumerate(dofs)\n                    u = dof_s(j)\n                    ∇u = dof_∇s(j)\n                    Ke[i,j] += ∇v⋅∇u*dV\n                    Me[i,j] += C*v*u*dV\n                end\n            end\n        end\n\n        #Add face contribution to global allocations\n        GT.contribute!(K_alloc,Ke,dofs,dofs)\n        GT.contribute!(Kfd_alloc,Ke,dofs,dofs)\n        GT.contribute!(M_alloc,Me,dofs,dofs)\n        GT.contribute!(Mfd_alloc,Me,dofs,dofs)\n    end\n\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Perform operations that are shared between time steps.","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function setup_time_steps(state)\n    (;T,N,Ω,uh,K,M,Kfd,Mfd) = state\n    #Generate linear problem\n    dt = T/N\n    t = 0\n    A = M + dt * K\n    x = GT.free_values(uh)\n    b = similar(x)\n    p = PS.linear_problem(x,A,b)\n    #Generate solver object.\n    #This factorizes the matrix\n    s = PS.LinearAlgebra_lu(p)\n    (;s,p,b,dt,state...)\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Do the time steps and record the solution with Makie.","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function time_steps_makie(state)\n    (;Ω,uh,u0,s,p,b,N,dt,M,Mfd,Kfd) = state\n\n    #Initial condition\n    t0 = 0\n    uht = uh(t0)\n    GT.interpolate_free!(u0,uht)\n    x = GT.free_values(uht)\n    xd = GT.dirichlet_values(uht)\n\n    #Setup Makie scene\n    axis = (aspect = Makie.DataAspect(),)\n    color = Makie.Observable(uht)\n    fig = Makie.Figure()\n    ax,sc = Makie.plot(fig[1,1],Ω;color,axis,colorrange=(-1,1))\n    Makie.Colorbar(fig[1,2],sc)\n\n    #Record Makie scene\n    fn = \"fig_transient_heat_equation_manual.gif\"\n    file = joinpath(@__DIR__,fn)\n    Makie.record(fig,file,1:N) do step\n        #Compute current time\n        t = dt*step + t0\n        #Setup rhs\n        mul!(b,M,x)\n        mul!(b,Mfd,xd,1,1)\n        uht = uh(t)\n        xd = GT.dirichlet_values(uht)\n        mul!(b,Mfd,xd,-1,1)\n        mul!(b,Kfd,xd,-dt,1)\n        #Update solver with the new rhs and solve\n        #This is only a solver substitution,\n        #not a full factorization\n        s = PS.update(s,rhs=b)\n        s = PS.solve(s)\n        #Get solution at the end of the step\n        x = PS.solution(s)\n        #Update Makie scene\n        color[] = GT.solution_field(uht,x)\n    end\n\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Do the time steps and record the solution with VTK.","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"function time_steps_vtk(state)\n    (;Ω,uh,u0,s,p,b,N,dt,M,Mfd,Kfd) = state\n\n    #Initial condition\n    t0 = 0\n    uht = uh(t0)\n    GT.interpolate_free!(u0,uht)\n    x = GT.free_values(uht)\n    xd = GT.dirichlet_values(uht)\n\n    #Create the GT plot object\n    plt = GT.plot(Ω)\n\n    #Save Paraview collection\n    fn = \"vtk_transient_heat_equation_manual\"\n    file = joinpath(@__DIR__,fn)\n    WriteVTK.paraview_collection(file,plt) do pvd\n        for step in 1:N\n            t = dt*step + t0\n            mul!(b,M,x)\n            mul!(b,Mfd,xd,1,1)\n            uht = uh(t)\n            xd = GT.dirichlet_values(uht)\n            mul!(b,Mfd,xd,-1,1)\n            mul!(b,Kfd,xd,-dt,1)\n            s = PS.update(s,rhs=b)\n            s = PS.solve(s)\n            x = PS.solution(s)\n            uht = GT.solution_field(uht,x)\n            #Save vtk file for this step\n            WriteVTK.vtk_grid(\"$(file)_$(step)\",plt) do plt\n                GT.plot!(plt,uht;label=\"uh\")\n                pvd[step] = plt\n            end\n        end\n    end\n\nend","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"Call the main function","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"main()","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"(Image: )","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"","category":"page"},{"location":"src_md/example_transient_heat_eq_manual/","page":"Transient heat equation (manual assembly)","title":"Transient heat equation (manual assembly)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"refindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"refindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GalerkinToolkit","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#What","page":"Home","title":"What","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package aims at providing a fully-fledged finite-element toolbox in pure Julia, with support for different computing systems from laptops to supercomputers and GPUs.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"NB. This package is work in progress; a proof-of-concept API is already available (for CPUs). The package is not production ready at this point. Planned performance and documentation improvements are needed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warn: Warn\nTODO elaborary more","category":"page"},{"location":"#Why","page":"Home","title":"Why","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package follows a new approach to implement finite-element methods based on the lessons learned in the Gridap project.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warn: Warn\nTODO elaborary more","category":"page"}]
}
