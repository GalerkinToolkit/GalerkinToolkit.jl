var documenterSearchIndex = {"docs":
[{"location":"pdes_automatic/elasticity/","page":"Linear elasticity","title":"Linear elasticity","text":"EditURL = \"elasticity.jl\"","category":"page"},{"location":"pdes_automatic/elasticity/#Linear-elasticity","page":"Linear elasticity","title":"Linear elasticity","text":"","category":"section"},{"location":"pdes_automatic/elasticity/","page":"Linear elasticity","title":"Linear elasticity","text":"warning: Warning\nTODOProblem statement\nHide call\nUse Voigt notation instead of using Tensors.jl?","category":"page"},{"location":"pdes_automatic/elasticity/","page":"Linear elasticity","title":"Linear elasticity","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport GLMakie as Makie\nimport ForwardDiff\nimport StaticArrays\nimport Tensors\nusing LinearAlgebra\nimport FileIO # hide\n\ndomain = (0,1,0,0.2)\ncells = (20,5)\nD = length(cells)\nmesh = GT.cartesian_mesh(domain,cells)\nΩ = GT.interior(mesh)\nΓ = GT.boundary(mesh;physical_names=[\"1-face-3\"])\nf = GT.analytical_field(x->StaticArrays.SVector(0,-1),Ω)\nconst E = 1\nconst ν = 0.33\nconst λ = (E*ν)/((1+ν)*(1-2*ν))\nconst μ = E/(2*(1+ν))\nσ(ε) = λ*tr(ε)*one(ε) + 2*μ*ε\norder = 2\nV = GT.lagrange_space(Ω,order;tensor_size=Val((D,)),dirichlet_boundary=Γ)\nuhd = GT.dirichlet_field(Float64,V)\ndΩ = GT.measure(Ω,2*order)\n∇ = ForwardDiff.jacobian\n#TODO this function should be better in Tensors.jl\nfunction symmetrize(m::StaticArrays.SMatrix{2,2})\n    T = eltype(m)\n    Tensors.SymmetricTensor{2,2,T}((m[1,1],0.5*(m[2,1]+m[1,2]),m[2,2]))\nend\n#TODO hide GT.call\nε(u,x) = GT.call(symmetrize,∇(u,x))\na(u,v) = GT.∫(x-> GT.call(Tensors.:⊡,ε(v,x),GT.call(σ,ε(u,x))), dΩ)\nl(v) = GT.∫(x-> v(x)⋅f(x), dΩ)\np = GT.linear_problem(uhd,a,l)\ns = PS.LinearAlgebra_lu(p)\ns = PS.solve(s)\nuh = GT.solution_field(uhd,s)\nMakie.plot(Ω;color=x->norm(uh(x)),warp_by_vector=uh,warp_scale=0.002)\nMakie.plot!(Ω;color=nothing,strokecolor=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_pt_linelast.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"pdes_automatic/elasticity/","page":"Linear elasticity","title":"Linear elasticity","text":"(Image: )","category":"page"},{"location":"pdes_automatic/elasticity/","page":"Linear elasticity","title":"Linear elasticity","text":"","category":"page"},{"location":"pdes_automatic/elasticity/","page":"Linear elasticity","title":"Linear elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"EditURL = \"p_laplacian.jl\"","category":"page"},{"location":"pdes_automatic/p_laplacian/#p-Laplacian","page":"p-Laplacian","title":"p-Laplacian","text":"","category":"section"},{"location":"pdes_automatic/p_laplacian/#Problem-statement","page":"p-Laplacian","title":"Problem statement","text":"","category":"section"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Solve the following p-Laplacian equation on the unit square,","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"leftlbrace\nbeginaligned\n-nabla cdot left( nabla u^q-2  nabla u right) = f textin Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"with f=1 and g=0 and q=3.","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Solve it with a piece-wise bi-linear Lagrange interpolation, and visualize the result.","category":"page"},{"location":"pdes_automatic/p_laplacian/#Implementation","page":"p-Laplacian","title":"Implementation","text":"","category":"section"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"using LinearAlgebra","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Import other dependencies","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Code","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"domain = (0,1,0,1)\ncells = (10,10)\nmesh = GT.cartesian_mesh(domain,cells)\ndirichlet_tag = \"dirichlet\"\nGT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\nΩ = GT.interior(mesh)\nΓd = GT.boundary(mesh;physical_names=[dirichlet_tag])\nk = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\ng = GT.analytical_field(x->0,Ω)\nf = GT.analytical_field(x->1,Ω)\nconst q = 3\nflux(∇u) = norm(∇u)^(q-2) * ∇u\ndflux(∇du,∇u) = (q-2)*norm(∇u)^(q-4)*(∇u⋅∇du)*∇u+norm(∇u)^(q-2)*∇du\nuh = GT.rand_field(Float64,V)\nGT.interpolate_dirichlet!(g,uh)\ndΩ = GT.measure(Ω,2*k)\n∇ = ForwardDiff.gradient\nres(u) = v -> GT.∫( x-> ∇(v,x)⋅GT.call(flux,∇(u,x)) - f(x)*v(x) , dΩ)\njac(u) = (du,v) -> GT.∫( x-> ∇(v,x)⋅GT.call(dflux,∇(du,x),∇(u,x)) , dΩ)\np = GT.nonlinear_problem(uh,res,jac)\ns = PS.newton_raphson(p,verbose=true)\ns = PS.solve(s)\nuh = GT.solution_field(uh,s)\nMakie.plot(Ω;color=uh,strokecolor=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_pt_plaplacian.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Now, by showing the intermediate results in the iteration process","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"uh = GT.rand_field(Float64,V)\nGT.interpolate_dirichlet!(g,uh)\np = GT.nonlinear_problem(uh,res,jac)\ns = PS.newton_raphson(p)\ncolor = Makie.Observable(uh)\nfig = Makie.plot(Ω;color,strokecolor=:black)\nfn = joinpath(@__DIR__,\"fig_pt_plaplacian.gif\")\nMakie.record(fig,fn,PS.history(s);framerate=2) do s\n    color[] = GT.solution_field(uh,s)\nend\nnothing # hide","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"","category":"page"},{"location":"pdes_automatic/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"developers_guide/#Developers-guide","page":"Developers guide","title":"Developers guide","text":"","category":"section"},{"location":"developers_guide/#Performance-Benchmarks","page":"Developers guide","title":"Performance Benchmarks","text":"","category":"section"},{"location":"developers_guide/","page":"Developers guide","title":"Developers guide","text":"There is a benchmark suite defined in GalerkinToolkitExamples/benchmarks. This uses BenchmarkTools.jl to perform the timings and github-action-benchmark to collect the results and store them in the benchmarks branch. Upon merging of a PR, and after the docs have built, the benchmark results are copied from the benchmarks branch into the gh-pages branch. This is required to prevent overwriting of the previous results by docs deployment etc.","category":"page"},{"location":"developers_guide/","page":"Developers guide","title":"Developers guide","text":"Graphs of performance changes over time (per commit hash) can then be viewed here: https://galerkintoolkit.github.io/GalerkinToolkit.jl/dev/bench/.","category":"page"},{"location":"developers_guide/","page":"Developers guide","title":"Developers guide","text":"The github action can be configured (in .github/workflows/CI.yml, job benchmark) to fail if the performance change is beyond a given threshold. Look for the alert-threshold: and fail-on-alert: keys.","category":"page"},{"location":"developers_guide/","page":"Developers guide","title":"Developers guide","text":"More benchmarks can be added (or existing ones modified) in GalerkinToolkitExamples/benchmarks/run_benchmarks.jl.","category":"page"},{"location":"pdes_automatic/stokes/","page":"Stokes","title":"Stokes","text":"EditURL = \"stokes.jl\"","category":"page"},{"location":"pdes_automatic/stokes/#Stokes","page":"Stokes","title":"Stokes","text":"","category":"section"},{"location":"pdes_automatic/stokes/","page":"Stokes","title":"Stokes","text":"warning: Warning\nTODOProblem statement\nAllow g1 and g1 to be defined on the boundary\nBuild a pressure field with zero mean","category":"page"},{"location":"pdes_automatic/stokes/","page":"Stokes","title":"Stokes","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport GLMakie as Makie\nimport ForwardDiff\nimport StaticArrays\nimport Tensors\nusing LinearAlgebra\nimport FileIO # hide\n\ndomain = (0,1,0,1)\ncells = (20,20)\nD = length(cells)\nmesh = GT.cartesian_mesh(domain,cells)\nΩ = GT.interior(mesh)\nΓ1 = GT.boundary(mesh;physical_names=[\"1-face-2\"])\nΓ2 = GT.boundary(mesh;physical_names=[\"1-face-1\",\"1-face-3\",\"1-face-4\"])\n#TODO\n#g1 = GT.analytical_field(x->SVector(1,0),Γ1)\n#g2 = GT.analytical_field(x->SVector(0,0),Γ2)\n#g = GT.piecewiese_field(g1,g2)\n#Γ = GT.domain(g)\ng1 = GT.analytical_field(x->StaticArrays.SVector(1,0),Ω)\ng2 = GT.analytical_field(x->StaticArrays.SVector(0,0),Ω)\ng = GT.piecewiese_field(g1,g2)\nΓ = GT.piecewiese_domain(Γ1,Γ2)\norder = 2\nV = GT.lagrange_space(Ω,order;space_type=:Q,tensor_size=Val((D,)),dirichlet_boundary=Γ)\nQ = GT.lagrange_space(Ω,order-1;space_type=:P,dirichlet_boundary=GT.last_dof())\nVxQ = V × Q\nu_field, p_field = 1,2\nuhph_dirichlet = GT.dirichlet_field(Float64,VxQ)\nGT.interpolate_dirichlet!(g,uhph_dirichlet,u_field)\ndΩ = GT.measure(Ω,2*order)\n∇ = ForwardDiff.jacobian\ndiv(u,x) = tr(∇(u,x))\na((u,p),(v,q)) = GT.∫( x-> ∇(v,x)⋅∇(u,x) - div(v,x)*p(x) + q(x)*div(u,x), dΩ)\nl((v,q)) = 0\np = GT.linear_problem(uhph_dirichlet,a,l)\ns = PS.LinearAlgebra_lu(p)\ns = PS.solve(s)\n#TODO\n#uh = GT.solution_field(uhph_dirichlet,s,u_field)\n#ph = GT.solution_field(uhph_dirichlet,s,p_field;zeromean=true)\nuh,ph = GT.solution_field(uhph_dirichlet,s)\nMakie.plot(Ω,color=ph)\nMakie.arrows!(uh;color=x->norm(uh(x)),lengthscale=0.1)\nFileIO.save(joinpath(@__DIR__,\"fig_pt_stokes.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"pdes_automatic/stokes/","page":"Stokes","title":"Stokes","text":"(Image: )","category":"page"},{"location":"pdes_automatic/stokes/","page":"Stokes","title":"Stokes","text":"","category":"page"},{"location":"pdes_automatic/stokes/","page":"Stokes","title":"Stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"EditURL = \"mesh_generation.jl\"","category":"page"},{"location":"tooling/mesh_generation/#Mesh-generation","page":"Mesh generation","title":"Mesh generation","text":"","category":"section"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Dependencies","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"import GalerkinToolkit as GT\nimport PartitionedArrays as PA\nimport GLMakie as Makie\nimport Gmsh\nimport Metis\nimport FileIO # hide\nusing StaticArrays\n\n#TODO no current way of adding this to a recipe\n#https://discourse.julialang.org/t/accessing-axis-in-makie-plot-recipes/66006/1\nMakie.update_theme!(Axis=(;aspect=Makie.DataAspect()))","category":"page"},{"location":"tooling/mesh_generation/#Cartesian-meshes","page":"Mesh generation","title":"Cartesian meshes","text":"","category":"section"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Generate a Cartesian mesh of the 3D domain (01)times(23)times(-11) using 5 cells per direction and visualize it.","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"domain = (0,1,1,3,-1,1)\ncells = (5,5,5)\nmesh = GT.cartesian_mesh(domain,cells)\nMakie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_mg_cm_3d.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"(Image: )","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Generate a Cartesian mesh of the 2D domain (01)times(23) and visualize it.","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"domain = (0,1,2,3)\ncells = (5,5)\nmesh = GT.cartesian_mesh(domain,cells)\nMakie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_mg_cm_2d.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"(Image: )","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Now visualize all objects (vertices, edges, faces) in the mesh.","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Makie.plot(mesh,color=:pink,strokecolor=:blue,shrink=0.6,dim=(0:2))\nFileIO.save(joinpath(@__DIR__,\"fig_mg_cm_2d_a.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"(Image: )","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Now, do not generate low-dimensional objects on the interior of the mesh","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"domain = (0,1,2,3)\ncells = (5,5)\nmesh = GT.cartesian_mesh(domain,cells;complexify=false)\nMakie.plot(mesh,color=:pink,strokecolor=:blue,shrink=0.6,dim=(0:2))\nFileIO.save(joinpath(@__DIR__,\"fig_mg_cm_2d_b.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"(Image: )","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"note: Note\nMost algorithms require working with a polytopal complex (i.e., a mesh containing all low dimensional objects). Thus using the option complexify=false is not recommended, unless you know what you are doing.","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Now, use triangles instead of squares.","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"domain = (0,1,2,3)\ncells = (5,5)\nmesh = GT.cartesian_mesh(domain,cells;simplexify=true)\nMakie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_mg_cm_2d_c.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"(Image: )","category":"page"},{"location":"tooling/mesh_generation/#Gmsh-meshes","page":"Mesh generation","title":"Gmsh meshes","text":"","category":"section"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Read a mesh from a \".msh\" file and visualize it.","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"repodir = joinpath(@__DIR__,\"..\",\"..\",\"..\")\nfn = joinpath(repodir,\"assets\",\"mesh1.msh\")\nmesh = GT.mesh_from_gmsh(fn)\nMakie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_mg_gmsh.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"(Image: )","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Now, define the mesh using GMSH DSL","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"warning: Warning\nTODO","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Now, define the mesh using GMSH julia API","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"warning: Warning\nTODO","category":"page"},{"location":"tooling/mesh_generation/#Parallel-meshes","page":"Mesh generation","title":"Parallel meshes","text":"","category":"section"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Generate a Cartesian mesh of the 2D domain (01)times(23) using 10 cells in each direction. Partitioned it into 2 parts per direction and visualize with face color according to part owner.","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"domain = (0,1,2,3)\ncells_per_dir = (10,10)\nparts_per_dir = (2,2)\nparts = LinearIndices((prod(parts_per_dir),))\npmesh = GT.cartesian_pmesh(domain,cells_per_dir,parts,parts_per_dir)\nMakie.plot(pmesh;color=GT.FaceData(\"__OWNER__\"),strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_mg_pmesh.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"(Image: )","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"warning: Warning\nTODO Maybe a different API for partsperdir and parts? TODO Maybe a different API for GT.FaceData(\"OWNER\")","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Generate a mesh on a single machine (using Gmsh in this case), partition it using Metis into 4 parts, and visualize it.","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"np = 4\nparts = LinearIndices((np,))\npmesh = PA.map_main(parts) do parts\n    fn = joinpath(repodir,\"assets\",\"mesh1.msh\")\n    mesh = GT.mesh_from_gmsh(fn)\n    graph = GT.mesh_graph(mesh)\n    graph_partition = Metis.partition(graph,np)\n    GT.partition_mesh(mesh,np;graph,graph_partition)\nend |> GT.scatter_mesh\nMakie.plot(pmesh,color=GT.FaceData(\"__OWNER__\"),strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_mg_pmesh_a.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"(Image: )","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"warning: Warning\nTODO color=GT.FaceData(\"__PART__\") not working\nTODO better syntax for color=GT.FaceData(\"__PART__\") ?","category":"page"},{"location":"tooling/mesh_generation/#Meshes-from-arrays","page":"Mesh generation","title":"Meshes from arrays","text":"","category":"section"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Generate a mesh of three triangles from the arrays describing node coordinates and cell connectivity.","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"order = 1\ntriangle = GT.unit_simplex(Val(2))\ntriangle3 = GT.lagrange_space(triangle,order)\nnode_to_coords = SVector{2,Float64}[(0,0),(1,0),(0,1),(1,1),(2,0)]\ncell_to_nodes = [[1,2,3],[2,3,4],[2,4,5]]\ncell_to_type = [1,1,1]\ntype_to_refcell = [triangle3]\nchain = GT.chain(;\n        node_coordinates = node_to_coords,\n        face_nodes = cell_to_nodes,\n        face_reference_id = cell_to_type,\n        reference_spaces = type_to_refcell)\nmesh = GT.mesh(chain)\nMakie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_mg_mfa.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"(Image: )","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Now, include also a square element","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"square = GT.unit_n_cube(Val(2))\nsquare4 = GT.lagrange_space(square,order)\ncell_to_nodes = [[1,2,3,4],[2,4,5]]\ncell_to_type = [2,1]\ntype_to_refcell = (triangle3,square4)\nchain = GT.chain(;\n        node_coordinates = node_to_coords,\n        face_nodes = cell_to_nodes,\n        face_reference_id = cell_to_type,\n        reference_spaces = type_to_refcell)\nmesh = GT.mesh(chain)\nMakie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_mg_mfa_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"(Image: )","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"warning: Warning\nTODO visualization not working properly when more than one element type present","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Generate a mesh that includes cells of different dimensions, i.e., triangles, segments, and vertices.","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"segment = GT.unit_simplex(Val(1))\nsegment2 = GT.lagrange_space(segment,order)\nvertex = GT.unit_simplex(Val(0))\nvertex1 = GT.lagrange_space(vertex,order)\nnode_to_coords = SVector{2,Float64}[(0,0),(1,0),(0,1),(1,1),(2,0)]\nface2_to_nodes = [[1,2,3],[2,3,4],[2,4,5]]\nface2_to_type = [1,1,1]\nface1_to_nodes = [[1,2],[2,5],[5,4]]\nface1_to_type = [1,1,1]\nface0_to_nodes = [[1],[3]]\nface0_to_type = [1,1]\nface_to_nodes = [face0_to_nodes,face1_to_nodes,face2_to_nodes]\nface_to_type = [face0_to_type,face1_to_type,face2_to_type]\ntype_to_refcell = ([vertex1],[segment2],[triangle3])\nmesh = GT.mesh(\n            node_coordinates = node_to_coords,\n            face_nodes = face_to_nodes,\n            face_reference_id = face_to_type,\n            reference_spaces = type_to_refcell)\nMakie.plot(mesh,color=:pink,strokecolor=:blue,shrink=0.8,dim=(0:2))\nFileIO.save(joinpath(@__DIR__,\"fig_mg_mfa_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"(Image: )","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"Now, generate all low-dimensional objects","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"mesh = GT.complexify(mesh)\nMakie.plot(mesh,color=:pink,strokecolor=:blue,shrink=0.8,dim=(0:2))\nFileIO.save(joinpath(@__DIR__,\"fig_mg_mfa_4.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"(Image: )","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"","category":"page"},{"location":"tooling/mesh_generation/","page":"Mesh generation","title":"Mesh generation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"users_guide/#Users-guide","page":"Users guide","title":"Users guide","text":"","category":"section"},{"location":"users_guide/#Installation","page":"Users guide","title":"Installation","text":"","category":"section"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"EditURL = \"p_laplacian.jl\"","category":"page"},{"location":"pdes_manual/p_laplacian/#p-Laplacian","page":"p-Laplacian","title":"p-Laplacian","text":"","category":"section"},{"location":"pdes_manual/p_laplacian/#Problem-statement","page":"p-Laplacian","title":"Problem statement","text":"","category":"section"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Solve the following p-Laplacian equation on the unit square,","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"leftlbrace\nbeginaligned\n-nabla cdot left( nabla u^q-2  nabla u right) = f textin Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"with f=1 and g=0 and q=3.","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Solve it with a piece-wise bi-linear Lagrange interpolation, and visualize the result.","category":"page"},{"location":"pdes_manual/p_laplacian/#Implementation","page":"p-Laplacian","title":"Implementation","text":"","category":"section"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"using LinearAlgebra","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Import other dependencies","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Setup the objects defining this example","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"function setup_example(;domain,cells,file)\n    mesh = GT.cartesian_mesh(domain,cells)\n    dirichlet_tag = \"dirichlet\"\n    GT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\n    Ω = GT.interior(mesh)\n    Γd = GT.boundary(mesh;physical_names=[dirichlet_tag])\n    g = GT.analytical_field(x->0,Ω)\n    f = GT.analytical_field(x->1,Ω)\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n    T = Float64\n    uh = GT.rand_field(T,V)\n    GT.interpolate_dirichlet!(g,uh)\n    degree = 2*k\n    dΩ = GT.measure(Ω,degree)\n    example = (;mesh,Ω,dΩ,V,uh,T,f,g,file)\n    state = (;example)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Create accessor functions for low-level integration quantities.","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"function setup_integration_accessors(state)\n    (;dΩ) = state.example\n    face_point_x = GT.coordinate_accessor(dΩ)\n    face_point_J = GT.jacobian_accessor(dΩ)\n    face_point_dV = GT.weight_accessor(dΩ)\n    face_npoints = GT.num_points_accessor(dΩ)\n    integration = (;\n        face_point_x,face_point_J, face_point_dV,face_npoints)\n    (;integration,state...)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Create accessor functions for low-level interpolation quantities.","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"function setup_interpolation_accessors(state)\n    (;dΩ,Ω,V,uh) = state.example\n    face_dofs = GT.dofs_accessor(V,Ω)\n    face_point_dof_s = GT.shape_function_accessor(GT.value,V,dΩ)\n    face_point_dof_∇s = GT.shape_function_accessor(ForwardDiff.gradient,V,dΩ)\n    face_point_∇uh = GT.discrete_field_accessor(ForwardDiff.gradient,uh,dΩ)\n    interpolation = (;\n        face_dofs,face_point_dof_s,face_point_dof_∇s,face_point_∇uh)\n    (;interpolation,state...)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define the algebraic non-linear problem object","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"function setup_nonlinear_problem(state)\n\n    (;example) = state\n    (;V,Ω,T,f,uh) = example\n\n    #Allocate auxiliary face matrix and vector\n    n = maximum(map(GT.num_dofs,GT.reference_spaces(V)))\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Allocate space for the global matrix and vector\n    b_alloc = GT.allocate_vector(T,V,Ω)\n    A_alloc = GT.allocate_matrix(T,V,V,Ω)\n\n    #Fill in residual and jacobian according to the initial state\n    allocs = (;A_alloc,b_alloc,Auu,bu)\n    fill_residual_and_jacobian!(state,allocs) # Defined later\n\n    #Compress matrix and vector into the final format\n    b,b_cache = GT.compress(b_alloc;reuse=Val(true))\n    A,A_cache = GT.compress(A_alloc;reuse=Val(true))\n\n    #Get initial guess\n    x0 = GT.free_values(uh)\n\n    workspace = nothing\n    problem = PS.nonlinear_problem(x0,b,A,workspace) do p\n\n        #Get the current solution vector\n        x = PS.solution(p)\n\n        #Build the current solution field\n        GT.solution_field!(uh,x)\n\n        #Fill in residual and Jacobian\n        fill_residual_and_jacobian!(state,allocs)\n\n        #In-place compression of matrix and vector\n        GT.compress!(b_alloc,b,b_cache)\n        GT.compress!(A_alloc,A,A_cache)\n\n        #Update the nonlinear problem object\n        #Here, we computed the residual and Jacobian simultaneously,\n        #but this API also allows to compute them separately.\n        if PS.residual(p) !== nothing\n            p = PS.update(p,residual=b)\n        end\n        if PS.jacobian(p) !== nothing\n            p = PS.update(p,jacobian=A)\n        end\n\n        p\n    end\n\n    (;problem,state...)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Assembly loop","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"function fill_residual_and_jacobian!(state,allocs)\n    (;A_alloc,b_alloc,Auu,bu) = allocs\n    (;example) = state\n    (;Ω,) = example\n\n    #Reset allocations\n    GT.reset!(b_alloc)\n    GT.reset!(A_alloc)\n\n    #Loop over the faces of the domain\n    for face in 1:GT.num_faces(Ω)\n\n        #Compute face tensors\n        dofs = face_tensors!(Auu,bu,face,state) # Defined later\n\n        #Add face contribution to global allocation\n        GT.contribute!(b_alloc,bu,dofs)\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n    end\n\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Compute local Jacobian and residual","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"function face_tensors!(Auu,bu,face,state)\n\n    (;example,integration,interpolation) = state\n    (;f) = example\n\n    #Define flux and its derivative\n    q = 3\n    flux(∇u) = norm(∇u)^(q-2) * ∇u\n    dflux(∇du,∇u) = (q-2)*norm(∇u)^(q-4)*(∇u⋅∇du)*∇u+norm(∇u)^(q-2)*∇du\n\n    #Get quantities at current face\n    npoints = integration.face_npoints(face)\n    point_x = integration.face_point_x(face)\n    point_J = integration.face_point_J(face)\n    point_dV = integration.face_point_dV(face)\n    point_dof_s = interpolation.face_point_dof_s(face)\n    point_dof_∇s = interpolation.face_point_dof_∇s(face)\n    point_∇uh = interpolation.face_point_∇uh(face)\n    dofs = interpolation.face_dofs(face)\n\n    #Reset face matrix and vector\n    fill!(Auu,zero(eltype(Auu)))\n    fill!(bu,zero(eltype(bu)))\n\n    #Loop over integration points\n    for point in 1:npoints\n\n        #Get quantities at current integration point\n        x = point_x(point)\n        fx = f.definition(x)\n        J = point_J(point)\n        dV = point_dV(point,J)\n        dof_s = point_dof_s(point)\n        dof_∇s = point_dof_∇s(point,J)\n        ∇uh = point_∇uh(point,J)\n\n        #Fill in face matrix and vector\n        for (i,dofi) in enumerate(dofs)\n            v = dof_s(i)\n            ∇v = dof_∇s(i)\n            bu[i] += (flux(∇uh)⋅∇v - fx*v)*dV\n            for (j,dofj) in enumerate(dofs)\n                ∇du = dof_∇s(j)\n                Auu[i,j] += dflux(∇du,∇uh)⋅∇v*dV\n            end\n        end\n    end\n\n    #Return dof ids for this face\n    dofs\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Solve and visualize results","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"function solve_and_visualize(state)\n    (;problem,example) = state\n    (;uh,file,Ω) = example\n\n    #Setup solver\n    solver = PS.newton_raphson(problem,verbose=true)\n\n    #Get the lazy solver history\n    solver_history = PS.history(solver)\n\n    #Visualize\n    color = Makie.Observable(uh)\n    fig = Makie.plot(Ω;color,strokecolor=:black)\n    fn = joinpath(@__DIR__,\"fig_pt_plaplacian.gif\")\n    Makie.record(fig,file,solver_history;framerate=2) do s\n        color[] = uh\n    end\nend","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Final program.","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"function main(;kwargs...)\n    state1 = setup_example(;kwargs...)\n    state2 = setup_integration_accessors(state1)\n    state3 = setup_interpolation_accessors(state2)\n    state4 = setup_nonlinear_problem(state3)\n    solve_and_visualize(state4)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Run it for a 2d case","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"file = joinpath(@__DIR__,\"p_laplacian_2d_manual.gif\")\nmain(;domain=(0,1,0,1),cells=(10,10),file)\nnothing # hide","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"","category":"page"},{"location":"pdes_manual/p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#API-reference","page":"Introduction","title":"API reference","text":"","category":"section"},{"location":"reference/","page":"Introduction","title":"Introduction","text":"Modules = [GalerkinToolkit]\nPages = [\"helpers.jl\", \"abstract_types.jl\", \"domain.jl\", \"mesh.jl\", \"cartesian_mesh.jl\", \"gmsh.jl\", \"p_mesh.jl\", \"topology.jl\", \"symbolics.jl\", \"field.jl\", \"integration.jl\", \"space.jl\", \"quadrature.jl\", \"quantity.jl\", \"visualization.jl\", \"assembly.jl\"]","category":"page"},{"location":"reference/#GalerkinToolkit.AbstractType","page":"Introduction","title":"GalerkinToolkit.AbstractType","text":"abstract type AbstractType end\n\nParent of all types defined in GalerkinToolkit.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.Options","page":"Introduction","title":"GalerkinToolkit.Options","text":"struct Options{...} <: AbstractType\n\nType of the objects returned by function options. All properties and type parameters are private.\n\nBasic queries\n\nreference_int_type\nint_type\nglobal_int_type\nreal_type\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.global_int_type-Tuple{GalerkinToolkit.Options}","page":"Introduction","title":"GalerkinToolkit.global_int_type","text":"global_int_type(options::Options)\n\nReturn the type of the integers used to enumerate global quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.int_type-Tuple{GalerkinToolkit.Options}","page":"Introduction","title":"GalerkinToolkit.int_type","text":"int_type(options::Options)\n\nReturn the default integer type used in the computation except for reference and global quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.options-Tuple{}","page":"Introduction","title":"GalerkinToolkit.options","text":"options(;kwargs...) -> Options\n\nCreate an object representing the default options for the current simulation. This object can be used as an optional argument in several object constructors in GalerkinToolkit, such as the mesh constructors cartesian_mesh and mesh_from_gmsh. In this case, the computations using the generated mesh, will use the given options by default.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.push","page":"Introduction","title":"GalerkinToolkit.push","text":"push(a,ai)\n\nLike push!, but creates a new object to store the result.  This function is used to push to immutable collections such as tuples.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.real_type-Tuple{GalerkinToolkit.Options}","page":"Introduction","title":"GalerkinToolkit.real_type","text":"real_type(options::Options)\n\nReturn the default real type used in the computation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.reference_int_type-Tuple{GalerkinToolkit.Options}","page":"Introduction","title":"GalerkinToolkit.reference_int_type","text":"reference_int_type(options::Options)\n\nReturn the type of the integers used to enumerate reference quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.val_parameter-Tuple{Any}","page":"Introduction","title":"GalerkinToolkit.val_parameter","text":"val_parameter(a)\n\nFor a::Val{A} it returns A. Otherwise, it returns a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.AbstractDomain","page":"Introduction","title":"GalerkinToolkit.AbstractDomain","text":"abstract type AbstractDomain <: AbstractType end\n\nAbstract type representing the geometry of a single mesh face, typically one of the reference faces.\n\nBasic queries\n\nnum_dims\nis_axis_aligned\nis_simplex\nis_n_cube\nis_unit_n_cube\nis_unit_simplex\nis_unitary\nbounding_box\nvertex_permutations\nmesh\nfaces\ninverse_faces\ngeometries\ntopology\ngeometries\noptions\nis_boundary\nface_around\n\nBasic constructors\n\nunit_simplex\nunit_n_cube\ndomain\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractMesh","page":"Introduction","title":"GalerkinToolkit.AbstractMesh","text":"abstract type AbstractMesh\n\nBasic queries\n\nnode_coordinates\nface_nodes\nface_reference_id\nreference_spaces\nperiodic_nodes\nphysical_faces\noutward_normals\n\nBasic constructors\n\nmesh\nmesh_from_gmsh\ncartesian_mesh\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractQuadrature","page":"Introduction","title":"GalerkinToolkit.AbstractQuadrature","text":"abstract type AbstractQuadrature\n\nBasic queries\n\ndomain\ncoordinates\nweights\n[num_points]\nface_reference_id\nreference_quadratures\n\nBasic constructors\n\nquadrature\nduffy_quadrature\ntensor_product_quadrature\nnode_quadrature\n\nSupertype hierarchy\n\nAbstractQuadrature <: GT.AbstractType\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractSpace","page":"Introduction","title":"GalerkinToolkit.AbstractSpace","text":"abstract type AbstractSpace <: AbstractType end\n\nBasic queries\n\ndomain num_dofs num_nodes face_dofs face_nodes face_reference_id reference_spaces interior_nodes interior_nodes_permutations geometry_own_dofs geometry_own_dofs_permutations geometry_interior_nodes geometry_interior_nodes_permutations geometry_nodes geometry_nodes_permutations\n\nBasic constructors\n\nlagrange_space raviart_thomas_space\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractTopology","page":"Introduction","title":"GalerkinToolkit.AbstractTopology","text":"abstract type AbstractTopology\n\nBasic queries\n\nface_incidence\nface_reference_id\nface_permutation_ids\nreference_topologies\nvertex_permutations\n\nBasic constructors\n\ntopology\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.bounding_box","page":"Introduction","title":"GalerkinToolkit.bounding_box","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.coordinates","page":"Introduction","title":"GalerkinToolkit.coordinates","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.domain","page":"Introduction","title":"GalerkinToolkit.domain","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_around","page":"Introduction","title":"GalerkinToolkit.face_around","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_dofs","page":"Introduction","title":"GalerkinToolkit.face_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_incidence","page":"Introduction","title":"GalerkinToolkit.face_incidence","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_nodes","page":"Introduction","title":"GalerkinToolkit.face_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_permutation_ids","page":"Introduction","title":"GalerkinToolkit.face_permutation_ids","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_reference_id","page":"Introduction","title":"GalerkinToolkit.face_reference_id","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.faces","page":"Introduction","title":"GalerkinToolkit.faces","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometries","page":"Introduction","title":"GalerkinToolkit.geometries","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_interior_nodes","page":"Introduction","title":"GalerkinToolkit.geometry_interior_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_interior_nodes_permutations","page":"Introduction","title":"GalerkinToolkit.geometry_interior_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_nodes","page":"Introduction","title":"GalerkinToolkit.geometry_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_nodes_permutations","page":"Introduction","title":"GalerkinToolkit.geometry_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_own_dofs","page":"Introduction","title":"GalerkinToolkit.geometry_own_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_own_dofs_permutations","page":"Introduction","title":"GalerkinToolkit.geometry_own_dofs_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.interior_nodes","page":"Introduction","title":"GalerkinToolkit.interior_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.interior_nodes_permutations","page":"Introduction","title":"GalerkinToolkit.interior_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.inverse_faces","page":"Introduction","title":"GalerkinToolkit.inverse_faces","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_axis_aligned","page":"Introduction","title":"GalerkinToolkit.is_axis_aligned","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_boundary","page":"Introduction","title":"GalerkinToolkit.is_boundary","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_n_cube","page":"Introduction","title":"GalerkinToolkit.is_n_cube","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_simplex","page":"Introduction","title":"GalerkinToolkit.is_simplex","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unit_n_cube","page":"Introduction","title":"GalerkinToolkit.is_unit_n_cube","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unitary","page":"Introduction","title":"GalerkinToolkit.is_unitary","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.node_coordinates","page":"Introduction","title":"GalerkinToolkit.node_coordinates","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.node_quadrature","page":"Introduction","title":"GalerkinToolkit.node_quadrature","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_dims","page":"Introduction","title":"GalerkinToolkit.num_dims","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_dofs","page":"Introduction","title":"GalerkinToolkit.num_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_nodes","page":"Introduction","title":"GalerkinToolkit.num_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.outward_normals","page":"Introduction","title":"GalerkinToolkit.outward_normals","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.periodic_nodes","page":"Introduction","title":"GalerkinToolkit.periodic_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.physical_faces","page":"Introduction","title":"GalerkinToolkit.physical_faces","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_quadratures","page":"Introduction","title":"GalerkinToolkit.reference_quadratures","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_spaces","page":"Introduction","title":"GalerkinToolkit.reference_spaces","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_topologies","page":"Introduction","title":"GalerkinToolkit.reference_topologies","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.vertex_permutations","page":"Introduction","title":"GalerkinToolkit.vertex_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.weights","page":"Introduction","title":"GalerkinToolkit.weights","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unit_simplex-Tuple{GalerkinToolkit.AbstractDomain}","page":"Introduction","title":"GalerkinToolkit.is_unit_simplex","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.unit_n_cube-Tuple{Any}","page":"Introduction","title":"GalerkinToolkit.unit_n_cube","text":"unit_n_cube(d)\nunit_n_cube(Val(d))\n\nReturn an object representing a unit d-cube.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.unit_simplex-Tuple{Any}","page":"Introduction","title":"GalerkinToolkit.unit_simplex","text":"unit_simplex(d)\nunit_simplex(Val(d))\n\nReturn an object representing a unit simplex of dimension d.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.cartesian_mesh-Tuple{Any, Any}","page":"Introduction","title":"GalerkinToolkit.cartesian_mesh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.label_boundary_faces!-Tuple{GalerkinToolkit.PMesh}","page":"Introduction","title":"GalerkinToolkit.label_boundary_faces!","text":"label_boundary_faces!(mesh::PMesh;physical_name=\"boundary\")\n\nUpdate mesh inplace by using partition ownership of faces to label only the boundary of  meshes in a parallel mesh where the boundary is defined as a face owned by a given partition  and not incident with any other faces on another partition (i.e., not on the interface). \n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh-Tuple{GalerkinToolkit.AbstractChain}","page":"Introduction","title":"GalerkinToolkit.mesh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.physical_names-Tuple{Any, Any}","page":"Introduction","title":"GalerkinToolkit.physical_names","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_gmsh-Tuple{Any}","page":"Introduction","title":"GalerkinToolkit.mesh_from_gmsh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.topology-Tuple{GalerkinToolkit.AbstractMesh}","page":"Introduction","title":"GalerkinToolkit.topology","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.interior_node_permutations-Tuple{GalerkinToolkit.LagrangeFaceSpace}","page":"Introduction","title":"GalerkinToolkit.interior_node_permutations","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.lagrange_space","page":"Introduction","title":"GalerkinToolkit.lagrange_space","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.node_permutations-Tuple{GalerkinToolkit.LagrangeFaceSpace}","page":"Introduction","title":"GalerkinToolkit.node_permutations","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.raviart_thomas_space","page":"Introduction","title":"GalerkinToolkit.raviart_thomas_space","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.shape_functions-Tuple{GalerkinToolkit.AbstractSpace}","page":"Introduction","title":"GalerkinToolkit.shape_functions","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.tabulator-Tuple{GalerkinToolkit.AbstractSpace}","page":"Introduction","title":"GalerkinToolkit.tabulator","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.duffy_quadrature-Tuple{Any, Any}","page":"Introduction","title":"GalerkinToolkit.duffy_quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.quadrature-Tuple{GalerkinToolkit.AbstractFaceDomain, Any}","page":"Introduction","title":"GalerkinToolkit.quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.tensor_product_quadrature-Tuple{GalerkinToolkit.AbstractFaceDomain, Any}","page":"Introduction","title":"GalerkinToolkit.tensor_product_quadrature","text":"\n\n\n\n","category":"method"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"EditURL = \"poisson.jl\"","category":"page"},{"location":"pdes_automatic/poisson/#Laplace","page":"Laplace","title":"Laplace","text":"","category":"section"},{"location":"pdes_automatic/poisson/#Problem-statement","page":"Laplace","title":"Problem statement","text":"","category":"section"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"In this example, we show how to solve the \"Hello, world\" PDE example: the Poisson equation on the unit square with Dirichlet boundary conditions.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"with f=0 and g(x)=textsum(x).","category":"page"},{"location":"pdes_automatic/poisson/#Numerical-scheme","page":"Laplace","title":"Numerical scheme","text":"","category":"section"},{"location":"pdes_automatic/poisson/#Implementation","page":"Laplace","title":"Implementation","text":"","category":"section"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"using LinearAlgebra","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Import other dependencies","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Generate the computational mesh.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"domain = (0,1,0,1)\ncells = (10,10)\nmesh = GT.cartesian_mesh(domain,cells)\nnothing # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Visualize the mesh.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Makie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_1.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"(Image: )","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Define the Dirichlet boundary.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"dirichlet_tag = \"dirichlet\"\nGT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\nnothing # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Defile computational domains.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Ω = GT.interior(mesh)\nΓd = GT.boundary(mesh;physical_names=[dirichlet_tag])\nnothing # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Define differential operators","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"const ∇ = ForwardDiff.gradient\nΔ(f,x) = tr(ForwardDiff.jacobian(y->∇(f,y),x))","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Define manufactured fields.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"g = GT.analytical_field(sum,Ω)\nf = GT.analytical_field(x->-Δ(g.definition,x),Ω)\nnothing # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Define the interpolation space.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"k = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\nnothing # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Interpolate Dirichlet values.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"T = Float64\nuhd = GT.dirichlet_field(T,V)\nGT.interpolate_dirichlet!(g,uhd)\nnothing # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Visualize the Dirichlet field.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Makie.plot(Ω,color=uhd,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"(Image: )","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Define numerical integration.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"degree = 2*k\ndΩ = GT.measure(Ω,degree)\nnothing # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Define weak form.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"a = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\nl = v -> GT.∫( x->v(x)*f(x), dΩ)\nnothing # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Assemble the problem using the automatic assembly loop generator","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"p = GT.linear_problem(uhd,a,l)\nnothing # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Solve the problem","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"s = PS.LinearAlgebra_lu(p)\ns = PS.solve(s)\nnothing # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Build the FE solution.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"uh = GT.solution_field(uhd,s)\nnothing # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Visualize the solution.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Makie.plot(Ω;color=uh,strokecolor=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"(Image: )","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Compute the L2 norm of the discretization error.","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"eh = x -> uh(x) - g(x)\nel2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt","category":"page"},{"location":"pdes_automatic/poisson/#Final-program","page":"Laplace","title":"Final program","text":"","category":"section"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"module Program\n\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\n\nfunction main(;domain,cells)\n    mesh = GT.cartesian_mesh(domain,cells)\n    dirichlet_tag = \"dirichlet\"\n    GT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\n    Ω = GT.interior(mesh)\n    Γd = GT.boundary(mesh;physical_names=[dirichlet_tag])\n    ∇ = ForwardDiff.gradient\n    Δ(f,x) = tr(ForwardDiff.jacobian(y->∇(f,y),x))\n    g = GT.analytical_field(sum,Ω)\n    f = GT.analytical_field(x->-Δ(g.definition,x),Ω)\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n    T = Float64\n    uhd = GT.dirichlet_field(T,V)\n    GT.interpolate_dirichlet!(g,uhd)\n    degree = 2*k\n    dΩ = GT.measure(Ω,degree)\n    a = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\n    l = v -> GT.∫( x->v(x)*f(x), dΩ)\n    p = GT.linear_problem(uhd,a,l)\n    s = PS.LinearAlgebra_lu(p)\n    s = PS.solve(s)\n    uh = GT.solution_field(uhd,s)\n    eh = x -> uh(x) - g(x)\n    el2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt\nend\n\nend # module","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Run it for a 2d case","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Program.main(domain=(0,1,0,1),cells=(10,10))","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Run it for a 3d case","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"Program.main(domain=(0,1,0,1,0,1),cells=(10,10,10))","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"","category":"page"},{"location":"pdes_automatic/poisson/","page":"Laplace","title":"Laplace","text":"This page was generated using Literate.jl.","category":"page"},{"location":"refindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"refindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"reference/integration/#Integration","page":"Integration","title":"Integration","text":"","category":"section"},{"location":"examples/#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GalerkinToolkit","category":"page"},{"location":"#GalerkinToolkit","page":"Home","title":"GalerkinToolkit","text":"","category":"section"},{"location":"#What","page":"Home","title":"What","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package aims at providing a fully-fledged finite-element toolbox in pure Julia, with support for different computing systems from laptops to supercomputers and GPUs.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"NB. This package is work in progress; a proof-of-concept API is already available (for CPUs). The package is not production ready at this point. Planned performance and documentation improvements are needed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warn: Warn\nTODO elaborary more","category":"page"},{"location":"#Why","page":"Home","title":"Why","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package follows a new approach to implement finite-element methods based on the lessons learned in the Gridap project.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warn: Warn\nTODO elaborary more","category":"page"},{"location":"#How-to-get-started","page":"Home","title":"How to get started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For users:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Read the Examples section to learn how the different pieces of the library work together in different scenarios.\nDo you want more info about a specific function, macro, or data type? Read the docstrings in the API reference.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For developers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Read the Developers guide.","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"EditURL = \"poisson.jl\"","category":"page"},{"location":"pdes_manual/poisson/#Laplace","page":"Laplace","title":"Laplace","text":"","category":"section"},{"location":"pdes_manual/poisson/#Problem-statement","page":"Laplace","title":"Problem statement","text":"","category":"section"},{"location":"pdes_manual/poisson/#Implementation","page":"Laplace","title":"Implementation","text":"","category":"section"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"using LinearAlgebra","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"Import other dependencies","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"Setup the objects defining this example","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"function setup_example(;domain,cells)\n    mesh = GT.cartesian_mesh(domain,cells)\n    dirichlet_tag = \"dirichlet\"\n    GT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\n    Ω = GT.interior(mesh)\n    Γd = GT.boundary(mesh;physical_names=[dirichlet_tag])\n    ∇ = ForwardDiff.gradient\n    Δ(f,x) = tr(ForwardDiff.jacobian(y->∇(f,y),x))\n    g = GT.analytical_field(sum,Ω)\n    f = GT.analytical_field(x->-Δ(g.definition,x),Ω)\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n    T = Float64\n    uhd = GT.dirichlet_field(T,V)\n    GT.interpolate_dirichlet!(g,uhd)\n    degree = 2*k\n    dΩ = GT.measure(Ω,degree)\n    example = (;mesh,Ω,dΩ,V,uhd,T,f,g)\n    state = (;example)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"Create accessor functions for low-level integration quantities.","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"function setup_integration_accessors(state)\n    (;dΩ) = state.example\n    face_point_x = GT.coordinate_accessor(dΩ)\n    face_point_J = GT.jacobian_accessor(dΩ)\n    face_point_dV = GT.weight_accessor(dΩ)\n    face_npoints = GT.num_points_accessor(dΩ)\n    integration = (;\n        face_point_x,face_point_J, face_point_dV,face_npoints)\n    (;integration,state...)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"Create accessor functions for low-level interpolation quantities.","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"function setup_interpolation_accessors(state)\n    (;dΩ,Ω,V,uhd) = state.example\n    face_dofs = GT.dofs_accessor(V,Ω)\n    face_point_dof_s = GT.shape_function_accessor(GT.value,V,dΩ)\n    face_point_dof_∇s = GT.shape_function_accessor(ForwardDiff.gradient,V,dΩ)\n    face_dirichlet! = GT.dirichlet_accessor(uhd,Ω)\n    interpolation = (;\n        face_dofs,face_point_dof_s,face_point_dof_∇s,face_dirichlet!)\n    (;interpolation,state...)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"Compute local matrix and vector","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"function face_tensors!(Auu,bu,face,state)\n\n    (;example,integration,interpolation) = state\n    (;f) = example\n\n    #Get quantities at current face\n    npoints = integration.face_npoints(face)\n    point_x = integration.face_point_x(face)\n    point_J = integration.face_point_J(face)\n    point_dV = integration.face_point_dV(face)\n    point_dof_s = interpolation.face_point_dof_s(face)\n    point_dof_∇s = interpolation.face_point_dof_∇s(face)\n    dofs = interpolation.face_dofs(face)\n    dirichlet! = interpolation.face_dirichlet!(face)\n\n    #Reset face matrix and vector\n    fill!(Auu,zero(eltype(Auu)))\n    fill!(bu,zero(eltype(bu)))\n\n    #Loop over integration points\n    for point in 1:npoints\n\n        #Get quantities at current integration point\n        x = point_x(point)\n        J = point_J(point)\n        dV = point_dV(point,J)\n        dof_s = point_dof_s(point)\n        dof_∇s = point_dof_∇s(point,J)\n\n        #Fill in face matrix and vector\n        for (i,dofi) in enumerate(dofs)\n            v = dof_s(i)\n            ∇v = dof_∇s(i)\n            bu[i] += f.definition(x)*v*dV\n            for (j,dofj) in enumerate(dofs)\n                ∇u = dof_∇s(j)\n                Auu[i,j] += ∇v⋅∇u*dV\n            end\n        end\n    end\n\n    #Apply Dirichlet conditions on face vector\n    dirichlet!(Auu,bu)\n\n    #Return dof ids for this face\n    dofs\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"Assemble linear problem","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"function assemble_problem(state)\n\n    (;example) = state\n    (;V,Ω,T,f) = example\n\n    #Allocate auxiliary face matrix and vector\n    n = maximum(map(GT.num_dofs,GT.reference_spaces(V)))\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Allocate space for the global matrix and vector\n    b_alloc = GT.allocate_vector(T,V,Ω)\n    A_alloc = GT.allocate_matrix(T,V,V,Ω)\n\n    #Loop over the faces of the domain\n    for face in 1:GT.num_faces(Ω)\n\n        #Compute face tensors\n        dofs = face_tensors!(Auu,bu,face,state)\n\n        #Add face contribution to global allocation\n        GT.contribute!(b_alloc,bu,dofs)\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n    end\n\n    #Compress matrix and vector into the final format\n    b = GT.compress(b_alloc)\n    A = GT.compress(A_alloc)\n\n    #Allocate space for the solution\n    sol = similar(b,axes(A,2))\n\n    #Create linear problem object\n    problem = PS.linear_problem(sol,A,b)\n    (;problem,state...)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"Solve the solution problem and build the solution field","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"function solve_problem(state)\n    (;problem,example) = state\n    (;uhd) = example\n    solver = PS.LinearAlgebra_lu(problem)\n    solver = PS.solve(solver)\n    uh = GT.solution_field(uhd,solver)\n    (;uh,state...)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"Setup accessor functions to integrate error norms","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"function setup_postpro_accessors(state)\n    (;uh,example) = state\n    (;dΩ) = example\n    #TODO add also h1 norm\n    face_point_uhx = GT.discrete_field_accessor(GT.value,uh,dΩ)\n    postpro = (;face_point_uhx)\n    (;postpro,state...)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"Compute the error norms","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"function integrate_error_norms(state)\n    (;postpro,example,integration) = state\n    (;Ω,dΩ,g,T) = example\n    #TODO add also h1 norm\n    el2 = zero(T)\n    for face in 1:GT.num_faces(Ω)\n        npoints = integration.face_npoints(face)\n        point_x = integration.face_point_x(face)\n        point_J = integration.face_point_J(face)\n        point_dV = integration.face_point_dV(face)\n        point_uhx = postpro.face_point_uhx(face)\n        for point in 1:npoints\n            x = point_x(point)\n            J = point_J(point)\n            dV = point_dV(point,J)\n            uhx = point_uhx(point,J)\n            el2 += abs2(uhx-g.definition(x))*dV\n        end\n    end\n    el2 = sqrt(el2)\n    norms = (;el2)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/poisson/#Final-Program","page":"Laplace","title":"Final Program","text":"","category":"section"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"function main(;kwargs...)\n    state1 = setup_example(;kwargs...)\n    state2 = setup_integration_accessors(state1)\n    state3 = setup_interpolation_accessors(state2)\n    state4 = assemble_problem(state3)\n    state5 = solve_problem(state4)\n    state6 = setup_postpro_accessors(state5)\n    norms = integrate_error_norms(state6)\nend\nnothing # hide","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"Run it for a 2d case","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"main(domain=(0,1,0,1),cells=(10,10))","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"Run it for a 3d case","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"main(domain=(0,1,0,1,0,1),cells=(10,10,10))","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"","category":"page"},{"location":"pdes_manual/poisson/","page":"Laplace","title":"Laplace","text":"This page was generated using Literate.jl.","category":"page"}]
}
