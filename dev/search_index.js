var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"manual/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"manual/getting_started/#Pre-requirements","page":"Getting started","title":"Pre-requirements","text":"","category":"section"},{"location":"manual/getting_started/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"EditURL = \"../src_jl/example_p_laplacian.jl\"","category":"page"},{"location":"src_md/example_p_laplacian/#p-Laplacian","page":"p-Laplacian","title":"p-Laplacian","text":"","category":"section"},{"location":"src_md/example_p_laplacian/#Problem-statement","page":"p-Laplacian","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Find the scalar-field u such that","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"leftlbrace\nbeginaligned\n-nabla cdot left( nabla u^p-2  nabla u right) = f textin Omega\nu = -1  texton  Gamma_0\nu = 1  texton  Gamma_1\nleft( nabla u^p-2 nabla u right)cdot n = 0  textelsewhere on  partialOmega\nendaligned\nright","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"with p2. The vector field n is the outwards unit normal vector to partialOmega. The computational domains are defined in the mesh file model.msh. The domain Omega is represented by the 3D faces in this mesh. The domain Gamma_0 is represented by the physical group named \"sides\" and Gamma_1 is the union of the physical groups named \"circle\", \"triangle\", and \"square\".  To solve this PDE, we use a conventional Galerkin finite element method with conforming Lagrangian FE spaces.","category":"page"},{"location":"src_md/example_p_laplacian/#Implementation","page":"p-Laplacian","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Import other dependencies.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Read and visualize the mesh.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"assets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"model.msh\")\nmesh = GT.mesh_from_gmsh(msh_file)\nnothing # hide\n\nMakie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_1.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define domains.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"dirichlet_0_names = [\"sides\"]\ndirichlet_1_names = [\"circle\", \"triangle\", \"square\"]\nΩ = GT.interior(mesh)\nΓ0 = GT.boundary(mesh;physical_names=dirichlet_0_names)\nΓ1 = GT.boundary(mesh;physical_names=dirichlet_1_names)\nΓd = GT.piecewise_domain(Γ0,Γ1)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define forcing data.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"g0 = GT.analytical_field(x->-1.0,Ω)\ng1 = GT.analytical_field(x->1.0,Ω)\ng = GT.piecewise_field(g0,g1)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define the interpolation space.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"k = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Interpolate Dirichlet values.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"T = Float64\nuh = GT.rand_field(T,V)\nGT.interpolate_dirichlet!(g,uh)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Visualize the Dirichlet field.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Makie.plot(Ω,color=uh,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define numerical integration.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"degree = 2*k\ndΩ = GT.measure(Ω,degree)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define weak form.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"const ∇ = ForwardDiff.gradient\nconst q = 3\nflux(∇u) = norm(∇u)^(q-2) * ∇u\ndflux(∇du,∇u) = (q-2)*norm(∇u)^(q-4)*(∇u⋅∇du)*∇u+norm(∇u)^(q-2)*∇du\nres = u -> v -> GT.∫( x-> ∇(v,x)⋅GT.call(flux,∇(u,x)), dΩ)\njac = u -> (du,v) -> GT.∫( x-> ∇(v,x)⋅GT.call(dflux,∇(du,x),∇(u,x)) , dΩ)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define non-linear problem using the automatic assembly loop generator.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"p = GT.nonlinear_problem(uh,res,jac)\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Define a nonlinear solver and solve the problem, and visualize the solution.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"s = PS.newton_raphson(p,verbose=true)\ns = PS.solve(s)\nuh = GT.solution_field(uh,s)\nMakie.plot(Ω;color=uh,strokecolor=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_p_laplacian_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"Now, solve while showing the intermediate results in the iteration process.","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"uh = GT.rand_field(Float64,V)\nGT.interpolate_dirichlet!(g,uh)\np = GT.nonlinear_problem(uh,res,jac)\ns = PS.newton_raphson(p)\ncolor = Makie.Observable(uh)\nfig = Makie.plot(Ω;color,strokecolor=:black)\nfn = joinpath(@__DIR__,\"fig_p_laplacian.gif\")\nMakie.record(fig,fn,PS.history(s);framerate=2) do s\n    color[] = GT.solution_field(uh,s)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"(Image: )","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"","category":"page"},{"location":"src_md/example_p_laplacian/","page":"p-Laplacian","title":"p-Laplacian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"EditURL = \"../src_jl/example_hello_world.jl\"","category":"page"},{"location":"src_md/example_hello_world/#Hello,-World!","page":"Hello, World!","title":"Hello, World!","text":"","category":"section"},{"location":"src_md/example_hello_world/#Problem-statement","page":"Hello, World!","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"In this example, we show how to solve the \"Hello, world\" PDE example: the Poisson equation on the unit hyper-cube Omega  =01^d, din23, with Dirichlet boundary conditions.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"with f=0 and g(x)=textsum(x). In this case, we know that the solution is u=g which allows us to check that we solve the problem correctly, by integration an error norm.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"To solve this PDE, we use a conventional Galerkin finite element (FE) method with conforming Lagrangian FE spaces (see, e.g., [1] for specific details on this formulation).","category":"page"},{"location":"src_md/example_hello_world/#Implementation","page":"Hello, World!","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Import other dependencies","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Generate the computational mesh.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"domain = (0,1,0,1)\ncells = (10,10)\nmesh = GT.cartesian_mesh(domain,cells)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Visualize the mesh.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Makie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_1.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define the Dirichlet boundary.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"dirichlet_tag = \"dirichlet\"\nGT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Defile computational domains.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Ω = GT.interior(mesh)\nΓd = GT.boundary(mesh;physical_names=[dirichlet_tag])\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define differential operators","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"const ∇ = ForwardDiff.gradient\nΔ(f,x) = tr(ForwardDiff.jacobian(y->∇(f,y),x))","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define manufactured fields.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"g = GT.analytical_field(sum,Ω)\nf = GT.analytical_field(x->-Δ(g.definition,x),Ω)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define the interpolation space.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"k = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Interpolate Dirichlet values.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"T = Float64\nuhd = GT.dirichlet_field(T,V)\nGT.interpolate_dirichlet!(g,uhd)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Visualize the Dirichlet field.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Makie.plot(Ω,color=uhd,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define numerical integration.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"degree = 2*k\ndΩ = GT.measure(Ω,degree)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Define weak form.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"a = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\nl = v -> GT.∫( x->v(x)*f(x), dΩ)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Assemble the problem using the automatic assembly loop generator","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"p = GT.linear_problem(uhd,a,l)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Solve the problem","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"s = PS.LinearAlgebra_lu(p)\ns = PS.solve(s)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Build the FE solution.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"uh = GT.solution_field(uhd,s)\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Visualize the solution.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Makie.plot(Ω;color=uh,strokecolor=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"(Image: )","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Compute the L2 norm of the discretization error.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"eh = x -> uh(x) - g(x)\nel2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt","category":"page"},{"location":"src_md/example_hello_world/#Final-program","page":"Hello, World!","title":"Final program","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"module Program\n\nusing LinearAlgebra\nimport GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\n\nfunction main(;domain,cells)\n    mesh = GT.cartesian_mesh(domain,cells)\n    dirichlet_tag = \"dirichlet\"\n    GT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\n    Ω = GT.interior(mesh)\n    Γd = GT.boundary(mesh;physical_names=[dirichlet_tag])\n    ∇ = ForwardDiff.gradient\n    Δ(f,x) = tr(ForwardDiff.jacobian(y->∇(f,y),x))\n    g = GT.analytical_field(sum,Ω)\n    f = GT.analytical_field(x->-Δ(g.definition,x),Ω)\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n    T = Float64\n    uhd = GT.dirichlet_field(T,V)\n    GT.interpolate_dirichlet!(g,uhd)\n    degree = 2*k\n    dΩ = GT.measure(Ω,degree)\n    a = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\n    l = v -> GT.∫( x->v(x)*f(x), dΩ)\n    p = GT.linear_problem(uhd,a,l)\n    s = PS.LinearAlgebra_lu(p)\n    s = PS.solve(s)\n    uh = GT.solution_field(uhd,s)\n    eh = x -> uh(x) - g(x)\n    el2 = GT.∫( x->abs2(eh(x)), dΩ) |> sum |> sqrt\nend\n\nend # module","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Run it for a 2d case.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Program.main(domain=(0,1,0,1),cells=(10,10))","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Run it for a 3d case.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"Program.main(domain=(0,1,0,1,0,1),cells=(10,10,10))","category":"page"},{"location":"src_md/example_hello_world/#References","page":"Hello, World!","title":"References","text":"","category":"section"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"[1] C. Johnson. Numerical Solution of Partial Differential Equations by the Finite Element Method. Dover Publications, 2009.","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"","category":"page"},{"location":"src_md/example_hello_world/","page":"Hello, World!","title":"Hello, World!","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"EditURL = \"../src_jl/example_poisson_equation.jl\"","category":"page"},{"location":"src_md/example_poisson_equation/#Poisson-equation","page":"Poisson equation","title":"Poisson equation","text":"","category":"section"},{"location":"src_md/example_poisson_equation/#Problem-statement","page":"Poisson equation","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Find the scalar field u such that","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton Gamma_rm D\nnabla ucdot n = h  texton  Gamma_rm N\nnabla ucdot n = 0  textelsewhere on  partial Omega\nendaligned\nright","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"being n the outwards unit normal vector to partialOmega. In this example, we chose f(x) = 1, g(x) = 2, and h(x)=3. The variable x is the position vector x=(x_1x_2x_3).  The computational domains are defined in the mesh file model.msh. The domain Omega is represented by the 3D faces in this mesh. The domain Gamma_rm D is represented by the physical group named \"sides\" and Gamma_rm N is the union of the physical groups named \"circle\", \"triangle\", and \"square\".  To solve this PDE, we use a conventional Galerkin finite element method with conforming Lagrangian FE spaces.","category":"page"},{"location":"src_md/example_poisson_equation/#Implementation","page":"Poisson equation","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Import other dependencies","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff\nimport GLMakie as Makie\nimport FileIO # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Read and visualize the mesh","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"assets_dir = normpath(joinpath(@__DIR__,\"..\",\"..\",\"..\",\"assets\"))\nmsh_file = joinpath(assets_dir,\"model.msh\")\nmesh = GT.mesh_from_gmsh(msh_file)\nnothing # hide\n\nMakie.plot(mesh,color=:pink,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_0.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define domains and visualize them","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Ω = GT.interior(mesh)\nMakie.plot(Ω,color=:pink)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_1.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"dirichlet_names = [\"sides\"]\nΓd = GT.boundary(mesh;physical_names=dirichlet_names)\nMakie.plot(Γd,color=:pink)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_2.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"neumann_names = [\"circle\", \"triangle\", \"square\"]\nΓn = GT.boundary(mesh;physical_names=neumann_names)\nMakie.plot(Γn,color=:pink)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_3.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define forcing data","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"f = GT.analytical_field(x->1.0,Ω)\ng = GT.analytical_field(x->2.0,Ω)\nh = GT.analytical_field(x->3.0,Ω)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define the interpolation space.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"k = 1\nV = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Interpolate Dirichlet values.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"T = Float64\nuhd = GT.dirichlet_field(T,V)\nGT.interpolate_dirichlet!(g,uhd)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Visualize the Dirichlet field.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Makie.plot(Ω,color=uhd,strokecolor=:blue)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_4.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define numerical integration.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"degree = 2*k\ndΩ = GT.measure(Ω,degree)\ndΓn = GT.measure(Γn,degree)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Define weak form.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"const ∇ = ForwardDiff.gradient\na = (u,v) -> GT.∫( x->∇(u,x)⋅∇(v,x), dΩ)\nl = v -> GT.∫( x->v(x)*f(x), dΩ) + GT.∫( x->v(x)*h(x), dΓn)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Assemble the problem using the automatic assembly loop generator","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"p = GT.linear_problem(uhd,a,l)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Solve the problem","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"s = PS.LinearAlgebra_lu(p)\ns = PS.solve(s)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Build the FE solution.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"uh = GT.solution_field(uhd,s)\nnothing # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Visualize the solution.","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"Makie.plot(Ω;color=uh,strokecolor=:black)\nFileIO.save(joinpath(@__DIR__,\"fig_poisson_eq_5.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"(Image: )","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"","category":"page"},{"location":"src_md/example_poisson_equation/","page":"Poisson equation","title":"Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/for_developers/#For-developers","page":"For developers","title":"For developers","text":"","category":"section"},{"location":"manual/for_developers/#Building-the-documentation-locally","page":"For developers","title":"Building the documentation locally","text":"","category":"section"},{"location":"manual/for_developers/#Setup-the-docs-folder-environment","page":"For developers","title":"Setup the docs folder environment","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"We assume that your terminal is located in the root folder of the GalerkingToolkit.jl repo. Open Julia, pointing to the docs folder.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"$ julia --project=docs/","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"Develop your current copy of GalerkingToolkit.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> ]\n(docs) pkg> dev .","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"You will need to do this each time the dependencies of the documentation or of GalerkinToolkit change.","category":"page"},{"location":"manual/for_developers/#Standard-build","page":"For developers","title":"Standard build","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"After the setup, exit package mode and run","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/make.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"This will take a while. When it is done, you will have the html docs in the folder docs/build.","category":"page"},{"location":"manual/for_developers/#Visualizing-the-documentation","page":"For developers","title":"Visualizing the documentation","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The easiest way to visualize the documentation is using LiveServer as follows.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> using LiveServer\nserve(dir=\"docs/build/\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"After it, your docs will be served at the given url.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"If nor yet done, you can install LiveServer as follows. We recommend to install it in your global environment.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> ]\npkg> activate\npgk> add LiveServer","category":"page"},{"location":"manual/for_developers/#Quick-build","page":"For developers","title":"Quick build","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The standard build takes a long time since it runs several examples. This delay makes this approach impractical to write documentation, since one needs to build the docs often to check the final result.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"To avoid this, one can run all the files in docs/src/src_jl in advance using","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/make_media.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"and then one can quickly build the documentation with","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/make_with_media.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"This will work as long as you are not including new figures or animations that are generated by running the files in the docs/src/src_jl folder. Otherwise you will need to run the particular file with","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/src/src_jl/<file that generates the figure>.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"or running again","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"julia> include(\"docs/media.jl\")","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The output documentation is not exactly the same as the generated with the standard build method, but it is good enough for development.","category":"page"},{"location":"manual/for_developers/#Performance-Benchmarks","page":"For developers","title":"Performance Benchmarks","text":"","category":"section"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"There is a benchmark suite defined in GalerkinToolkitExamples/benchmarks. This uses BenchmarkTools.jl to perform the timings and github-action-benchmark to collect the results and store them in the benchmarks branch. Upon merging of a PR, and after the docs have built, the benchmark results are copied from the benchmarks branch into the gh-pages branch. This is required to prevent overwriting of the previous results by docs deployment etc.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"Graphs of performance changes over time (per commit hash) can then be viewed here: https://galerkintoolkit.github.io/GalerkinToolkit.jl/dev/bench/.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"The github action can be configured (in .github/workflows/CI.yml, job benchmark) to fail if the performance change is beyond a given threshold. Look for the alert-threshold: and fail-on-alert: keys.","category":"page"},{"location":"manual/for_developers/","page":"For developers","title":"For developers","text":"More benchmarks can be added (or existing ones modified) in GalerkinToolkitExamples/benchmarks/run_benchmarks.jl.","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"EditURL = \"../src_jl/example_stokes.jl\"","category":"page"},{"location":"src_md/example_stokes/#Stokes-lid-driven-cavity","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"","category":"section"},{"location":"src_md/example_stokes/#Problem-statement","page":"Stokes lid-driven cavity","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"We solve the lid-driven cavity for a stokes flow. We use an inf-sub stable high order formulation. The velocity is a continuous piecewise multi-linear polynomial of order order and the pressure is a discontinuous piecewise linear polinomyal of order order-1. We constraint the pressure to zero at an arbitrary point of the domain (the last pressure node) to end up with a problem with unique solution.","category":"page"},{"location":"src_md/example_stokes/#Implementation","page":"Stokes lid-driven cavity","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport GLMakie as Makie\nimport ForwardDiff\nimport StaticArrays\nimport Tensors\nusing LinearAlgebra\nimport FileIO # hide\ndomain = (0,1,0,1)\ncells = (20,20)\nD = length(cells)\nmesh = GT.cartesian_mesh(domain,cells)\nΩ = GT.interior(mesh)\nΓ1 = GT.boundary(mesh;physical_names=[\"1-face-2\"])\nΓ2 = GT.boundary(mesh;physical_names=[\"1-face-1\",\"1-face-3\",\"1-face-4\"])\ng1 = GT.analytical_field(x->StaticArrays.SVector(1,0),Ω)\ng2 = GT.analytical_field(x->StaticArrays.SVector(0,0),Ω)\ng = GT.piecewise_field(g1,g2)\nΓ = GT.piecewise_domain(Γ1,Γ2)\norder = 2\nV = GT.lagrange_space(Ω,order;space_type=:Q,tensor_size=Val((D,)),dirichlet_boundary=Γ)\nQ = GT.lagrange_space(Ω,order-1;space_type=:P,dirichlet_boundary=GT.last_dof())\nVxQ = V × Q\nu_field, p_field = 1,2\nuhph_dirichlet = GT.dirichlet_field(Float64,VxQ)\nuhd = GT.field(uhph_dirichlet,u_field)\nGT.interpolate_dirichlet!(g,uhd)\ndΩ = GT.measure(Ω,2*order)\n∇ = ForwardDiff.jacobian\ndiv(u,x) = tr(∇(u,x))\na((u,p),(v,q)) = GT.∫( x-> ∇(v,x)⋅∇(u,x) - div(v,x)*p(x) + q(x)*div(u,x), dΩ)\nl((v,q)) = 0\np = GT.linear_problem(uhph_dirichlet,a,l)\ns = PS.LinearAlgebra_lu(p)\ns = PS.solve(s)\nuh,ph = GT.solution_field(uhph_dirichlet,s)\nMakie.plot(Ω,color=ph)\nMakie.arrows!(uh;color=x->norm(uh(x)),lengthscale=0.1)\nFileIO.save(joinpath(@__DIR__,\"fig_stokes.png\"),Makie.current_figure()) # hide","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"(Image: )","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"","category":"page"},{"location":"src_md/example_stokes/","page":"Stokes lid-driven cavity","title":"Stokes lid-driven cavity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"EditURL = \"../src_jl/tutorial_intro_to_fem.jl\"","category":"page"},{"location":"src_md/tutorial_intro_to_fem/#Introduction-to-FEM","page":"Introduction to FEM","title":"Introduction to FEM","text":"","category":"section"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"","category":"page"},{"location":"src_md/tutorial_intro_to_fem/","page":"Introduction to FEM","title":"Introduction to FEM","text":"This page was generated using Literate.jl.","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"EditURL = \"../src_jl/example_hello_world_manual.jl\"","category":"page"},{"location":"src_md/example_hello_world_manual/#Hello,-World!-(manual-assembly)","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"","category":"section"},{"location":"src_md/example_hello_world_manual/#Problem-statement","page":"Hello, World! (manual assembly)","title":"Problem statement","text":"","category":"section"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"We solve the same problem as in the Hello, World! example, but in this case we explicitly write the numerical integration loops.","category":"page"},{"location":"src_md/example_hello_world_manual/#Implementation","page":"Hello, World! (manual assembly)","title":"Implementation","text":"","category":"section"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Load dependencies form Julia stdlib.","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"using LinearAlgebra","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Import other dependencies","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"import GalerkinToolkit as GT\nimport PartitionedSolvers as PS\nimport ForwardDiff","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Setup the objects defining this example","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function setup_example(;domain,cells)\n    mesh = GT.cartesian_mesh(domain,cells)\n    dirichlet_tag = \"dirichlet\"\n    GT.label_boundary_faces!(mesh;physical_name=dirichlet_tag)\n    Ω = GT.interior(mesh)\n    Γd = GT.boundary(mesh;physical_names=[dirichlet_tag])\n    ∇ = ForwardDiff.gradient\n    Δ(f,x) = tr(ForwardDiff.jacobian(y->∇(f,y),x))\n    g = GT.analytical_field(sum,Ω)\n    f = GT.analytical_field(x->-Δ(g.definition,x),Ω)\n    k = 1\n    V = GT.lagrange_space(Ω,k;dirichlet_boundary=Γd)\n    T = Float64\n    uhd = GT.dirichlet_field(T,V)\n    GT.interpolate_dirichlet!(g,uhd)\n    degree = 2*k\n    dΩ = GT.measure(Ω,degree)\n    example = (;mesh,Ω,dΩ,V,uhd,T,f,g)\n    state = (;example)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Create accessor functions for low-level integration quantities.","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function setup_integration_accessors(state)\n    (;dΩ) = state.example\n    face_point_x = GT.coordinate_accessor(dΩ)\n    face_point_J = GT.jacobian_accessor(dΩ)\n    face_point_dV = GT.weight_accessor(dΩ)\n    face_npoints = GT.num_points_accessor(dΩ)\n    integration = (;\n        face_point_x,face_point_J, face_point_dV,face_npoints)\n    (;integration,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Create accessor functions for low-level interpolation quantities.","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function setup_interpolation_accessors(state)\n    (;dΩ,Ω,V,uhd) = state.example\n    face_dofs = GT.dofs_accessor(V,Ω)\n    face_point_dof_s = GT.shape_function_accessor(GT.value,V,dΩ)\n    face_point_dof_∇s = GT.shape_function_accessor(ForwardDiff.gradient,V,dΩ)\n    face_dirichlet! = GT.dirichlet_accessor(uhd,Ω)\n    interpolation = (;\n        face_dofs,face_point_dof_s,face_point_dof_∇s,face_dirichlet!)\n    (;interpolation,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Compute local matrix and vector","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function face_tensors!(Auu,bu,face,state)\n\n    (;example,integration,interpolation) = state\n    (;f) = example\n\n    #Get quantities at current face\n    npoints = integration.face_npoints(face)\n    point_x = integration.face_point_x(face)\n    point_J = integration.face_point_J(face)\n    point_dV = integration.face_point_dV(face)\n    point_dof_s = interpolation.face_point_dof_s(face)\n    point_dof_∇s = interpolation.face_point_dof_∇s(face)\n    dofs = interpolation.face_dofs(face)\n    dirichlet! = interpolation.face_dirichlet!(face)\n\n    #Reset face matrix and vector\n    fill!(Auu,zero(eltype(Auu)))\n    fill!(bu,zero(eltype(bu)))\n\n    #Loop over integration points\n    for point in 1:npoints\n\n        #Get quantities at current integration point\n        x = point_x(point)\n        J = point_J(point)\n        dV = point_dV(point,J)\n        dof_s = point_dof_s(point)\n        dof_∇s = point_dof_∇s(point,J)\n\n        #Fill in face matrix and vector\n        for (i,dofi) in enumerate(dofs)\n            v = dof_s(i)\n            ∇v = dof_∇s(i)\n            bu[i] += f.definition(x)*v*dV\n            for (j,dofj) in enumerate(dofs)\n                ∇u = dof_∇s(j)\n                Auu[i,j] += ∇v⋅∇u*dV\n            end\n        end\n    end\n\n    #Apply Dirichlet conditions on face vector\n    dirichlet!(Auu,bu)\n\n    #Return dof ids for this face\n    dofs\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Assemble linear problem","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function assemble_problem(state)\n\n    (;example) = state\n    (;V,Ω,T,f) = example\n\n    #Allocate auxiliary face matrix and vector\n    n = maximum(map(GT.num_dofs,GT.reference_spaces(V)))\n    Auu = zeros(T,n,n)\n    bu = zeros(T,n)\n\n    #Allocate space for the global matrix and vector\n    b_alloc = GT.allocate_vector(T,V,Ω)\n    A_alloc = GT.allocate_matrix(T,V,V,Ω)\n\n    #Loop over the faces of the domain\n    for face in 1:GT.num_faces(Ω)\n\n        #Compute face tensors\n        dofs = face_tensors!(Auu,bu,face,state)\n\n        #Add face contribution to global allocation\n        GT.contribute!(b_alloc,bu,dofs)\n        GT.contribute!(A_alloc,Auu,dofs,dofs)\n    end\n\n    #Compress matrix and vector into the final format\n    b = GT.compress(b_alloc)\n    A = GT.compress(A_alloc)\n\n    #Allocate space for the solution\n    sol = similar(b,axes(A,2))\n\n    #Create linear problem object\n    problem = PS.linear_problem(sol,A,b)\n    (;problem,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Solve the solution problem and build the solution field","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function solve_problem(state)\n    (;problem,example) = state\n    (;uhd) = example\n    solver = PS.LinearAlgebra_lu(problem)\n    solver = PS.solve(solver)\n    uh = GT.solution_field(uhd,solver)\n    (;uh,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Setup accessor functions to integrate error norms","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function setup_postpro_accessors(state)\n    (;uh,example) = state\n    (;dΩ) = example\n    #TODO add also h1 norm\n    face_point_uhx = GT.discrete_field_accessor(GT.value,uh,dΩ)\n    postpro = (;face_point_uhx)\n    (;postpro,state...)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Compute the error norms","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function integrate_error_norms(state)\n    (;postpro,example,integration) = state\n    (;Ω,dΩ,g,T) = example\n    #TODO add also h1 norm\n    el2 = zero(T)\n    for face in 1:GT.num_faces(Ω)\n        npoints = integration.face_npoints(face)\n        point_x = integration.face_point_x(face)\n        point_J = integration.face_point_J(face)\n        point_dV = integration.face_point_dV(face)\n        point_uhx = postpro.face_point_uhx(face)\n        for point in 1:npoints\n            x = point_x(point)\n            J = point_J(point)\n            dV = point_dV(point,J)\n            uhx = point_uhx(point,J)\n            el2 += abs2(uhx-g.definition(x))*dV\n        end\n    end\n    el2 = sqrt(el2)\n    norms = (;el2)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/#Final-Program","page":"Hello, World! (manual assembly)","title":"Final Program","text":"","category":"section"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"function main(;kwargs...)\n    state1 = setup_example(;kwargs...)\n    state2 = setup_integration_accessors(state1)\n    state3 = setup_interpolation_accessors(state2)\n    state4 = assemble_problem(state3)\n    state5 = solve_problem(state4)\n    state6 = setup_postpro_accessors(state5)\n    norms = integrate_error_norms(state6)\nend\nnothing # hide","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Run it for a 2d case","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"main(domain=(0,1,0,1),cells=(10,10))","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"Run it for a 3d case","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"main(domain=(0,1,0,1,0,1),cells=(10,10,10))","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"","category":"page"},{"location":"src_md/example_hello_world_manual/","page":"Hello, World! (manual assembly)","title":"Hello, World! (manual assembly)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#API","page":"API","title":"API","text":"","category":"section"},{"location":"reference/","page":"API","title":"API","text":"Modules = [GalerkinToolkit]","category":"page"},{"location":"reference/#GalerkinToolkit.AbstractDomain","page":"API","title":"GalerkinToolkit.AbstractDomain","text":"abstract type AbstractDomain{A} <: AbstractType end\n\nAbstract type representing a subset of mathbbR^d, typically din0123. Domains are defined using an underlying computational mesh. A is an (abstract) type indicating on which type of mesh this domain is defined.\n\nSee also AbstractMesh.\n\nLevel\n\nBeginner\n\nBasic constructors\n\nunit_simplex\nunit_n_cube\ndomain\ninterior\nboundary\nskeleton\n\nBasic queries\n\nnum_dims\nnum_ambient_dims\nnum_codims\nis_axis_aligned\nis_simplex\nis_n_cube\nis_unit_n_cube\nis_unit_simplex\nis_unitary\nbounding_box\nvertex_permutations\nmesh\nfaces\ninverse_faces\noptions\nis_boundary\nface_around\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceDomain","page":"API","title":"GalerkinToolkit.AbstractFaceDomain","text":"abstract type AbstractFaceDomain <: AbstractDomain{AbstractMesh} end\n\nA domain defined on a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\nBasic constructors\n\nunit_simplex\nunit_n_cube\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceSpace","page":"API","title":"GalerkinToolkit.AbstractFaceSpace","text":"abstract type AbstractFaceSpace <: AbstractSpace{AbstractMesh} end\n\nLike AbstractSpace, but for a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractFaceTopology","page":"API","title":"GalerkinToolkit.AbstractFaceTopology","text":"abstract type AbstractFaceTopology <: AbstractTopology end\n\nLike AbstractTopology, but for a single mesh face. Typically used as helper to identify cases that only make sense for a single mesh face.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractMesh","page":"API","title":"GalerkinToolkit.AbstractMesh","text":"abstract type AbstractMesh <: AbstractType end\n\nAbstract type representing a triangulation of a subset of mathbbR^d, typically din0123, plus metadata useful in finite element computations, such as physical groups for imposing boundary conditions.\n\nNotation\n\nEach of of the elements of the triangulation is referred to as a face. A mesh can contain faces of different dimensions. A mesh might or might not represent a cell complex (all possible low dimensional faces are present in the mesh), but it is often assumed that it represents a cell complex.\n\nLevel\n\nBeginner\n\nBasic constructors\n\nmesh\nchain\nmesh_from_gmsh\nmesh_from_space\ncartesian_mesh\ncomplexify\nsimplexify\n\nBasic queries\n\nnum_dims\nnum_ambient_dims\nnum_codims\nnum_faces\nnum_nodes\nnode_coordinates\nface_nodes\nface_reference_id\nreference_spaces\nperiodic_nodes\nphysical_faces\ngeometries\noutward_normals\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractPMesh","page":"API","title":"GalerkinToolkit.AbstractPMesh","text":"\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractQuadrature","page":"API","title":"GalerkinToolkit.AbstractQuadrature","text":"abstract type AbstractQuadrature\n\nBasic queries\n\ndomain\ncoordinates\nweights\nnum_points\nface_reference_id\nreference_quadratures\n\nBasic constructors\n\nquadrature\nduffy_quadrature\ntensor_product_quadrature\nnode_quadrature\n\nSupertype hierarchy\n\nAbstractQuadrature <: GT.AbstractType\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractSpace","page":"API","title":"GalerkinToolkit.AbstractSpace","text":"abstract type AbstractSpace{A} <: AbstractType end\n\nAbstract type representing a finite element space.  A is an (abstract) type  indicating on which type of mesh this domain is defined.\n\nLevel\n\nBasic\n\nBasic constructors\n\nlagrange_space raviart_thomas_space\n\nBasic queries\n\ndomain\nnum_dofs\nface_dofs\nface_nodes\nface_reference_id\nreference_spaces\ngeometry_own_dofs\ngeometry_own_dofs_permutations\n\nAdditional queries\n\nFor spaces, used as reference spaces in AbstractMesh specializations.\n\nnum_nodes\ninterior_nodes\ninterior_nodes_permutations\ngeometry_interior_nodes\ngeometry_interior_nodes_permutations\ngeometry_nodes\ngeometry_nodes_permutations\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractTopology","page":"API","title":"GalerkinToolkit.AbstractTopology","text":"abstract type AbstractTopology\n\nAbstract type representing the incidence relations in a cell complex.\n\nSee also AbstractFaceTopology.\n\nLevel\n\nIntermediate\n\nBasic constructors\n\ntopology\n\nBasic queries\n\nface_incidence\nface_reference_id\nface_permutation_ids\nreference_topologies\nvertex_permutations\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.AbstractType","page":"API","title":"GalerkinToolkit.AbstractType","text":"abstract type AbstractType end\n\nParent of all types defined in GalerkinToolkit.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.Options","page":"API","title":"GalerkinToolkit.Options","text":"struct Options{...} <: AbstractType\n\nType of the objects returned by function options. All properties and type parameters are private.\n\nBasic queries\n\nreference_int_type\nint_type\nglobal_int_type\nreal_type\n\n\n\n\n\n","category":"type"},{"location":"reference/#GalerkinToolkit.boundary","page":"API","title":"GalerkinToolkit.boundary","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.bounding_box","page":"API","title":"GalerkinToolkit.bounding_box","text":"p0,p1 = bounding_box(x)\n\nReturn a tuple of two vectors, where the vectors p0 and p1 define the span of the bounding box of x.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.cartesian_mesh-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.cartesian_mesh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.chain-Tuple{}","page":"API","title":"GalerkinToolkit.chain","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.complexify","page":"API","title":"GalerkinToolkit.complexify","text":"complexify(x)\n\nConvert x into a mesh representing a cell complex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.coordinates","page":"API","title":"GalerkinToolkit.coordinates","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.domain","page":"API","title":"GalerkinToolkit.domain","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.duffy_quadrature-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.duffy_quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.face_around","page":"API","title":"GalerkinToolkit.face_around","text":"face_around(x)\n\nReturn an integer that allows to break ties when faces in x need to point to faces around of one dimension higher. Return nothing if x does not break such ties.\n\nNote: This function will eventually return a vector of integers.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_dofs","page":"API","title":"GalerkinToolkit.face_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_incidence","page":"API","title":"GalerkinToolkit.face_incidence","text":"face_incidence(x,d)\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_nodes","page":"API","title":"GalerkinToolkit.face_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_permutation_ids","page":"API","title":"GalerkinToolkit.face_permutation_ids","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.face_reference_id","page":"API","title":"GalerkinToolkit.face_reference_id","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.faces","page":"API","title":"GalerkinToolkit.faces","text":"faces(x)\n\nReturn the subset of face ids in mesh(x) of dimension num_dims(x) defining the domain x. This is effectively the map from domain face id to mesh face id.\n\nSee also inverse_faces.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometries","page":"API","title":"GalerkinToolkit.geometries","text":"geometries(x,d)\ngeometries(x,Val(d))\n\nReturn a vector of domains representing the geometrical entities of x of dimension d. The returned domains and x are defined on the same mesh. That is, faces(geometries(x,1)[2]) are the face ids in mesh(x) representing the second edge of x.\n\nNotation\n\ngeometries(x,Val(0)) are referred to as the vertices of x. geometries(x,Val(1)) are referred to as the edges of x. geometries(x,Val(d)) are referred to as the d-faces of x.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_interior_nodes","page":"API","title":"GalerkinToolkit.geometry_interior_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_interior_nodes_permutations","page":"API","title":"GalerkinToolkit.geometry_interior_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_nodes","page":"API","title":"GalerkinToolkit.geometry_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_nodes_permutations","page":"API","title":"GalerkinToolkit.geometry_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_own_dofs","page":"API","title":"GalerkinToolkit.geometry_own_dofs","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.geometry_own_dofs_permutations","page":"API","title":"GalerkinToolkit.geometry_own_dofs_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.global_int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.global_int_type","text":"global_int_type(options::Options)\n\nReturn the type of the integers used to enumerate global quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.int_type","text":"int_type(options::Options)\n\nReturn the default integer type used in the computation except for reference and global quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.interior","page":"API","title":"GalerkinToolkit.interior","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.interior_node_permutations-Tuple{GalerkinToolkit.LagrangeFaceSpace}","page":"API","title":"GalerkinToolkit.interior_node_permutations","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.interior_nodes","page":"API","title":"GalerkinToolkit.interior_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.interior_nodes_permutations","page":"API","title":"GalerkinToolkit.interior_nodes_permutations","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.inverse_faces","page":"API","title":"GalerkinToolkit.inverse_faces","text":"inverse_faces(x)\n\nReturn the inverse integer mas of faces(x). This is effectively the map from mesh face id to domain face id. Mesh faces not present in the domain, receive an invalid index id.\n\nSee also faces.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_axis_aligned","page":"API","title":"GalerkinToolkit.is_axis_aligned","text":"is_axis_aligned(x)\n\nTrue if x is a unit simplex or a unit cube.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_boundary","page":"API","title":"GalerkinToolkit.is_boundary","text":"is_boundary(x)\n\nTrue if x represent an (internal) boundary. Faces in an internal boundary \"point\" to only of the two faces around of a dimension higher.\n\nSee also face_around.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_n_cube","page":"API","title":"GalerkinToolkit.is_n_cube","text":"is_n_cube(x)\n\nTrue if x is a n-cube (hypercube).\n\nSee also is_simplex, is_unit_simplex, is_unit_n_cube.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_simplex","page":"API","title":"GalerkinToolkit.is_simplex","text":"is_simplex(x)\n\nTrue if x is a simplex.\n\nSee also is_n_cube, is_unit_simplex, is_unit_n_cube.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unit_n_cube","page":"API","title":"GalerkinToolkit.is_unit_n_cube","text":"is_unit_n_cube(x)\n\nTrue if x is a unit n-cube.\n\nSee also is_n_cube, is_unit_simplex, is_simplex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unit_simplex","page":"API","title":"GalerkinToolkit.is_unit_simplex","text":"is_unit_simplex(x)\n\nTrue if x is a unit simplex.\n\nSee also is_n_cube, is_unit_n_cube, is_simplex.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.is_unitary","page":"API","title":"GalerkinToolkit.is_unitary","text":"is_unitary(x)\n\nTrue bounding_box(x) coincides with a unit n-cube.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.lagrange_space","page":"API","title":"GalerkinToolkit.lagrange_space","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.mesh-Tuple{GalerkinToolkit.Chain}","page":"API","title":"GalerkinToolkit.mesh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_gmsh-Tuple{Any}","page":"API","title":"GalerkinToolkit.mesh_from_gmsh","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.mesh_from_space","page":"API","title":"GalerkinToolkit.mesh_from_space","text":"mesh_from_space(space)\n\nReturn the mesh induced by space. For instance, a (high order) Lagrange space can be interpreted as a mesh using this function.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.node_coordinates","page":"API","title":"GalerkinToolkit.node_coordinates","text":"node_coordinates(x)\n\nReturn the vector of node coordinates associated with `x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.node_permutations-Tuple{GalerkinToolkit.LagrangeFaceSpace}","page":"API","title":"GalerkinToolkit.node_permutations","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.node_quadrature","page":"API","title":"GalerkinToolkit.node_quadrature","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_ambient_dims","page":"API","title":"GalerkinToolkit.num_ambient_dims","text":"num_ambient_dims(x)\n\nReturn the ambient dimension where object x lives.\n\nSee also num_codims, num_dims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_codims","page":"API","title":"GalerkinToolkit.num_codims","text":"num_codims(x)\n\nReturn num_ambient_dims(x)-num_dims(x).\n\nSee also num_ambient_dims, num_dims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_dims","page":"API","title":"GalerkinToolkit.num_dims","text":"num_dims(x)\n\nReturn the parametric dimension of x.\n\nSee also num_ambient_dims, num_codims.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_dofs","page":"API","title":"GalerkinToolkit.num_dofs","text":"num_dofs(x)\n\nReturn the number of degrees of freedom of x.\n\nSee also num_nodes.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_faces","page":"API","title":"GalerkinToolkit.num_faces","text":"num_faces(x)\nnum_faces(x,d)\n\nReturn the number of faces  of dimension d in mesh(x). If d is omitted, return a vector with the number of faces in each dimension, starting from dimension 0 up to num_dims(x).\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_nodes","page":"API","title":"GalerkinToolkit.num_nodes","text":"num_nodes(x)\n\nReturn the number of nodes of x.\n\nSee also num_dofs.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.num_points","page":"API","title":"GalerkinToolkit.num_points","text":"num_points(x)\n\nReturn the number of integration points in x.\n\nSee also num_nodes.\n\nLevel\n\nBeginner\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.options-Tuple{}","page":"API","title":"GalerkinToolkit.options","text":"options(;kwargs...) -> Options\n\nCreate an object representing the default options for the current simulation. This object can be used as an optional argument in several object constructors in GalerkinToolkit, such as the mesh constructors cartesian_mesh and mesh_from_gmsh. In this case, the computations using the generated mesh, will use the given options by default.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.outward_normals","page":"API","title":"GalerkinToolkit.outward_normals","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.periodic_nodes","page":"API","title":"GalerkinToolkit.periodic_nodes","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.physical_faces","page":"API","title":"GalerkinToolkit.physical_faces","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.physical_names-Tuple{Any, Any}","page":"API","title":"GalerkinToolkit.physical_names","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.push","page":"API","title":"GalerkinToolkit.push","text":"push(a,ai)\n\nLike push!, but creates a new object to store the result.  This function is used to push to immutable collections such as tuples.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.quadrature-Tuple{GalerkinToolkit.AbstractFaceDomain, Any}","page":"API","title":"GalerkinToolkit.quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.raviart_thomas_space","page":"API","title":"GalerkinToolkit.raviart_thomas_space","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.real_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.real_type","text":"real_type(options::Options)\n\nReturn the default real type used in the computation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.reference_int_type-Tuple{GalerkinToolkit.Options}","page":"API","title":"GalerkinToolkit.reference_int_type","text":"reference_int_type(options::Options)\n\nReturn the type of the integers used to enumerate reference quantities.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.reference_quadratures","page":"API","title":"GalerkinToolkit.reference_quadratures","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_spaces","page":"API","title":"GalerkinToolkit.reference_spaces","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.reference_topologies","page":"API","title":"GalerkinToolkit.reference_topologies","text":"reference_topologies(x)\nreference_topologies(x,d)\nreference_topologies(x,Val(d))\n\nReturn the list (a vector or a tuple) of reference topologies in x of dimension d. If the second argument is omitted, return a tuple with the reference topologies in each dimension, starting from dimension 0 up to num_dims(x).\n\nSee also face_reference_id.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.shape_functions-Tuple{GalerkinToolkit.AbstractSpace}","page":"API","title":"GalerkinToolkit.shape_functions","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.simplexify","page":"API","title":"GalerkinToolkit.simplexify","text":"simplexify(x)\n\nConvert x into a mesh made of simplex cells.\n\nLevel\n\nIntermediate\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.skeleton","page":"API","title":"GalerkinToolkit.skeleton","text":"\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.tabulator-Tuple{GalerkinToolkit.AbstractSpace}","page":"API","title":"GalerkinToolkit.tabulator","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.tensor_product_quadrature-Tuple{GalerkinToolkit.AbstractFaceDomain, Any}","page":"API","title":"GalerkinToolkit.tensor_product_quadrature","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.topology-Tuple{GalerkinToolkit.AbstractMesh}","page":"API","title":"GalerkinToolkit.topology","text":"\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.unit_n_cube-Tuple{Any}","page":"API","title":"GalerkinToolkit.unit_n_cube","text":"unit_n_cube(d)\nunit_n_cube(Val(d))\n\nReturn an object representing a unit d-cube.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.unit_simplex-Tuple{Any}","page":"API","title":"GalerkinToolkit.unit_simplex","text":"unit_simplex(d)\nunit_simplex(Val(d))\n\nReturn an object representing a unit simplex of dimension d.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.val_parameter-Tuple{Any}","page":"API","title":"GalerkinToolkit.val_parameter","text":"val_parameter(a)\n\nFor a::Val{A} it returns A. Otherwise, it returns a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GalerkinToolkit.vertex_permutations","page":"API","title":"GalerkinToolkit.vertex_permutations","text":"vertex_permutations(x)\n\nReturn a list of permutations representing the admissible re-labelings of the vertices of x.\n\nLevel\n\nAdvanced\n\n\n\n\n\n","category":"function"},{"location":"reference/#GalerkinToolkit.weights","page":"API","title":"GalerkinToolkit.weights","text":"\n\n\n\n","category":"function"},{"location":"refindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"refindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GalerkinToolkit","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#What","page":"Home","title":"What","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package aims at providing a fully-fledged finite-element toolbox in pure Julia, with support for different computing systems from laptops to supercomputers and GPUs.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"NB. This package is work in progress; a proof-of-concept API is already available (for CPUs). The package is not production ready at this point. Planned performance and documentation improvements are needed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warn: Warn\nTODO elaborary more","category":"page"},{"location":"#Why","page":"Home","title":"Why","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package follows a new approach to implement finite-element methods based on the lessons learned in the Gridap project.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warn: Warn\nTODO elaborary more","category":"page"}]
}
